Code,JavaDoc,Package
PermissionOverride realOverride = channel.getPermissionOverrideMap().get(override.getIdLong());,"/**
     * Creates a new PermOverrideManager instance
     *
     * @param override
     *        The {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverride} to manage
     */",net.dv8tion.jda.internal.managers
"public static final Route GUILD_LEAVE = Route.delete(""/users/@me/guilds/{guild.id}"");","/**
     * Leave a guild. Returns a 204 empty response on success.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/user#leave-guild"">
     * https://discord.com/developers/docs/resources/user#leave-guild</a>
     */",discord4j.rest.route
"public LegacyRoleEditSpec setHoist(boolean hoist) {
        requestBuilder.hoist(hoist);
        return this;
    }","/**
     * Sets whether the modified {@link Role} should be displayed separately in the sidebar.
     *
     * @param hoist The role hoisted property.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
    @Unmodifiable
    default List<TextChannel> getTextChannels()
    {
        return getTextChannelCache().asList();
    }","/**
     * Gets all {@link TextChannel TextChannels} in the cache.
     * <br>In {@link Guild} cache, channels are sorted according to their position and id.
     *
     * <p>This copies the backing store into a list. This means every call
     * creates a new list with O(n) complexity. It is recommended to store this into
     * a local variable or use {@link #getTextChannelCache()} and use its more efficient
     * versions of handling these values.
     *
     * <p>This getter exists on any instance of {@link IGuildChannelContainer} and only checks the caches with the relevant scoping.
     * For {@link Guild}, {@link JDA}, or {@link ShardManager},
     * this returns the relevant channel with respect to the cache within each of those objects.
     * For a guild, this would mean it only returns channels within the same guild.
     * <br>If this is called on {@link JDA} or {@link ShardManager}, this may return null immediately after building, because the cache isn't initialized yet.
     * To make sure the cache is initialized after building your {@link JDA} instance, you can use {@link JDA#awaitReady()}.
     *
     * @return An immutable List of all {@link TextChannel TextChannels} in this Guild.
     */",net.dv8tion.jda.api.entities.channel.attribute
MemberData getMemberData();,"/**
     * Return the raw member data that created this interaction.
     *
     * @return a member data object
     */",discord4j.rest.interaction
The maximum amount of welcome channel a welcome screen can show ({@value},/** The maximum length of a welcome screen description ({@value}) */,net.dv8tion.jda.api.entities
"public Optional<User> getOld() {
        return Optional.ofNullable(old);
    }","/**
     * Gets the old version of the {@link User} that has been updated in this event, if present.
     * This may not be available if {@code Users} are not stored.
     *
     * @return The old version of the {@link User} that has been updated in this event, if present.
     */",discord4j.core.event.domain
"@Nonnull
    @CheckReturnValue
    GuildManager removeFeatures(@Nonnull Collection<String> features);","/**
     * Removes a {@link Guild#getFeatures() Guild Feature} from the list of features.
     * <br>The list of available features, including which ones can be configured, is available in the
     * <a href=""https://discord.com/developers/docs/resources/guild#guild-object-guild-features"" target=""_blank"">Official Discord API Documentation</a>.
     *
     * @param  features
     *         The features to remove
     *
     * @throws IllegalArgumentException
     *         If any of the provided features is null
     *
     * @return GuildManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"Pattern WEBHOOK_URL = Pattern.compile(""https?://(?:[^\\s.]+\\.)?discord(?:app)?\\.com/api(?:/v\\d+)?/webhooks/(?<id>\\d+)/(?<token>[^\\s/]+)"", Pattern.CASE_INSENSITIVE);","/**
     * Pattern for a Webhook URL.
     *
     * <p><b>Groups</b><br>
     * <table>
     *   <caption style=""display: none"">Javadoc is stupid, this is not a required tag</caption>
     *   <tr>
     *     <th>Index</th>
     *     <th>Name</th>
     *     <th>Description</th>
     *   </tr>
     *   <tr>
     *     <td>0</td>
     *     <td>N/A</td>
     *     <td>The entire link</td>
     *   </tr>
     *   <tr>
     *     <td>1</td>
     *     <td>id</td>
     *     <td>The ID of the webhook</td>
     *   </tr>
     *   <tr>
     *     <td>2</td>
     *     <td>token</td>
     *     <td>The token of the webhook</td>
     *   </tr>
     * </table>
     *
     * You can use the names with {@link java.util.regex.Matcher#group(String) Matcher.group(String)}
     * and the index with {@link java.util.regex.Matcher#group(int) Matcher.group(int)}.
     */",net.dv8tion.jda.api.entities
"public static GuildRoleCreateAction guildRoleCreate(int shardIndex, GuildRoleCreate dispatch) {
        return new GuildRoleCreateAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link GuildRoleCreate} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link GuildRoleCreateAction}
     */",discord4j.common.store.action.gateway
"public LegacyWebhookCreateSpec setName(String name) {
        this.name = name;
        return this;
    }","/**
     * Sets the name of the created {@link Webhook}.
     *
     * @param name The webhook name.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nullable
        default JDA.ShardInfo getShardInfo()
        {
            return getJDA().getShardInfo();
        }","/**
         * Shortcut to access the shard info for this JDA instance
         *
         * @return The shard information, or null if this was not for a sharded client
         */",net.dv8tion.jda.api.hooks
"public Optional<Snowflake> getBotId() {
        return data.botId().toOptional().map(Snowflake::of);
    }","/**
     * Gets the id of the bot this role belongs to, if present.
     *
     * @return The id of the bot this role belongs to, if present.
     */",discord4j.core.object
"@Nullable
    public Map<String, Set<String>> getHeaders() {
        return headers;
    }","/**
     * Return the request headers, if present.
     *
     * @return a map representing HTTP headers, or {@code null} if none are defined
     */",discord4j.rest.request
"public static final Route GROUP_DM_RECIPIENT_DELETE = Route.delete(""/channels/{channel.id}/recipients/{user.id}"");","/**
     * Removes a recipient from a Group DM.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/channel#group-dm-remove-recipient"">
     * https://discord.com/developers/docs/resources/channel#group-dm-remove-recipient</a>
     */",discord4j.rest.route
public abstract int readInteger();,"/**
   * Reads a primitive integer from the terminal input.
   *
   * @return an int
   */",io.github.augustoravazoli.termenu.io
"public Mono<Channel> asFullChannel(EntityRetrievalStrategy retrievalStrategy) {
        return gateway.withRetrievalStrategy(retrievalStrategy).getChannelById(getId());
    }","/**
     * Retrieves the full {@link Channel} instance corresponding to this resolved channel, using the given retrieval
     * strategy.
     *
     * @return a {@link Mono} where, upon successful completion, emits the full {@link Channel} instance corresponding
     * to this resolved channel. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.object.command
"public Builder payloadSenderScheduler(Scheduler payloadSenderScheduler) {
            this.payloadSenderScheduler = payloadSenderScheduler;
            return this;
        }","/**
         * Set the {@link Scheduler} used for sending Gateway payloads. A default can be created from
         * {@link GatewayReactorResources#DEFAULT_PAYLOAD_SENDER_SCHEDULER}.
         *
         * @param payloadSenderScheduler a scheduler for payload tasks
         * @return this builder
         */",discord4j.gateway
"public Snowflake getWebhookId() {
        return Snowflake.of(data.webhookId());
    }","/**
     * Returns the ID of the webhook created as the result of following the news channel.
     *
     * @return the webhook ID
     */",discord4j.core.object
boolean hasPermission(@Nonnull Collection<Permission> permissions);,"/**
     * Checks whether or not this PermissionHolder has the {@link net.dv8tion.jda.api.Permission Permissions} in the provided
     * {@code Collection<Permission>} in the Guild.
     *
     * @param  permissions
     *         Permissions to check for.
     *
     * @throws IllegalArgumentException
     *         If null is provided
     *
     * @return True, if all of the specified Permissions are granted to this PermissionHolder.
     *
     * @see    java.util.EnumSet EnumSet
     */",net.dv8tion.jda.api.entities
"public static ReadyAction ready(Ready dispatch) {
        return new ReadyAction(dispatch);
    }","/**
     * Creates an action to execute when a {@link Ready} is received from the gateway.
     *
     * @param dispatch the dispatch data coming from Discord gateway
     * @return a new {@link ReadyAction}
     */",discord4j.common.store.action.gateway
void onEvent(@Nonnull GenericEvent event);,"/**
     * Handles any {@link net.dv8tion.jda.api.events.GenericEvent GenericEvent}.
     *
     * <p>To get specific events with Methods like {@code onMessageReceived(MessageReceivedEvent event)}
     * take a look at: {@link net.dv8tion.jda.api.hooks.ListenerAdapter ListenerAdapter}
     *
     * @param  event
     *         The Event to handle.
     */",net.dv8tion.jda.api.hooks
"public static UserUpdateAction userUpdate(int shardIndex, UserUpdate dispatch) {
        return new UserUpdateAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link UserUpdate} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link UserUpdateAction}
     */",discord4j.common.store.action.gateway
"public static GuildDeleteAction guildDelete(int shardIndex, GuildDelete dispatch) {
        return new GuildDeleteAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link GuildDelete} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link GuildDeleteAction}
     */",discord4j.common.store.action.gateway
"public static final Route AUDIT_LOG_GET = Route.get(""/guilds/{guild.id}/audit-logs"");","/**
     * Returns an audit log object for the guild. Requires the 'VIEW_AUDIT_LOG' permission.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/audit-log#get-guild-audit-log"">
     * https://discord.com/developers/docs/resources/audit-log#get-guild-audit-log</a>
     */",discord4j.rest.route
void saveSettings();,"/**
     * Save the settings.
     */",jestures.core.view
"@Nonnull
    @CheckReturnValue
    RoleAction setColor(@Nullable Integer rgb);","/**
     * Sets the Color for the new role.
     * This accepts colors from the range {@code 0x000} to {@code 0xFFFFFF}.
     * The provided value will be ranged using {@code rbg & 0xFFFFFF}
     *
     * @param  rgb
     *         The color for the new role in integer form, {@code null} to use default white/black
     *
     * @return The current RoleAction, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
"public Optional<Instant> getJoinTime() {
        return Optional.ofNullable(currentJoinedAt)
            .map(it -> DateTimeFormatter.ISO_OFFSET_DATE_TIME.parse(it, Instant::from));
    }","/**
     * Gets the current join time of the {@link Member} involved in this event, if present. It is typically absent if
     * this event is caused by a lurking stage channel member.
     *
     * @return The current join time of the {@link Member} involved in this event, if present.
     */",discord4j.core.event.domain.guild
"public static DiscordClientBuilder<DiscordClient, RouterOptions> builder(String token) {
        return DiscordClientBuilder.create(token);
    }","/**
     * Obtain a {@link DiscordClientBuilder} able to create {@link DiscordClient} instances, using the given token
     * for authentication.
     *
     * @param token the bot token used for authentication
     * @return a {@link DiscordClientBuilder}
     */",discord4j.core
"@Nonnull
    @CheckReturnValue
    default MessageCreateAction setStickers(@Nullable StickerSnowflake... stickers)
    {
        if (stickers != null)
            Checks.noneNull(stickers, ""Sticker"");
        return setStickers(stickers == null ? null : Arrays.asList(stickers));
    }","/**
     * Set the stickers to send alongside this message.
     * <br>This is not supported for message edits.
     *
     * @param  stickers
     *         The stickers to send, or null to not send any stickers
     *
     * @throws IllegalStateException
     *         If this request is a message edit request
     * @throws IllegalArgumentException
     *         <ul>
     *           <li>If any of the provided stickers is a {@link GuildSticker},
     *               which is either {@link GuildSticker#isAvailable() unavailable} or from a different guild.</li>
     *           <li>If the collection has more than {@value Message#MAX_STICKER_COUNT} stickers</li>
     *           <li>If a collection with null entries is provided</li>
     *         </ul>
     *
     * @return Updated MessageCreateAction for chaining convenience
     *
     * @see    Sticker#fromId(long)
     */",net.dv8tion.jda.api.requests.restaction
B create(byte [] data);,"/**
     * Create {@link threegpp.milenage.MilenageBuffer} object from the array of bytes.
     *
     * @param data  Array of bytes with length equal to {@link Milenage#BLOCK_LEN_BYTES}.
     * @return  {@link threegpp.milenage.MilenageBuffer} object.
     */",threegpp.milenage
"@SuppressWarnings(""unchecked"")
	public static void register(@SuppressWarnings(""rawtypes"") Map tagletMap) {
		WRMqConsumerTaglet tag = new WRMqConsumerTaglet();
		Taglet t = (Taglet) tagletMap.get(tag.getName());
		if (t != null) {
			tagletMap.remove(tag.getName());
		}
		tagletMap.put(tag.getName(), tag);
	}","/**
	 * Register this Taglet.
	 * 
	 * @param tagletMap
	 *            the map to register this tag to.
	 */",net.winroad.wrdoclet.taglets
"public LegacyGuildPruneSpec setDays(int days) {
        map.set(""days"", days);
        return this;
    }","/**
     * Set the number of days to prune.
     *
     * @param days the number of days
     * @return this spec
     */",discord4j.core.spec.legacy
public abstract boolean provide();,"/**
     * Called every 20 milliseconds and is expected to provide
     * <a href=""https://en.wikipedia.org/wiki/Opus_(audio_format)"">Opus</a>-encoded audio according to the format in
     * {@link Opus} by writing to the provider's {@link #getBuffer() buffer}.
     * @return Whether audio was provided (the buffer was mutated).
     */",discord4j.voice
"public static final Route WEBHOOK_EXECUTE = Route.post(""/webhooks/{webhook.id}/{webhook.token}"");","/**
     * This endpoint supports both JSON and form data bodies. It does require multipart/form-data requests instead of
     * the normal JSON request type when uploading files. Make sure you set your Content-Type to multipart/form-data if
     * you're doing that. Note that in that case, the embeds field cannot be used, but you can pass an url-encoded JSON
     * body as a form value for payload_json.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/webhook#execute-webhook"">
     * https://discord.com/developers/docs/resources/webhook#execute-webhook</a>
     */",discord4j.rest.route
"public Optional<String> getDescription() {
        return this.data.description();
    }","/**
     * Gets the description of the option.
     *
     * @return An {@link Optional} containing the description of the option or {@link Optional#empty()} if not present.
     */",discord4j.core.object.onboarding
"default void setPresence(@Nullable final OnlineStatus status, @Nullable final Activity activity)
    {
        this.setPresenceProvider(id -> status, id -> activity);
    }","/**
     * Sets the {@link net.dv8tion.jda.api.OnlineStatus OnlineStatus} and {@link net.dv8tion.jda.api.entities.Activity Activity} for all shards.
     *
     * <p>This will also change the status for shards that are created in the future.
     *
     * @param  status
     *         The {@link net.dv8tion.jda.api.OnlineStatus OnlineStatus}
     *         to be used (OFFLINE/null {@literal ->} INVISIBLE)
     * @param  activity
     *         A {@link net.dv8tion.jda.api.entities.Activity Activity} instance or null to reset
     *
     * @throws java.lang.IllegalArgumentException
     *         If the provided OnlineStatus is {@link net.dv8tion.jda.api.OnlineStatus#UNKNOWN UNKNOWN}
     *
     * @see    net.dv8tion.jda.api.entities.Activity#playing(String)
     * @see    net.dv8tion.jda.api.entities.Activity#streaming(String, String)
     */",net.dv8tion.jda.api.sharding
private static final Logger LOG = Logger.getLogger(FileManager.class);,"/*******************************************************************************
 * Copyright (c) 2018 Giulianini Luca Licensed under the Apache License, Version
 * 2.0 (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law
 * or agreed to in writing, software distributed under the License is
 * distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 *******************************************************************************/",jestures.core.file
"public RestEmoji emoji(Snowflake emojiId) {
        return RestEmoji.create(restClient, id, emojiId.asLong());
    }","/**
     * Return a {@link RestEmoji} representation under this guild. This method does not perform any API request.
     *
     * @param emojiId the entity ID
     * @return a {@code RestEmoji} with the given ID, under this guild
     */",discord4j.rest.entity
A factory class for the creation of gui components ({@link JFXListView},"/*******************************************************************************
 * Copyright (c) 2018 Giulianini Luca
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/",jestures.core.view.utils
"@Nonnull
    EnumSet<Permission> getPermissions();","/**
     * The Guild-Wide Permissions this PermissionHolder holds.
     * <br><u>Changes to the returned set do not affect this entity directly.</u>
     *
     * @return An EnumSet of Permissions granted to this PermissionHolder.
     */",net.dv8tion.jda.api.entities
boolean canProvide();,"/**
     * If this method returns true JDA will attempt to retrieve audio data from this handler by calling
     * {@link #provide20MsAudio()}. The return value is checked each time JDA attempts send audio, so if
     * the developer wanted to start and stop sending audio it could be done by changing the value returned
     * by this method at runtime.
     *
     * @return If true, JDA will attempt to retrieve audio data from {@link #provide20MsAudio()}
     */",net.dv8tion.jda.api.audio
void setRecognitionSettings(RecognitionSettings recognitionSettings) throws IOException;,"/**
     * Set the settings.
     *
     * @param recognitionSettings
     *            the {@link RecognitionSettings}
     * @throws IOException
     *             the {@link IOException}
     */",jestures.core.serialization
Flux<Dispatch> dispatch();,"/**
     * Obtains the {@link Flux} of {@link Dispatch} events inbound from the gateway connection made by this client.
     * <p>
     * Can be used like this, for example, to get all created message events:
     * <pre>
     * gatewayClient.dispatch().ofType(MessageCreate.class)
     *     .subscribe(message -&gt; {
     *         System.out.println(""Got a message with content: "" + message.getMessage().getContent());
     * });
     * </pre>
     *
     * @return a {@link Flux} of {@link Dispatch} values
     */",discord4j.gateway
"@Nonnull
    @CheckReturnValue
    RestAction<List<Invite>> retrieveInvites();","/**
     * Returns all invites for this channel.
     * <br>Requires {@link net.dv8tion.jda.api.Permission#MANAGE_CHANNEL MANAGE_CHANNEL} in this channel.
     * Will throw an {@link net.dv8tion.jda.api.exceptions.InsufficientPermissionException InsufficientPermissionException} otherwise.
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         if the account does not have {@link net.dv8tion.jda.api.Permission#MANAGE_CHANNEL MANAGE_CHANNEL} in this channel
     *
     * @return {@link net.dv8tion.jda.api.requests.RestAction RestAction} - Type: List{@literal <}{@link net.dv8tion.jda.api.entities.Invite Invite}{@literal >}
     *         <br>The list of expanded Invite objects
     *
     * @see    net.dv8tion.jda.api.entities.Guild#retrieveInvites()
     */",net.dv8tion.jda.api.entities.channel.attribute
"Flux<ScheduledEventUser> getScheduledEventUsers(Snowflake guildId, Snowflake eventId);","/**
     * Requests to retrieve the users that subscribed to the event represented by the supplied IDs.
     *
     * @return A {@link Flux} that continually emits the event's {@link ScheduledEventUser users}.
     * If an error is received, it is emitted through the {@code Flux}.
     */",discord4j.core.retriever
"@Nonnull
    @CheckReturnValue
    GuildManager setCommunityUpdatesChannel(@Nullable TextChannel communityUpdatesChannel);","/**
     * Sets the community updates {@link net.dv8tion.jda.api.entities.channel.concrete.TextChannel TextChannel} of this {@link net.dv8tion.jda.api.entities.Guild Guild}.
     *
     * @param  communityUpdatesChannel
     *         The new community updates channel for this {@link net.dv8tion.jda.api.entities.Guild Guild}
     *         or {@code null} to reset
     *
     * @throws IllegalArgumentException
     *         If the provided channel is not from this guild
     *
     * @return GuildManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"@Nonnull
    @CheckReturnValue
    ScheduledEventManager setLocation(@Nonnull String location);","/**
     * Sets the location of the selected {@link ScheduledEvent} to take place externally,
     * or not in a specific {@link GuildChannel}. <u>Please note that an event is required to have an end time set if
     * the location is external.</u>
     * <p>This will change the event's type to {@link ScheduledEvent.Type#EXTERNAL}
     *
     * @param  location
     *         The location that the selected {@link ScheduledEvent} is set to take place at.
     *
     * @throws java.lang.IllegalArgumentException
     *         If the provided location is blank, empty, {@code null}, or longer than
     *         {@value ScheduledEvent#MAX_LOCATION_LENGTH}
     * @throws java.lang.IllegalStateException
     *         If the selected {@link ScheduledEvent} does not have an end time
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have
     *         {@link net.dv8tion.jda.api.Permission#MANAGE_EVENTS Permission.MANAGE_EVENTS}
     *
     * @return ScheduledEventManager for chaining convenience
     *
     * @see    #setEndTime(TemporalAccessor)
     * @see    #setLocation(GuildChannel)
     */",net.dv8tion.jda.api.managers
MilenageBuffer<T> xor(final MilenageBuffer<T> that);,"/**
     * Performs bit exclusive OR (XOR) operation.
     *
     * @param that  Another {@link threegpp.milenage.MilenageBuffer} object to XOR with this
     * @return  New result {@link threegpp.milenage.MilenageBuffer} object
     */",threegpp.milenage
"public static DiscordClient create(String token) {
        return DiscordClientBuilder.create(token).build();
    }","/**
     * Create a {@link DiscordClient} with default options, using the given token for authentication.
     *
     * @param token the bot token used for authentication
     * @return a {@link DiscordClient} configured with the default options
     */",discord4j.core
"public String getName() {
        return name;
    }","/**
     * Gets the name of audit log change key.
     *
     * @return The name of audit log change key.
     */",discord4j.core.object.audit
"@Nonnull
    ScheduledEvent getScheduledEvent();","/**
     * The target {@link ScheduledEvent} for this manager
     */",net.dv8tion.jda.api.managers
"public Optional<String> getIconUrl(final Image.Format format) {
        return data.icon()
                .map(icon -> ImageUtil.getUrl(String.format(ICON_IMAGE_PATH, getId().asString(), icon), format));
    }","/**
     * Gets the icon URL of the application, if present.
     *
     * @param format The format for the URL.
     * @return The icon URL of the application, if present.
     */",discord4j.core.object.entity
"PayloadTransformer getIdentifyLimiter(ShardInfo shardInfo, int maxConcurrency);","/**
     * Returns a transformation function for a sequence of payloads that can be held or delayed in order to successfully
     * identify multiple shards in a coordinated manner.
     *
     * @param shardInfo the shard from where to retrieve the limiter
     * @param maxConcurrency the number of shards that can be concurrently identified
     * @return a {@link PayloadTransformer} allowing IDENTIFY payload coordination across shards
     */",discord4j.core.shard
"public AbstractRecognitionScreenView(final Recognition recognizer) {
        super(recognizer);
        this.recognizer = recognizer;
    }","/**
     * The constructor.
     *
     * @param recognizer
     *            the {@link Recognition} recognizer
     *
     */",jestures.core.view.screens
void attacheTracker(TrackingObserver recognizer);,"/**
     * Attache the {@link TrackerImpl} for feedback notification.
     *
     * @param recognizer
     *            the {@link TrackerImpl}
     */",jestures.core.codification
"Mono<Void> onGuildCreate(int shardIndex, GuildCreate dispatch);","/**
     * Updates the internal state of the store according to the given {@link GuildCreate} gateway dispatch. This
     * will typically perform an insert operation on the related {@link GuildData}, as well as all associated
     * entities received in the payload, such as channels, roles, emojis, members, voice states and presences.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a {@link Mono} completing when the operation is done
     */",discord4j.common.store.api.layout
Mono<Void> logout();,"/**
     * Instructs that on subscription this group should log out from Discord Gateway.
     *
     * @return a {@link Mono} indicating completion when the logout has succeeded. If an error occurs it is forwarded
     * through this {@link Mono}.
     */",discord4j.gateway
"public Optional<Custom> asCustomEmoji() {
        return this instanceof Custom ? Optional.of((Custom) this) : Optional.empty();
    }","/**
     * Gets this emoji as downcasted to {@link Custom a custom reaction emoji}.
     *
     * @return This emoji downcasted to a custom emoji, if possible.
     */",discord4j.core.object.reaction
"public Publisher<?> onUserInteraction(UserInteractionEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when a user issues a user command (context menu action on a user).
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"@Nonnull
    @CheckReturnValue
    WebhookMessageCreateAction<T> createThread(@Nonnull ThreadCreateMetadata threadMetadata);","/**
     * Create a new thread channel for this webhook message.
     * <br>This is currently limited to forum channels.
     * <br>Does nothing if a {@link #setThread(ThreadChannel) target thread} is already configured.
     *
     * <p>This cannot be used with {@link net.dv8tion.jda.api.interactions.InteractionHook InteractionHooks}!
     *
     * @param  threadMetadata
     *         The metadata for the thread
     *
     * @throws IllegalStateException
     *         If this is an interaction webhook
     * @throws IllegalArgumentException
     *         If null is provided
     *
     * @return The same message action, for chaining convenience
     *
     * @see    #createThread(String, ForumTagSnowflake...)
     */",net.dv8tion.jda.api.requests.restaction
"public static CountInGuildAction countVoiceStatesInGuild(long guildId) {
        return new CountInGuildAction(InGuildEntity.VOICE_STATES, guildId);
    }","/**
     * Creates an action to count the number of voice states present in a store for the given guild ID.
     *
     * @param guildId the guild ID
     * @return a new {@link CountInGuildAction}
     */",discord4j.common.store.action.read
"public Mono<Message> createFollowup(InteractionFollowupCreateSpec spec) {
        Objects.requireNonNull(spec);
        return Mono.defer(() -> {
                    InteractionFollowupCreateSpec actualSpec = getClient().getRestClient().getRestResources()
                            .getAllowedMentions()
                            .filter(allowedMentions -> !spec.isAllowedMentionsPresent())
                            .map(spec::withAllowedMentions)
                            .orElse(spec);
                    return getInteractionResponse().createFollowupMessage(actualSpec.asRequest());
                })
                .map(data -> new Message(getClient(), data));
    }","/**
     * Creates a follow-up message to this interaction.
     *
     * @param spec an immutable object that specifies how to build the follow-up message
     * @return a {@link Mono} where, upon successful completion, emits the resulting follow-up message. If an error is
     * received, it is emitted through the {@code Mono}.
     */",discord4j.core.event.domain.interaction
"Route.CompiledRoute route = Route.Messages.ADD_REACTION.compile(getId(), messageId, emoji.getAsReactionCode(), ""@me"");","/**
     * Attempts to react to a message represented by the specified {@code messageId}
     * in this MessageChannel.
     *
     * <p>The following {@link net.dv8tion.jda.api.requests.ErrorResponse ErrorResponses} are possible:
     * <ul>
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS}
     *     <br>The request was attempted after the account lost access to the {@link net.dv8tion.jda.api.entities.Guild Guild}
     *         typically due to being kicked or removed, or after {@link net.dv8tion.jda.api.Permission#VIEW_CHANNEL Permission.VIEW_CHANNEL}
     *         was revoked in the {@link GuildMessageChannel GuildMessageChannel}
     *     <br>Also can happen if the account lost the {@link net.dv8tion.jda.api.Permission#MESSAGE_HISTORY Permission.MESSAGE_HISTORY}</li>
     *
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS}
     *     <br>The request was attempted after the account lost
     *         {@link net.dv8tion.jda.api.Permission#MESSAGE_ADD_REACTION Permission.MESSAGE_ADD_REACTION} in the
     *         {@link GuildMessageChannel GuildMessageChannel}.</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_EMOJI UNKNOWN_EMOJI}
     *     <br>The provided emoji was deleted, doesn't exist, or is not available to the currently logged-in account in this channel.</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_MESSAGE UNKNOWN_MESSAGE}
     *     <br>The provided {@code messageId} is unknown in this MessageChannel, either due to the id being invalid, or
     *         the message it referred to has already been deleted.</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_CHANNEL UNKNOWN_CHANNEL}
     *     <br>The request was attempted after the channel was deleted.</li>
     * </ul>
     *
     * @param  messageId
     *         The messageId to attach the reaction to
     * @param  emoji
     *         The not-null {@link Emoji} to react with
     *
     * @throws java.lang.IllegalArgumentException
     *         <ul>
     *             <li>If provided {@code messageId} is {@code null} or empty.</li>
     *             <li>If provided {@code emoji} is {@code null}.</li>
     *         </ul>
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the MessageChannel this message was sent in was a {@link GuildMessageChannel GuildMessageChannel}
     *         and the logged in account does not have
     *         <ul>
     *             <li>{@link net.dv8tion.jda.api.Permission#MESSAGE_ADD_REACTION Permission.MESSAGE_ADD_REACTION}</li>
     *             <li>{@link net.dv8tion.jda.api.Permission#MESSAGE_HISTORY Permission.MESSAGE_HISTORY}</li>
     *         </ul>
     *
     * @return {@link net.dv8tion.jda.api.requests.RestAction}
     */",net.dv8tion.jda.api.entities.channel.middleman
"public Set<Guild> getGuilds() {
        return guilds;
    }","/**
     * Gets a set of Unavailable {@link Guild}. These {@code Guilds} have not yet been provided via a
     * {@link discord4j.core.event.domain.guild.GuildCreateEvent}
     *
     * @return A set of unavailable {@code Guilds}.
     * @see <a href=""https://discord.com/developers/docs/resources/guild#unavailable-guild-object"">
     * Unavailable Guild Object</a>
     */",discord4j.core.event.domain.lifecycle
"public long getMaxRetries() {
        return maxRetries;
    }","/**
     * Returns the number of retries.
     *
     * @return number of retries
     */",discord4j.common.retry
"public Publisher<?> onTypingStart(TypingStartEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when a user has started typing a message.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"public MessageReferenceData getData() {
        return data;
    }","/**
     * Gets the data of the message reference.
     *
     * @return The data of the message reference.
     */",discord4j.core.object
"@Nullable
    public Member getOldOwner()
    {
        return getOldValue();
    }","/**
     * The old owner
     *
     * @return The old owner
     */",net.dv8tion.jda.api.events.guild.update
Mono<GuildData> getGuildById(long guildId);,"/**
     * Retrieves data for the guild corresponding to the given guild ID.
     *
     * @param guildId the guild ID
     * @return A {@link Mono} emitting the guild, or empty if not found
     */",discord4j.common.store.api.layout
"@Nonnull
        public Method getMethod()
        {
            return baseRoute.method;
        }","/**
         * The HTTP method.
         *
         * @return The HTTP method
         */",net.dv8tion.jda.api.requests
"static ShardingStrategy fixed(int count) {
        return new ShardingStrategy() {

            @Override
            public Mono<Integer> getShardCount(RestClient restClient) {
                return Mono.just(count);
            }

            @Override
            public GatewayClientGroupManager getGroupManager(int shardCount) {
                return new ShardingGatewayClientGroup(shardCount);
            }

            @Override
            public int getMaxConcurrency() {
                return 1;
            }
        };
    }","/**
     * Sharding strategy that creates a fixed number of {@link GatewayClient} instances, using the given {@code count}.
     *
     * @param count the number of {@link GatewayClient} instances to create, each representing a Discord shard
     * @return a fixed-count {@link ShardingStrategy}
     */",discord4j.core.shard
"@Nonnull
    static <E> CacheView<E> all(@Nonnull Collection<? extends CacheView<E>> cacheViews)
    {
        Checks.noneNull(cacheViews, ""Collection"");
        return new UnifiedCacheViewImpl<>(cacheViews::stream);
    }","/**
     * Creates a combined {@link net.dv8tion.jda.api.utils.cache.CacheView CacheView}
     * for all provided CacheView implementations. This allows to combine cache of multiple
     * JDA sessions or Guilds.
     *
     * @param  cacheViews
     *         Collection of {@link net.dv8tion.jda.api.utils.cache.CacheView CacheView} implementations
     *
     * @param  <E>
     *         The target type of the projection
     *
     * @return Combined CacheView spanning over all provided implementation instances
     */",net.dv8tion.jda.api.utils.cache
"@Nonnull
    public CompletableFuture<Path> downloadToPath()
    {
        return downloadToPath(url);
    }","/**
     * Downloads the data of this file, and stores it in a file with the same name as the queried file name (this would be the last segment of the URL).
     *
     * <p><b>Implementation note:</b>
     *       The file is first downloaded into a temporary file, the file is then moved to its real destination when the download is complete.
     *
     * @return {@link CompletableFuture} which holds a {@link Path} which corresponds to the location the file has been downloaded.
     */",net.dv8tion.jda.api.utils
"default ActionMapper getCustomActionMapper() {
        return ActionMapper.empty();
    }","/**
     * Defines a mapping for custom action types. By default, returns an empty {@link ActionMapper}, implementations
     * may override this method to supply custom mappings.
     *
     * @return an {@link ActionMapper}
     */",discord4j.common.store.api.layout
"Route route = Route.custom(Method.GET, ""channels/{channel_id}/messages/{message_id}"");","/**
     * Create a route template for the with the {@link Method#PATCH PATCH} method.
     *
     * <p>Route syntax should include valid argument placeholders of the format: {@code '{' argument_name '}'}
     * <br>The rate-limit handling in JDA relies on the correct names of major parameters:
     * <ul>
     *     <li>{@code channel_id} for channel routes</li>
     *     <li>{@code guild_id} for guild routes</li>
     *     <li>{@code webhook_id} for webhook routes</li>
     *     <li>{@code interaction_token} for interaction routes</li>
     * </ul>
     *
     * For example, to compose the route to edit a message in a channel:
     * <pre>{@code
     * Route route = Route.custom(Method.PATCH, ""channels/{channel_id}/messages/{message_id}"");
     * }</pre>
     *
     * <p>To compile the route, use {@link #compile(String...)} with the positional arguments.
     * <pre>{@code
     * Route.CompiledRoute compiled = route.compile(channelId, messageId);
     * }</pre>
     *
     * @param  route
     *         The route template with valid argument placeholders
     *
     * @throws IllegalArgumentException
     *         If null is provided or the route is invalid (containing spaces or empty)
     *
     * @return The custom route template
     */",net.dv8tion.jda.api.requests
boolean isValid(T object);,"/**
   * Validate an object.
   *
   * @param object an object
   * @return       <code>true</code> if valid;
   *               <code>false</code> otherwise
   */",io.github.augustoravazoli.termenu.util
"public static final Route CHANNEL_MODIFY = Route.put(""/channels/{channel.id}"");","/**
     * Update a channels settings. Requires the 'MANAGE_CHANNELS' permission for the guild. Returns a guild channel on
     * success, and a 400 BAD REQUEST on invalid parameters. Fires a Channel Update Gateway event.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/channel#modify-channel"">
     * https://discord.com/developers/docs/resources/channel#modify-channel</a>
     */",discord4j.rest.route
"@Nullable
    T getElementById(@Nonnull ChannelType type, long id);","/**
     * Retrieves the entity represented by the provided ID.
     *
     * @param  type
     *         The expected {@link ChannelType}
     * @param  id
     *         The ID of the entity
     *
     * @return Possibly-null entity for the specified ID, null if the expected type is different from the actual type
     */",net.dv8tion.jda.api.utils.cache
"@Nullable
    public Member getMember()
    {
        return override.getMember();
    }","/**
     * The {@link Member} for the override.
     * <br>This can be null if the member is not cached or there is a discord inconsistency.
     *
     * @return Possibly-null member
     */",net.dv8tion.jda.api.events.guild.override
"public static final Route GUILD_TEMPLATE_CREATE = Route.post(""/guilds/{guild.id}/templates"");","/**
     * Creates a template for the guild. Requires the MANAGE_GUILD permission. Returns the created template object on success.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/template#create-guild-template"">
     *         https://discord.com/developers/docs/resources/template#create-guild-template</a>
     */",discord4j.rest.route
"@Nonnull
    public static DataArray getArray(@Nonnull DataArray root, @Nonnull String path)
    {
        DataArray array = optArray(root, path);
        if (array == null)
            pathError(path, ""Array"");
        return array;
    }","/**
     * Parses the given {@code path} and finds the appropriate value within this {@link DataArray}.
     *
     * @param  root
     *         The root data array, which is the top level accessor.
     *         <br>The very first element in the path corresponds to a field of that name within this root object.
     * @param  path
     *         The path of the value, in accordance with the described grammar by {@link DataPath}.
     *         This must start with an index element, such as {@code ""[0]""}.
     *
     * @throws ParsingException
     *         If the path is invalid or resolving fails due to missing elements
     * @throws IndexOutOfBoundsException
     *         If any of the elements in the path refer to an array index that is out of bounds
     * @throws IllegalArgumentException
     *         If null is provided or the path is empty
     *
     * @return The {@link DataArray} at the given path
     */",net.dv8tion.jda.api.utils.data
"public static ReactionEmoji of(@Nullable Long id, String name, boolean isAnimated) {
        return id == null ? unicode(name) : custom(Snowflake.of(id), name, isAnimated);
    }","/**
     * Constructs a {@code ReactionEmoji} for generic emoji information.
     *
     * @param id The ID of the custom emoji OR null if the emoji is a unicode emoji.
     * @param name The name of the custom emoji OR the raw unicode string for the emoji.
     * @param isAnimated Whether the emoji is animated OR false if the emoji is a unicode emoji.
     * @return A reaction emoji using the given information.
     */",discord4j.core.object.reaction
"@Nonnull
    @CheckReturnValue
    ChannelAction<TextChannel> createTextChannel(@Nonnull String name);","/**
     * Creates a new {@link TextChannel TextChannel} with this Category as parent.
     * For this to be successful, the logged in account has to have the
     * {@link net.dv8tion.jda.api.Permission#MANAGE_CHANNEL MANAGE_CHANNEL} Permission in this Category.
     *
     * <p>This will copy all {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverrides} of this Category!
     * Unless the bot is unable to sync it with this category due to permission escalation.
     * See {@link IPermissionHolder#canSync(IPermissionContainer, IPermissionContainer)} for details.
     *
     * <p>Possible {@link net.dv8tion.jda.api.requests.ErrorResponse ErrorResponses} caused by
     * the returned {@link net.dv8tion.jda.api.requests.RestAction RestAction} include the following:
     * <ul>
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS}
     *     <br>The channel could not be created due to a permission discrepancy</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS}
     *     <br>The {@link net.dv8tion.jda.api.Permission#VIEW_CHANNEL VIEW_CHANNEL} permission was removed</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MAX_CHANNELS MAX_CHANNELS}
     *     <br>The maximum number of channels were exceeded</li>
     * </ul>
     *
     * @param  name
     *         The name of the TextChannel to create (up to {@value Channel#MAX_NAME_LENGTH} characters)
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the logged in account does not have the {@link net.dv8tion.jda.api.Permission#MANAGE_CHANNEL} permission
     * @throws IllegalArgumentException
     *         If the provided name is {@code null}, empty, or longer than {@value Channel#MAX_NAME_LENGTH} characters
     *
     * @return A specific {@link ChannelAction ChannelAction}
     *         <br>This action allows to set fields for the new TextChannel before creating it
     */",net.dv8tion.jda.api.entities.channel.concrete
"@Nonnull
        public Builder setRequired(boolean required)
        {
            this.required = required;
            return this;
        }","/**
         * Sets whether the user is required to write in this TextInput. Default is true.
         *
         * @param  required 
         *         If this TextInput should be required
         *
         * @return The same builder instance for chaining
         */",net.dv8tion.jda.api.interactions.components.text
"@Nonnull
    default String getOwnerId()
    {
        return Long.toUnsignedString(getOwnerIdLong());
    }","/**
     * The id for the user who owns this team.
     *
     * @return The owner id
     */",net.dv8tion.jda.api.entities
"@Nonnull
    public String getOldImageUrl()
    {
        return getOldValue();
    }","/**
     * The old {@link ScheduledEvent#getImageUrl() image}.
     *
     * @return The old image
     */",net.dv8tion.jda.api.events.guild.scheduledevent.update
"Map<String, Object> map = mapper.readValue(json, mapType);","/**
     * Parses a JSON payload into a DataObject instance.
     *
     * @param  json
     *         The correctly formatted JSON payload to parse
     *
     * @throws net.dv8tion.jda.api.exceptions.ParsingException
     *         If the provided json is incorrectly formatted
     *
     * @return A DataObject instance for the provided payload
     */",net.dv8tion.jda.api.utils.data
"@Nonnull
    @CheckReturnValue
    CommandEditAction setGuildOnly(boolean guildOnly);","/**
     * Sets whether this command is only usable in a guild (Default: false).
     * <br>This only has an effect if this command is registered globally.
     *
     * @param  guildOnly
     *         Whether to restrict this command to guilds
     *
     * @return The CommandEditAction instance, for chaining
     */",net.dv8tion.jda.api.requests.restaction
"public static RestGuild create(RestClient restClient, Snowflake id) {
        return new RestGuild(restClient, id.asLong());
    }","/**
     * Create a {@link RestGuild} for a given ID. This method does not perform any API request.
     *
     * @param restClient the client to make API requests
     * @param id the ID of this entity
     * @return a {@code RestGuild} represented by this {@code id}.
     */",discord4j.rest.entity
"@Override
    public void setMaxDtwThreashold(final int maxDtwThreashold) {
        if (maxDtwThreashold >= 0) {
            this.maxDTWThreashold = maxDtwThreashold;
        } else {
            throw new IllegalStateException(""Min threshold must be greater than 0"");
        }
    }","/**
     * Set the threshold for gesture maximum acceptance.
     * <p>
     * Only gestures, that have a feature vector distance (by DTW) greater than minThreashold, are accepted.
     *
     *
     * @param maxDtwThreashold
     *            represents the maximum distance above which a feature vector is accepted
     */",jestures.core.recognition.gesturedata
"public static PresenceAndUserData of(@Nullable PresenceData presenceData, @Nullable UserData userData) {
        return new PresenceAndUserData(presenceData, userData);
    }","/**
     * Creates a new {@link PresenceAndUserData} wrapping the given presence and user data.
     *
     * @param presenceData the presence data, or null if not provided
     * @param userData     the user data, or null if not provided
     * @return a new {@link PresenceAndUserData}
     */",discord4j.common.store.api.object
"public LegacyMessageReferenceSpec setGuildId(Snowflake guildId) {
        requestBuilder.guildId(guildId.asString());
        return this;
    }","/**
     * Sets the ID of the originating message's guild.
     *
     * @param guildId The ID of the originating message's guild.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
    public List<User> getUsers()
    {
        return users;
    }","/**
     * An unmodifiable list of all {@link net.dv8tion.jda.api.entities.User Users} that provided audio that was combined.
     * <br>Basically: This is a list of all users that can be heard in the data returned by {@link #getAudioData(double)}
     * <p>
     * <b>NOTE: If no users were speaking, this list is empty and {@link #getAudioData(double)} provides silent audio data.</b>
     *
     * @return Never-null list of all users that provided audio.
     */",net.dv8tion.jda.api.audio
"public LegacyGuildCreateSpec setRegion(@Nullable String regionId) {
        builder.region(regionId == null ? Possible.absent() : Possible.of(regionId));
        return this;
    }","/**
     * Sets the voice region id for the created {@link Guild}, automatic if null.
     *
     * @param regionId The voice region id for the guild, automatic if null.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
    EnumSet<Permission> getDenied();","/**
     * EnumSet of all {@link net.dv8tion.jda.api.Permission Permissions} that are denied by this override.
     * <br><u>Changes to the returned set do not affect this entity directly.</u>
     *
     * @return Possibly-empty set of denied {@link net.dv8tion.jda.api.Permission Permissions}.
     */",net.dv8tion.jda.api.entities
"default Optional<String> getTopic() {
        return Possible.flatOpt(getData().topic());
    }","/**
     * Gets the channel topic, if present.
     *
     * @return The channel topic, if present.
     */",discord4j.core.object.entity.channel
"@Deprecated
    @Nullable
    public MessageCreateRequest getCreateRequest() {
        return (MessageCreateRequest) jsonPayload;
    }","/**
     * @deprecated Use {@link #getJsonPayload()} instead.
     */",discord4j.rest.util
"@Nonnull
    @CheckReturnValue
    default ThreadChannelManager setAppliedTags(@Nonnull ForumTagSnowflake... tags)
    {
        Checks.noneNull(tags, ""Tags"");
        return setAppliedTags(Arrays.asList(tags));
    }","/**
     * Sets the applied {@link net.dv8tion.jda.api.entities.channel.forums.ForumTag ForumTags} for this forum post thread.
     * <br>This is only applicable to public threads inside forum channels. The tags must be from the forum channel.
     * You can get the list of available tags with {@link ForumChannel#getAvailableTags()}.
     *
     * @param  tags
     *         The new tags for the thread
     *
     * @throws IllegalStateException
     *         If the thread is not a forum post
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If null is provided</li>
     *             <li>If more than {@value ForumChannel#MAX_POST_TAGS} tags are provided</li>
     *             <li>If at least one tag is {@link ForumChannel#isTagRequired() required} and none were provided</li>
     *         </ul>
     *
     * @return this ThreadChannelManager for chaining convenience.
     */",net.dv8tion.jda.api.managers.channel.concrete
"@Nullable
    public String getIconUrl()
    {
        return this.iconId == null ? null
                : String.format(Guild.ICON_URL, this.id, this.iconId, iconId.startsWith(""a_"") ? ""gif"" : ""png"");
    }","/**
     * The icon url of this guild.
     *
     * @return The guild's icon url
     *
     * @see    #getIconId()
     */",net.dv8tion.jda.api.entities.templates
"public Mono<Channel> asFullChannel() {
        return gateway.getChannelById(getId());
    }","/**
     * Retrieves the full {@link Channel} instance corresponding to this resolved channel.
     *
     * @return a {@link Mono} where, upon successful completion, emits the full {@link Channel} instance corresponding
     * to this resolved channel. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.object.command
"public RestEmoji restGuildEmoji(Snowflake guildId, EmojiData data) {
        return RestEmoji.create(this, guildId,
            Snowflake.of(data.id().orElseThrow(() -> new IllegalArgumentException(""Not a guild emoji""))));
    }","/**
     * Requests to retrieve the guild emoji represented by the supplied ID and {@link EmojiData}.
     *
     * @param guildId The ID of the guild.
     * @param data The data of the emoji.
     * @return A {@link RestEmoji} as represented by the supplied parameters.
     */",discord4j.rest
"@Nullable
    default String getBannerId()
    {
        long id = getBannerIdLong();
        return id == 0 ? null : Long.toUnsignedString(id);
    }","/**
     * The id for the pack banner.
     * <br>This is shown when you at the top of the pack pop-out in the client.
     *
     * @return The banner id, or {@code null} if there is no banner
     */",net.dv8tion.jda.api.entities.sticker
"@Nonnull
    @CheckReturnValue
    RoleManager revokePermissions(@Nonnull Collection<Permission> perms);","/**
     * Revokes the specified {@link net.dv8tion.jda.api.Permission Permissions} from the selected {@link net.dv8tion.jda.api.entities.Role Role}.
     *
     * <p>Permissions may only include already present Permissions for the currently logged in account.
     * <br>You are unable to revoke permissions you don't have!
     *
     * @param  perms
     *         The permission to give to the selected {@link net.dv8tion.jda.api.entities.Role Role}
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have permission to revoke one of the specified permissions
     *
     * @return RoleManager for chaining convenience
     *
     * @see    #setPermissions(Collection)
     * @see    #setPermissions(Permission...)
     * @see    java.util.EnumSet EnumSet
     * @see    net.dv8tion.jda.api.Permission#getRaw(java.util.Collection) Permission.getRaw(Collection)
     */",net.dv8tion.jda.api.managers
"public Publisher<?> onScheduledEventDelete(ScheduledEventDeleteEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when a scheduled event is deleted.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"public <T> Optional<T> getOption(OptionKey<T> optionKey) {
        return data.options().toOptional()
                .map(AuditLogUtil::createOptionMap)
                .map(map -> optionKey.parseValue(map.get(optionKey.getField())));
    }","/**
     * Gets one of the optional extra pieces of information recorded by an audit log entry. The possible options
     * correspond to each {@link OptionKey}.
     *
     * @param optionKey The option key.
     * @param <T> The type of the option key.
     * @return The option, if present.
     */",discord4j.core.object.audit
"public static GetVoiceStatesInChannelAction getVoiceStatesInChannel(long guildId, long channelId) {
        return new GetVoiceStatesInChannelAction(guildId, channelId);
    }","/**
     * Creates an action to retrieve data for all voice states present in a store for the given guild ID and channel ID.
     *
     * @param guildId the guild ID
     * @param channelId the channel ID
     * @return a new {@link GetVoiceStatesInChannelAction}
     */",discord4j.common.store.action.read
"public static CountInGuildAction countEmojisInGuild(long guildId) {
        return new CountInGuildAction(InGuildEntity.EMOJIS, guildId);
    }","/**
     * Creates an action to count the number of emojis present in a store for the given guild ID.
     *
     * @param guildId the guild ID
     * @return a new {@link CountInGuildAction}
     */",discord4j.common.store.action.read
"boolean hasPermission(@Nonnull GuildChannel channel, @Nonnull Permission... permissions);","/**
     * Checks whether or not this PermissionHolder has the given {@link net.dv8tion.jda.api.Permission Permissions} in the specified GuildChannel.
     *
     * @param  channel
     *         The {@link GuildChannel GuildChannel} in which to check.
     * @param  permissions
     *         Permissions to check for.
     *
     * @throws IllegalArgumentException
     *         If null is provided
     *
     * @return True, if all of the specified Permissions are granted to this PermissionHolder in the provided GuildChannel.
     *
     * @see    java.util.EnumSet EnumSet
     */",net.dv8tion.jda.api.entities
new UnknownPropertyHandler(true));,"/**
     * A mapper of {@link ObjectMapper} to handle unknown properties without throwing errors.
     */",discord4j.common
"@Deprecated
        DefaultEventDispatcher.Builder eventProcessor(FluxProcessor<Event, Event> eventProcessor);","/**
         * Set the underlying {@link FluxProcessor} the dispatcher will use to queue and distribute events. Defaults
         * to using an {@link EmitterProcessor}.
         * <p>
         * Using {@link EmitterProcessor} only emits events since a subscriber has subscribed to the processor
         * (except for the first one which receives all queued signals until that point), and it allows you to
         * configure the backing queue size while allowing you to use operators like {@link Flux#repeat()} and
         * {@link Flux#retry()} to drop the triggering signal.
         *
         * @param eventProcessor the custom processor for events
         * @return this builder
         * @deprecated due to the Processor API being deprecated, we recommend using {@link #eventSink(Function)}
         * moving forward
         */",discord4j.core.event
"Mono<ChannelData> onChannelUpdate(int shardIndex, ChannelUpdate dispatch);","/**
     * Updates the internal state of the store according to the given {@link ChannelUpdate} gateway dispatch. This
     * will typically perform an update operation on a related {@link ChannelData} that is already present in the store.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a {@link Mono} completing when the operation is done, optionally returning the old state of the
     * {@link ChannelData} before the update
     */",discord4j.common.store.api.layout
"@Override
    public int hashCode() {
        // see Map.Entry API specification
        return Objects.hashCode(getLeft()) ^ Objects.hashCode(getRight());
    }","/**
     * <p>Returns a suitable hash code.
     * The hash code follows the definition in {@code Map.Entry}.</p>
     *
     * @return the hash code
     */",net.dv8tion.jda.internal.utils.tuple
"public ExchangeStrategies getExchangeStrategies() {
        return exchangeStrategies;
    }","/**
     * Returns the currently configured {@link ExchangeStrategies}.
     *
     * @return the configured {@link ExchangeStrategies}
     */",discord4j.rest.request
"@Nullable
    default String getParentCategoryId()
    {
        long parentID = getParentCategoryIdLong();
        if (parentID == 0L)
            return null;
        return Long.toUnsignedString(parentID);
    }","/**
     * Get the snowflake of the {@link Category Category} that contains this channel.
     *
     * <p>This will return {@code null} if this channel doesn't have a parent category.
     *
     * @return Possibly-null String representation of the Discord ID snowflake of the parent channel.
     */",net.dv8tion.jda.api.entities.channel.attribute
"public static final Route CREATE_TEST_ENTITLEMENT = Route.post(""/applications/{application.id}/entitlements"");","/**
     * Creates a test entitlement for a given application.
     *
     * @see <a href=""https://discord.com/developers/docs/monetization/entitlements#create-test-entitlement"">Docs</a>
     */",discord4j.rest.route
"public static long asLong(final Id id) {
        return id.asLong();
    }","/**
     * Constructs a {@code Snowflake} represented as a {@code long} utilizing a discord-json {@link Id}.
     *
     * @param id The ID to construct a {@code Snowflake}. Must be non-null.
     * @return A constructed {@code Snowflake} with the ID.
     */",discord4j.common.util
"public static GuildScheduledEventCreateAction guildScheduledEventCreate(int shardIndex, GuildScheduledEventCreate dispatch) {
        return new GuildScheduledEventCreateAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link GuildScheduledEventCreate} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link GuildScheduledEventCreate}
     */",discord4j.common.store.action.gateway
"public GatewayReactorResources(ReactorResources parent, Scheduler payloadSenderScheduler) {
        super(parent.getHttpClient(), parent.getTimerTaskScheduler(), parent.getBlockingTaskScheduler());
        this.payloadSenderScheduler = payloadSenderScheduler;
    }","/**
     * Create Gateway resources based off {@link ReactorResources} properties, and allowing customization of the
     * remaining properties.
     *
     * @param parent the resources instance to get properties from
     * @param payloadSenderScheduler a {@link Scheduler} for sending payloads. A default can be created from
     * {@link GatewayReactorResources#DEFAULT_PAYLOAD_SENDER_SCHEDULER}
     */",discord4j.gateway
"public String getCommandName() {
        return getInteraction().getCommandInteraction()
                .flatMap(ApplicationCommandInteraction::getName)
                .orElseThrow(IllegalStateException::new); // should always be present for application commands
    }","/**
     * Gets the name of the invoked command.
     *
     * @return The name of the invoked command.
     */",discord4j.core.event.domain.interaction
"public static VoiceReactorResources create() {
        return new VoiceReactorResources(new ReactorResources());
    }","/**
     * Create a default set of Voice Gateway resources.
     *
     * @return a new {@link VoiceReactorResources} using all default properties
     */",discord4j.voice
"public Mono<MessageData> getData() {
        return restClient.getChannelService().getMessage(channelId, id);
    }","/**
     * Retrieve this messages' data upon subscription.
     *
     * @return a {@link Mono} where, upon successful completion, emits the {@link MessageData} belonging to this
     * channel. If an error is received, it is emitted through the {@code Mono}.
     * @see <a href=""https://discord.com/developers/docs/resources/channel#get-channel-message"">Get Message</a>
     */",discord4j.rest.entity
"@Nonnull
    @CheckReturnValue
    default M putRolePermissionOverride(long roleId, @Nullable Collection<Permission> allow, @Nullable Collection<Permission> deny)
    {
        long allowRaw = allow == null ? 0 : Permission.getRaw(allow);
        long denyRaw  = deny  == null ? 0 : Permission.getRaw(deny);
        return putRolePermissionOverride(roleId, allowRaw, denyRaw);
    }","/**
     * Adds an override for the specified role with the provided permission sets as allowed and denied permissions.
     * If the role already had an override on this channel it will be replaced instead.
     *
     * @param  roleId
     *         The ID of the role to set permissions for
     * @param  allow
     *         The permissions to grant, or null
     * @param  deny
     *         The permissions to deny, or null
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have {@link Permission#MANAGE_PERMISSIONS Permission.MANAGE_PERMISSIONS}
     *         in this channel, or tries to set permissions it does not have without having {@link Permission#MANAGE_PERMISSIONS Permission.MANAGE_PERMISSIONS} explicitly for this channel through an override.
     *
     * @return ChannelManager for chaining convenience
     *
     * @see    #putRolePermissionOverride(long, long, long)
     * @see    java.util.EnumSet EnumSet
     */",net.dv8tion.jda.api.managers.channel.attribute
"@Nullable
    @Override
    public T getNewValue()
    {
        return newValue;
    }","/**
     * The {@link Channel Channel's} new value of the just updated field.
     *
     * @return The new value of the just updated field.
     */",net.dv8tion.jda.api.events.channel.update
"public static HttpClient newHttpClient(ConnectionProvider provider) {
        return HttpClient.create(provider).compress(true).followRedirect(true).secure();
    }","/**
     * Create a Reactor Netty {@link HttpClient} using the given connection pool.
     * <p>Use this in case you want dedicated resources for a particular client or clients instead of the global
     * default.
     *
     * @param provider the connection pool provider to use
     * @return an {@link HttpClient} configured with custom resources
     */",discord4j.common
String printKinectInfo();,"/**
     * Print Sensor info.
     *
     * @param the
     *            {@link String} info
     */",jestures.sensor.kinect
"@Nonnull
    @CheckReturnValue
    default Button withLabel(@Nonnull String label)
    {
        Checks.notEmpty(label, ""Label"");
        Checks.notLonger(label, LABEL_MAX_LENGTH, ""Label"");
        return new ButtonImpl(getId(), label, getStyle(), getUrl(), isDisabled(), getEmoji());
    }","/**
     * Returns a copy of this button with the provided label.
     *
     * @param  label
     *         The label to use
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If the provided {@code label} is null or empty.</li>
     *             <li>If the character limit for {@code label}, defined by {@link #LABEL_MAX_LENGTH} as {@value #LABEL_MAX_LENGTH},
     *             is exceeded.</li>
     *         </ul>
     *
     * @return New button with the changed label
     */",net.dv8tion.jda.api.interactions.components.buttons
"public static IdentifyOptions create(int shardIndex, int shardCount) {
        return builder(ShardInfo.create(shardIndex, shardCount)).build();
    }","/**
     * Create a default {@link IdentifyOptions} using the given shard index and count.
     *
     * @param shardIndex the shard index for authentication
     * @param shardCount the shard count for authentication
     * @return a default authentication policy
     */",discord4j.gateway
policy = policy.and(p);,"/**
     * Composes a policy which requires multiple other policies.
     * <br>This is logically identical to {@code policy1 && policy2 && policy3 && ... && policyN}.
     *
     * @param  policy
     *         The first policy
     * @param  policies
     *         The other policies
     *
     * @return New policy which combines all provided polices using a logical AND
     */",net.dv8tion.jda.api.utils
"@Nonnull
    @CheckReturnValue
    public static <E> Result<E> success(@Nullable E value)
    {
        return new Result<>(value, null);
    }","/**
     * Creates a successful result.
     *
     * @param  value
     *         The success value
     * @param  <E>
     *         The success type
     *
     * @return Result
     */",net.dv8tion.jda.api.utils
"@Nonnull
    AutoCompleteQuery getFocusedOption();","/**
     * The focused option which the user is typing.
     *
     * <p>This is not validated by the Discord API and may contain invalid/incomplete inputs.
     *
     * @return The focused {@link AutoCompleteQuery}
     */",net.dv8tion.jda.api.interactions.commands
"public int getChunkIndex() {
        return chunkIndex;
    }","/**
     * Gets the chunk index in the expected chunks for this response (0 &lt;= chunk_index &lt; chunk_count).
     *
     * @return The chunk index in the expected chunks for this response (0 &lt;= chunk_index &lt; chunk_count).
     */",discord4j.core.event.domain.guild
"@Nonnull
    public EnumSet<Permission> getOldDeny()
    {
        return Permission.getPermissions(oldDeny);
    }","/**
     * The old denied permissions
     *
     * @return The old denied permissions
     */",net.dv8tion.jda.api.events.guild.override
"@Nonnull
    @Unmodifiable
    default List<NewsChannel> getNewsChannels()
    {
        return getGuild().getNewsChannelCache().applyStream(stream ->
            stream.filter(channel -> equals(channel.getParentCategory()))
                  .sorted()
                  .collect(Helpers.toUnmodifiableList())
        );
    }","/**
     * All {@link NewsChannel NewsChannels}
     * listed for this Category
     *
     * @return Immutable list of all child NewsChannels
     */",net.dv8tion.jda.api.entities.channel.concrete
"public Optional<Long> getOptionAsLong(final String name) {
        return getOption(name)
            .flatMap(ApplicationCommandInteractionOption::getValue)
            .map(ApplicationCommandInteractionOptionValue::asLong);
    }","/**
     * Gets the value of the option corresponding to the provided name, if present, as a long.
     *
     * @param name The name of the option.
     * @return An {@link Optional} containing the value of the option corresponding to the provided name, if present, or empty otherwise.
     * @throws IllegalArgumentException If the option is present but its value cannot be converted to a long.
     */",discord4j.core.event.domain.interaction
"@Nonnull
    @CheckReturnValue
    PermissionOverrideAction grant(long allowBits);","/**
     * Grants the specified permissions.
     * <br>This does not override already granted permissions.
     *
     * @param  allowBits
     *         The permissions to grant, in addition to already allowed permissions
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have {@link Permission#MANAGE_PERMISSIONS Permission.MANAGE_PERMISSIONS}
     *         on the channel and tries to set permissions it does not have in the channel
     *
     * @return The current PermissionOverrideAction - for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
"@Nonnull
    @CheckReturnValue
    public CacheRestAction<User> retrieveUser()
    {
        return getJDA().retrieveUserById(getUserIdLong());
    }","/**
     * Retrieves the {@link User} that subscribed or unsubscribed to the {@link ScheduledEvent ScheduledEvent}.
     * <br>If a user is known, this will return {@link #getUser()}.
     *
     * @return {@link RestAction} - Type: {@link User}
     */",net.dv8tion.jda.api.events.guild.scheduledevent
"public InteractionFollowupCreateMono createFollowup() {
        return InteractionFollowupCreateMono.of(this);
    }","/**
     * Creates a follow-up message to this interaction. Properties specifying how to build the follow-up message can be
     * set via the {@code withXxx} methods of the returned {@link InteractionFollowupCreateMono}.
     *
     * @return a {@link InteractionFollowupCreateMono} where, upon successful completion, emits the resulting follow-up
     * message. If an error is received, it is emitted through the {@code InteractionApplicationCommandCallbackMono}.
     */",discord4j.core.event.domain.interaction
Mono<Void> subscribeToCity(SubscriptionCreateDTO dto);,"/**
     * This method is used to create the subscription entity.
     *
     * @param dto -> SubscriptionCreateDTO comes in and all its fields must be not null
     * @return Mono<Void>
     * @since 1.0
     */",org.khasanof.citiesapi.service.subscription
final Route.CompiledRoute route = super.finalizeRoute();,"/**
         * Limit between 1-100 messages that should be retrieved.
         *
         * @param  limit
         *         The limit to use, or {@code null} to use default 50
         *
         * @throws java.lang.IllegalArgumentException
         *         If the provided limit is not between 1-100
         *
         * @return The current MessageRetrieveAction for chaining convenience
         */",net.dv8tion.jda.api.entities
"public static boolean equals(final Entity entity, @Nullable final Object obj) {
        return entity.getClass().isInstance(obj) && ((Entity) obj).getId().equals(entity.getId());
    }","/**
     * A utility that checks for equality between an entity and a generic object.
     *
     * @param entity The entity to compare to.
     * @param obj The object to compare to.
     * @return {@code true} if the two objects are equal, {@code false} otherwise.
     */",discord4j.core.util
"default Flux<GuildScheduledEventData> getScheduledEventsInGuild(long guildId) {
        return Flux.empty();
    }","/**
     * Retrieves data for all guild scheduled events corresponding to the given guild ID.
     *
     * @param guildId the guild ID
     * @return A {@link Flux} emitting the scheduled events, or empty if none is present
     * @since 3.2.5
     */",discord4j.common.store.api.layout
void loadUserProfile(String name);,"/**
     * Load the userProfile.
     *
     * @param name
     *            the String name
     */",jestures.core.view
"public Publisher<?> onMessageDelete(MessageDeleteEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when a message is deleted.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
PermissionSet set = PermissionSet.none();,"/**
     * Performs a logical <b>AND NOT</b> of this permission set with the other permission set.
     * <p>
     * The resultant set is the <b>relative complement</b> of this set and the other set. A permission is contained if
     * and only if it was contained in this set and <b>not</b> contained in the other set.
     * <pre>
     * {@code
     * PermissionSet set0 = PermissionSet.of(KICK_MEMBERS, BAN_MEMBERS, ATTACH_FILES);
     * PermissionSet set1 = PermissionSet.of(BAN_MEMBERS, ATTACH_FILES, CONNECT);
     *
     * set0.subtract(set1) = PermissionSet.of(KICK_MEMBERS)
     * }
     * </pre>
     *
     * @param other The other permission set.
     * @return The relative complement of this set with the other set.
     *
     * @deprecated Use {@link PermissionSet#andNot(PermissionSet)} instead.
     */",discord4j.rest.util
"public int getCode()
    {
        return code;
    }","/**
     * The server close code that was in the disconnect close frame
     * of this JDA instance.
     *
     * @return int close code of the Server Close-Frame
     */",net.dv8tion.jda.api.events.session
"public LegacyAuditLogQuerySpec setActionType(final ActionType actionType) {
        request.put(""action_type"", actionType.getValue());
        return this;
    }","/**
     * Sets the query to return entries where the action type is the same as the one provided.
     *
     * @param actionType The {@code ActionType} of the audit log entries to filter by.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public Mono<Void> denyRequest() {
        return getMember().flatMap(PartialMember::moveToStageAudience);
    }","/**
     * Requests to deny the initial speak request.
     *
     * @return A {@link Mono} where, upon successful completion, emits nothing; indicating the member
     *         request to speak has been denied. If an error is received, it is emitted through the
     *         {@code Mono}.
     */",discord4j.core.event.domain
"public Mono<Void> moveMemberToStageAudience(Member member) {
        return Mono.defer(() -> gateway.getRestClient().getGuildService()
                .modifyOthersVoiceState(member.getGuildId().asLong(), member.getId().asLong(),
                        UpdateUserVoiceStateRequest.builder().suppress(true).build()));
    }","/**
     * Requests to move the specified {@param member} to the audience of the stage channel associated with this
     * stage instance.
     *
     * @param member The member to move to the stage audience
     * @return A {@link Mono} where, upon successful completion, emits nothing; indicating that the specified
     * {@param member} has been moved to the audience of the stage channel associated with this stage instance.
     * If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.object.entity
"@Nullable
    public AuditLogPart getParent() {
        return auditLogPart;
    }","/**
     * Gets the {@link AuditLogPart audit log part} that this entry belongs to.
     *
     * @return The audit log part that this entry belongs to, or {@code null} if the entry originated from a
     * {@link AuditLogEntryCreateEvent}
     */",discord4j.core.object.audit
"@Nonnull
    @CheckReturnValue
    InviteAction createInvite();","/**
     * Creates a new {@link InviteAction InviteAction} which can be used to create a
     * new {@link net.dv8tion.jda.api.entities.Invite Invite}.
     * <br>Requires {@link net.dv8tion.jda.api.Permission#CREATE_INSTANT_INVITE CREATE_INSTANT_INVITE} in this channel.
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the account does not have {@link net.dv8tion.jda.api.Permission#CREATE_INSTANT_INVITE CREATE_INSTANT_INVITE} in this channel
     * @throws java.lang.IllegalArgumentException
     *         If this is an instance of a {@link Category Category}
     *
     * @return A new {@link InviteAction InviteAction}
     *
     * @see    InviteAction
     */",net.dv8tion.jda.api.entities.channel.attribute
"For example (2, 0) (3, 5) (3, 6) become (1, 5) (0, 1) and so on.
 */
public class DerivativeCodifier implements Codifier {
    /**
     * The queue that gather all the derivative vectors. This represents a gesture, so a sequence of positions in time.
     */
    private Queue<Vector2D> featureVector;
    /**
     * Old vector for derivative calculus.
     */
    private Vector2D oldVector;
    /**
     * Last derivative vector.
     */
    private Vector2D derivative; // NOPMD
    /**
     * Starting vector for other representations
     */
    private Vector2D startingVector;
    /**
     * Frame count.
     */
    private int frame;
    /**
     * The gesture length.
     */
    private GestureLength gestureLength;
    /**
     * Tracker that gets notified when a feature vector (gesture is ready)
     */
    private TrackingObserver recognizer;
    /**
     * Type of codification
     */
    private static final Codification CODIFICATION = Codification.DERIVATIVE;

    /**
     * The @link{DerivativeCodifier.java} constructor.
     * <p>
     * Create the evicting queue, the first vector to be differentiated and set the frame at zero.
     *
     * @param frames
     *            the gesture's duration in frame
     */
    public DerivativeCodifier(final GestureLength frames) {
        this.featureVector = EvictingQueue.create(frames.getFrameNumber());
        this.oldVector = new Vector2D(0, 0);
        this.frame = 0;
        this.gestureLength = frames;
    }

    @Override
    public Codification getCodificationType() {
        return DerivativeCodifier.CODIFICATION;
    }

    @Override
    public void codifyOnSkeletonChange(final Vector2D newVector) {
        // derivative calculus
        this.derivative = newVector.subtract(this.oldVector);
        // vector is added to the queue
        this.featureVector.offer(this.derivative);
        // swap
        this.oldVector = newVector;
        // if it's the first frame reset the starting vector
        if (this.frame == 0) {
            this.startingVector = newVector;
        }
        // if reached the gesture length notify the recognizer with a new gesture.
        if (this.frame > this.gestureLength.getFrameNumber() - 1) {
            this.recognizer.notifyOnFeatureVectorEvent(new ArrayList<Vector2D>(this.featureVector));
            this.resetFrame();
        } else {
            // notify the recognizer so the view with a new frame
            this.recognizer.notifyOnFrameChange(this.frame, this.featureVector, this.derivative,
                    this.startingVector.subtract(newVector));
            this.frame++;
        }
    }

    @Override
    public Queue<Vector2D> extractFeatureVector() {
        return this.featureVector;
    }

    @Override
    public void attacheTracker(final TrackingObserver recognizer) {
        this.recognizer = recognizer;
    }

    @Override
    public synchronized void resetFrame() {
        this.frame = 0;
    }

    @Override
    public synchronized void setFrameLength(final GestureLength length) {
        this.gestureLength = length;
        this.featureVector = EvictingQueue.create(length.getFrameNumber());
    }

}","/*******************************************************************************
 * Copyright (c) 2018 Giulianini Luca
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/",jestures.core.codification
"void addAllGestureFeatureVector(String gestureName, List<List<Vector2D>> gestureFeatureVectors);","/**
     * The Feature Vector to serialize.
     *
     * @param gestureFeatureVectors
     *            the {@link List} of {@link List} of feature vector
     * @param gestureName
     *            the {@link String} gesture name
     */",jestures.core.recognition.gesturedata
"public Publisher<?> onResume(ResumeEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when the gateway connection is successfully resumed.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"public Publisher<?> onScheduledEventUserRemove(ScheduledEventUserRemoveEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when a user unsubscribes from a scheduled event.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"@Nullable
    public String getOldIconUrl()
    {
        return previous == null ? null : String.format(Guild.ICON_URL, guild.getId(), previous, previous.startsWith(""a_"") ? ""gif"" : ""png"");
    }","/**
     * The url of the old icon
     *
     * @return The url of the old icon, or null
     */",net.dv8tion.jda.api.events.guild.update
"public Flux<RoleData> changePosition(final int position) {
        return changePosition(position, null);
    }","/**
     * Requests to change this role's position.
     *
     * @param position The position to change for this role.
     * @return A {@link Flux} that continually emits all the {@link RoleData roles} associated to this role's
     * guild. If an error is received, it is emitted through the {@code Flux}.
     */",discord4j.rest.entity
Mono<User> getUserById(Snowflake userId);,"/**
     * Requests to retrieve the user represented by the supplied ID.
     *
     * @param userId The ID of the user.
     * @return A {@link Mono} where, upon successful completion, emits the {@link User} as represented by the supplied
     *         ID. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.retriever
"public static int getInt(@Nonnull DataArray root, @Nonnull String path)
    {
        Integer integer = get(root, path, DataObject::getInt, DataArray::getInt);
        if (integer == null)
            pathError(path, ""int"");
        return integer;
    }","/**
     * Parses the given {@code path} and finds the appropriate value within this {@link DataArray}.
     * <br>If the resulting value is a string, this will parse the string using {@link Integer#parseInt(String)}.
     *
     * @param  root
     *         The root data array, which is the top level accessor.
     *         <br>The very first element in the path corresponds to a field of that name within this root object.
     * @param  path
     *         The path of the value, in accordance with the described grammar by {@link DataPath}.
     *         This must start with an index element, such as {@code ""[0]""}.
     *
     * @throws ParsingException
     *         If the path is invalid or resolving fails due to missing elements
     * @throws IndexOutOfBoundsException
     *         If any of the elements in the path refer to an array index that is out of bounds
     * @throws IllegalArgumentException
     *         If null is provided or the path is empty
     *
     * @return The int value at the given path
     */",net.dv8tion.jda.api.utils.data
"@Nonnull
    @CheckReturnValue
    ScheduledEventManager setDescription(@Nullable String description);","/**
     * Sets the description of the selected {@link ScheduledEvent ScheduledEvent}.
     * This field may include markdown.
     *
     * @param  description
     *         The new description for the selected {@link ScheduledEvent ScheduledEvent},
     *         or {@code null} to reset the description
     *
     * @throws java.lang.IllegalArgumentException
     *         If the new description is longer than {@value ScheduledEvent#MAX_DESCRIPTION_LENGTH} characters
     *
     * @return ScheduledEventManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"@Nonnull
    @CheckReturnValue
    default MessageEditAction editMessageComponentsById(@Nonnull String messageId, @Nonnull LayoutComponent... components)
    {
        Checks.noneNull(components, ""Components"");
        return editMessageComponentsById(messageId, Arrays.asList(components));
    }","/**
     * Attempts to edit a message by its id in this MessageChannel.
     * <br>This will replace all the current {@link net.dv8tion.jda.api.interactions.components.Component Components},
     * such as {@link Button Buttons} or {@link SelectMenu SelectMenus} on this message.
     * The provided parameters are {@link LayoutComponent LayoutComponents} such as {@link ActionRow} which contain a list of components to arrange in the respective layout.
     *
     * <p>The following {@link net.dv8tion.jda.api.requests.ErrorResponse ErrorResponses} are possible:
     * <ul>
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#INVALID_AUTHOR_EDIT INVALID_AUTHOR_EDIT}
     *     <br>Attempted to edit a message that was not sent by the currently logged in account.
     *         Discord does not allow editing of other users' Messages!</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS}
     *     <br>The request was attempted after the account lost access to the {@link net.dv8tion.jda.api.entities.Guild Guild}
     *         typically due to being kicked or removed, or after {@link net.dv8tion.jda.api.Permission#VIEW_CHANNEL Permission.VIEW_CHANNEL}
     *         was revoked in the {@link GuildMessageChannel GuildMessageChannel}</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_MESSAGE UNKNOWN_MESSAGE}
     *     <br>The provided {@code messageId} is unknown in this MessageChannel, either due to the id being invalid, or
     *         the message it referred to has already been deleted. This might also be triggered for ephemeral messages.</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_CHANNEL UNKNOWN_CHANNEL}
     *     <br>The request was attempted after the channel was deleted.</li>
     * </ul>
     *
     * <p><b>Example</b><br>
     * <pre>{@code
     * channel.editMessageComponentsById(messageId,
     *   ActionRow.of(Button.success(""prompt:accept"", ""Accept""), Button.danger(""prompt:reject"", ""Reject"")), // 1st row below message
     *   ActionRow.of(Button.link(url, ""Help"")) // 2nd row below message
     * ).queue();
     * }</pre>
     *
     * @param  messageId
     *         The id referencing the Message that should be edited
     * @param  components
     *         Up to 5 new {@link LayoutComponent LayoutComponents} for the edited message, such as {@link ActionRow}
     *
     * @throws UnsupportedOperationException
     *         If the component layout is a custom implementation that is not supported by this interface
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If provided {@code messageId} is {@code null} or empty.</li>
     *             <li>If any of the provided {@link LayoutComponent LayoutComponents} is null</li>
     *         </ul>
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If this is a {@link GuildMessageChannel GuildMessageChannel} and this account does not have
     *         {@link net.dv8tion.jda.api.Permission#VIEW_CHANNEL Permission.VIEW_CHANNEL}
     *         or {@link net.dv8tion.jda.api.Permission#MESSAGE_SEND Permission.MESSAGE_SEND}
     *
     * @return {@link MessageEditAction}
     */",net.dv8tion.jda.api.entities.channel.middleman
"ConcurrentMap<String, String> contextMap = api.getContextMap();","/**
     * This method is used to start the reconnect of the JDA instance.
     * It is public for access from SessionReconnectQueue extensions.
     *
     * @param  callFromQueue
     *         whether this was in SessionReconnectQueue and got polled
     */",net.dv8tion.jda.internal.requests
"@Nonnull
    public RestConfig setBaseUrl(@Nonnull String baseUrl)
    {
        Checks.notEmpty(baseUrl, ""URL"");
        Checks.check(baseUrl.length() > 4 && baseUrl.substring(0, 4).equalsIgnoreCase(""http""), ""URL must be HTTP"");
        if (baseUrl.endsWith(""/""))
            this.baseUrl = baseUrl;
        else
            this.baseUrl = baseUrl + ""/"";
        return this;
    }","/**
     * Provide a custom base URL for REST-api requests.
     * <br>This uses {@link #DEFAULT_BASE_URL} by default.
     *
     * <p>It is important that the new URL uses the correct API version for JDA.
     * The correct version is currently {@value JDAInfo#DISCORD_REST_VERSION}.
     *
     * <p>It is not required for this URL to be HTTPS, because local proxies do not require signed connections.
     * However, if the URL points to an external server, it is highly recommended to use HTTPS for security.
     *
     * @param  baseUrl
     *         The new base url
     *
     * @throws IllegalArgumentException
     *         If the provided base url is null, empty, or not an HTTP(s) url
     *
     * @return The current RestConfig for chaining convenience
     */",net.dv8tion.jda.api.requests
"public Snowflake getUserId() {
        return this.userId;
    }","/**
     * Get the {@link Snowflake} ID of the user who voted in this event.
     *
     * @return The ID of the user who voted.
     */",discord4j.core.event.domain.poll
"@Nonnull
        public Builder setLabel(@Nonnull String label)
        {
            Checks.notBlank(label, ""Label"");
            Checks.notLonger(label, MAX_LABEL_LENGTH, ""Label"");
            this.label = label;
            return this;
        }","/**
         * Sets the label for this TextInput
         *
         * @param  label
         *         The label to set
         *
         * @throws IllegalArgumentException
         *         <ul>
         *             <li>If label is null or blank</li>
         *             <li>If label is longer than {@value #MAX_LABEL_LENGTH} characters</li>
         *         </ul>
         *
         * @return The same Builder for chaining convenience.
         */",net.dv8tion.jda.api.interactions.components.text
"@Nonnull
    @CheckReturnValue
    TextChannelManager setType(@Nonnull ChannelType type);","/**
     * Converts the selected channel to a different {@link ChannelType}.
     *
     * <br><br>
     * This can only be done in the follow situations:
     * <table>
     *     <caption style=""display: none"">Javadoc is stupid, this is not a required tag</caption>
     *     <thead>
     *         <tr>
     *             <th>Current Channel Type</th>
     *             <th></th>
     *             <th>New Channel Type</th>
     *         </tr>
     *     </thead>
     *     <tbody>
     *         <tr>
     *             <td>{@link ChannelType#NEWS}</td>
     *             <td> -&gt; </td>
     *             <td>{@link ChannelType#TEXT}</td>
     *         </tr>
     *         <tr>
     *             <td>{@link ChannelType#TEXT}</td>
     *             <td> -&gt; </td>
     *             <td>{@link ChannelType#NEWS}</td>
     *         </tr>
     *     </tbody>
     * </table>
     *
     * @param  type
     *         The new not-null {@link ChannelType} of the channel
     *
     * @throws IllegalArgumentException
     *         If {@code channelType} is not {@link ChannelType#TEXT} or {@link ChannelType#NEWS}
     * @throws UnsupportedOperationException
     *         If this ChannelAction is not for a {@link TextChannel} or {@link net.dv8tion.jda.api.entities.channel.concrete.NewsChannel}
     * @throws IllegalStateException
     *         If {@code channelType} is {@link ChannelType#NEWS} and the guild doesn't have the {@code NEWS} feature in {@link Guild#getFeatures()}.
     *
     * @return ChannelManager for chaining convenience
     *
     * @see    Guild#getFeatures()
     */",net.dv8tion.jda.api.managers.channel.concrete
Mono<StageInstanceData> getStageInstanceByChannelId(long channelId);,"/**
     * Retrieves data for the stage instance corresponding to the given channel ID.
     *
     * @param channelId the channel ID
     * @return A {@link Mono} emitting the stage instance data, or empty if not found
     */",discord4j.common.store.api.layout
"public boolean isSelfDeafened()
    {
        return selfDeafened;
    }","/**
     * Whether the member deafened itself in this event
     *
     * @return True, if the member deafened itself,
     *         <br>False, if the member un-deafened itself
     */",net.dv8tion.jda.api.events.guild.voice
public abstract Set<Upgrade> upgradesToLoad();,"/**
     * Method to define upgrades you want to load.
     *
     * @return Set of upgrades you want to load.
     */",com.massivecraft.factions.addon.upgradeaddon
"@Nonnull
    @CheckReturnValue
    default InviteAction setTargetStream(@Nonnull final User user)
    {
        Checks.notNull(user, ""User"");
        return setTargetStream(user.getIdLong());
    }","/**
     * Sets the user whose stream to display for this invite.
     * <br>The user must be streaming in the same channel.
     * The invite will have the {@link Invite.TargetType#STREAM} target.
     *
     * @param user
     *        The user whose stream to target.
     *
     * @throws IllegalArgumentException
     *         If the provided user is {@code null}
     *
     * @return The current InviteAction for chaining.
     */",net.dv8tion.jda.api.requests.restaction
"@Deprecated
    public Mono<GuildEmoji> edit(final Consumer<? super LegacyGuildEmojiEditSpec> spec) {
        return Mono.defer(
                () -> {
                    LegacyGuildEmojiEditSpec mutatedSpec = new LegacyGuildEmojiEditSpec();
                    spec.accept(mutatedSpec);
                    return gateway.getRestClient().getEmojiService()
                            .modifyGuildEmoji(getGuildId().asLong(), getId().asLong(), mutatedSpec.asRequest(),
                                    mutatedSpec.getReason());
                })
                .map(data -> new GuildEmoji(gateway, data, getGuildId().asLong()));
    }","/**
     * Requests to edit this guild emoji.
     *
     * @param spec A {@link Consumer} that provides a ""blank"" {@link LegacyGuildEmojiEditSpec} to be operated on.
     * @return A {@link Mono} where, upon successful completion, emits the edited {@link GuildEmoji}. If an error is
     * received, it is emitted through the {@code Mono}.
     * @deprecated use {@link #edit(GuildEmojiEditSpec)} or {@link #edit()} which offer an immutable approach to build
     * specs
     */",discord4j.core.object.entity
"@Nullable
    default String getSkuId()
    {
        long id = getSkuIdLong();
        return id == 0 ? null : Long.toUnsignedString(id);
    }","/**
     * The stock-keeping unit (SKU) for this sticker pack.
     * <br>This is used for store purchases, if there was a store to buy the pack from.
     *
     * @return The SKU id for this pack, or {@code null} if there is no SKU
     */",net.dv8tion.jda.api.entities.sticker
"@Nullable
    public String getDescription()
    {
        return this.description;
    }","/**
     * The description for this guild.
     * <br>This is displayed in the server browser below the guild name for verified guilds.
     *
     * @return The description
     */",net.dv8tion.jda.api.entities.templates
"public RestRole role(Snowflake roleId) {
        return RestRole.create(restClient, id, roleId.asLong());
    }","/**
     * Return a {@link RestRole} representation under this guild. This method does not perform any API request.
     *
     * @param roleId the entity ID
     * @return a {@code RestRole} with the given ID, under this guild
     */",discord4j.rest.entity
"public CompletableFuture<Void> insertDocuments(final String collection, final Document... documents) {
        return insertDocuments(collection, Arrays.asList(documents));
    }","/**
     * Inserts a list of {@link Document} asynchronously into a MongoCollection
     * @param collection name of the collection
     */",io.github.heliumdioxid.database.mongo
"@Nonnull
    default String getDefaultAvatarUrl()
    {
        return String.format(User.DEFAULT_AVATAR_URL, getDefaultAvatarId());
    }","/**
     * The URL for the user's default avatar image.
     *
     * @return Never-null String containing the user's default avatar url.
     */",net.dv8tion.jda.api.entities
"@Nonnull
    static ForumTagSnowflake fromId(long id)
    {
        return new ForumTagSnowflakeImpl(id);
    }","/**
     * Wraps the provided id into a ForumTagSnowflake instance.
     *
     * @param  id
     *         The id of an existing forum tag
     *
     * @return ForumTagSnowflake instance for the provided id
     */",net.dv8tion.jda.api.entities.channel.forums
Mono<Void> execute(String gatewayUrl);,"/**
     * Establish a reconnecting gateway connection to the given URL.
     *
     * @param gatewayUrl the URL used to establish a websocket connection
     * @return a {@link Mono} signaling completion of the session. If a non-recoverable error terminates the session,
     * it is emitted as an error through this Mono.
     */",discord4j.gateway
"@Nullable
        default String getIntegrationId()
        {
            return isIntegration() ? Long.toUnsignedString(getIntegrationIdLong()) : null;
        }","/**
         * The id for the integration associated with this role.
         *
         * @return The integration id, or null if this role is not for an integration
         *
         * @see    #isIntegration()
         */",net.dv8tion.jda.api.entities
"default StartThreadFromMessageMono startPublicThreadWithMessage(String threadName, Message message) {
        return StartThreadFromMessageMono.of(threadName, message);
    }","/**
     * Start a new public thread that is not connected to an existing message. Properties specifying how to create the thread
     * can be set via the {@code withXxx} methods of the returned {@link StartThreadWithoutMessageMono}.
     *
     * @param threadName the name of the thread
     * @param message the message to start the thread with
     * @return A {@link StartThreadWithoutMessageMono} where, upon successful completion, emits the created {@link ThreadChannel}.
     * If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.object.entity.channel
"public Member getMember() {
        return member;
    }","/**
     * Gets the {@link Member} that has joined the {@link Guild} in this event.
     *
     * @return The {@link Member} that has joined
     */",discord4j.core.event.domain.guild
"@Nonnull
    @CheckReturnValue
    CacheRestAction<T> useCache(boolean useCache);","/**
     * Sets whether this request should rely on cached entities, or always retrieve a new one.
     *
     * @param  useCache
     *         True if the cache should be used when available, even if the entity might be outdated.
     *         False, to always request a new instance from the API.
     *
     * @return This RestAction instance
     */",net.dv8tion.jda.api.requests.restaction
"Mono<T> read(Mono<ByteBuf> content, Class<T> responseType);","/**
     * Read from the input message and encode to a single object.
     *
     * @param content the response contents
     * @param responseType the type of object in the response which must have been previously checked via {@link
     * #canRead(Class, String)}
     * @return a Mono for the resolved response, according to the given response type
     */",discord4j.rest.http
"public Mono<GuildScheduledEventData> createScheduledEvent(GuildScheduledEventCreateRequest request) {
        return restClient.getGuildService().createScheduledEvent(id, request);
    }","/**
     * Create a new scheduled event for the guild. Requires the {@link Permission#MANAGE_EVENTS} permission. Returns
     * the new event object on success.
     *
     * @param request the request body
     * @return A {@link Mono} where, upon subscription, emits the created {@link GuildScheduledEventData} on success.
     * If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.rest.entity
"<T> Flux<T> receiver(Function<ByteBuf, Publisher<? extends T>> mapper);","/**
     * Obtains a {@link Flux} of raw payloads inbound from the gateway connection made by this client, transformed by a
     * mapping function.
     *
     * @param mapper a mapping function turning raw {@link ByteBuf} objects into a given type
     * @param <T> the type of the resulting inbound {@link Flux}
     * @return a {@link Flux} of raw payloads transformed by a mapping function
     */",discord4j.gateway
"@Nonnull
    public EmbedBuilder setFooter(@Nullable String text, @Nullable String iconUrl)
    {
        //We only check if the text is null because its presence is what determines if the
        // footer will appear in the embed.
        if (text == null)
        {
            this.footer = null;
        }
        else
        {
            Checks.notLonger(text, MessageEmbed.TEXT_MAX_LENGTH, ""Text"");
            urlCheck(iconUrl);
            this.footer = new MessageEmbed.Footer(text, iconUrl, null);
        }
        return this;
    }","/**
     * Sets the Footer of the embed.
     *
     * <p><b><a href=""https://raw.githubusercontent.com/discord-jda/JDA/assets/assets/docs/embeds/12-setFooter.png"">Example</a></b>
     *
     * <p><b>Uploading images with Embeds</b>
     * <br>When uploading an <u>image</u>
     * (using {@link net.dv8tion.jda.api.entities.channel.middleman.MessageChannel#sendFiles(net.dv8tion.jda.api.utils.FileUpload...) MessageChannel.sendFiles(...)})
     * you can reference said image using the specified filename as URI {@code attachment://filename.ext}.
     *
     * <p><u>Example</u>
     * <pre><code>
     * MessageChannel channel; // = reference of a MessageChannel
     * EmbedBuilder embed = new EmbedBuilder();
     * InputStream file = new URL(""https://http.cat/500"").openStream();
     * embed.setFooter(""Cool footer!"", ""attachment://cat.png"") // we specify this in sendFile as ""cat.png""
     *      .setDescription(""This is a cute cat :3"");
     * channel.sendFiles(FileUpload.fromData(file, ""cat.png"")).setEmbeds(embed.build()).queue();
     * </code></pre>
     *
     * @param  text
     *         the text of the footer of the embed. If this is not set, the footer will not appear in the embed.
     * @param  iconUrl
     *         the url of the icon for the footer
     *
     * @throws java.lang.IllegalArgumentException
     *         <ul>
     *             <li>If the character limit for {@code text}, defined by {@link net.dv8tion.jda.api.entities.MessageEmbed#TEXT_MAX_LENGTH} as {@value net.dv8tion.jda.api.entities.MessageEmbed#TEXT_MAX_LENGTH},
     *             is exceeded.</li>
     *             <li>If the character limit for {@code iconUrl}, defined by {@link net.dv8tion.jda.api.entities.MessageEmbed#URL_MAX_LENGTH} as {@value net.dv8tion.jda.api.entities.MessageEmbed#URL_MAX_LENGTH},
     *             is exceeded.</li>
     *             <li>If the provided {@code iconUrl} is not a properly formatted http or https url.</li>
     *         </ul>
     *
     * @return the builder after the footer has been set
     */",net.dv8tion.jda.api
"public RestSticker getGuildStickerById(final Snowflake guildId, final Snowflake stickerId) {
        return RestSticker.create(this, guildId, stickerId);
    }","/**
     * Requests to retrieve the guild sticker represented by the supplied IDs.
     *
     * @param guildId The ID of the guild.
     * @param stickerId The ID of the sticker.
     * @return A {@link RestSticker} as represented by the supplied IDs.
     */",discord4j.rest
"@Nullable
    public RoleIcon getNewIcon()
    {
        return getNewValue();
    }","/**
     * The new icon
     *
     * @return The new icon
     */",net.dv8tion.jda.api.events.role.update
str = String.valueOf(value);,"/**
     * Format a given {@link Object} to a {@link String}, optionally limiting their length.
     *
     * @param value the value to format
     * @param maxLength maximum length of the formatted value if positive or impose no limit otherwise.
     * @return a formatted value
     */",discord4j.common
"public Publisher<?> onAutoModRuleCreate(AutoModRuleCreateEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when an automod rule has been created.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"@Nullable
    GuildMessageChannelUnion getChannel();","/**
     * The {@link GuildMessageChannelUnion} that this execution occurred in.
     *
     * <p>This might be {@code null} if the execution occurred by future event types.
     *
     * @return The {@link GuildMessageChannelUnion}
     */",net.dv8tion.jda.api.entities.automod
Mono<Void> sendBuffer(Publisher<ByteBuf> publisher);,"/**
     * Sends a sequence of {@link ByteBuf} payloads through this {@link GatewayClient} and returns a {@link Mono}
     * that signals completion when the given publisher completes.
     * <p>
     * Sequences produced this way are not expected to be validated against errors or invalid input by the underlying
     * implementation.
     *
     * @param publisher a sequence of outbound payloads
     * @return a {@link Mono} signaling completion, if an error occurs while producing it is emitted through the Mono
     */",discord4j.gateway
"public Optional<ForumChannel> getOld() {
        return Optional.ofNullable(old);
    }","/**
     * Gets the old version of the {@link ForumChannel} that was updated in this event, if present.
     *
     * @return The old version of the updated {@link ForumChannel}, if present.
     */",discord4j.core.event.domain.channel
int getMinValues();,"/**
     * The minimum amount of values a user has to select.
     *
     * @return The min values
     */",net.dv8tion.jda.api.interactions.components.selections
"@Nonnull
    PermissionOverrideAction resetDeny();","/**
     * Resets the denied permissions to the current original value.
     * <br>For a new override this will just be 0.
     *
     * @return The current PermissionOverrideAction for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
"@Nonnull
        public Builder<E> filter(@Nonnull Predicate<? super E> filter)
        {
            Checks.notNull(filter, ""Filter"");
            filters.add(filter);
            return this;
        }","/**
         * Adds an event filter, all filters need to return {@code true} for the event to be consumed.
         *
         * <p>If the filter throws an exception, this listener will unregister itself.
         *
         * @param  filter
         *         The filter to add, returns {@code true} if the event can be consumed
         *
         * @throws IllegalArgumentException
         *         If the filter is null
         *
         * @return This instance for chaining convenience
         */",net.dv8tion.jda.api.utils
long getDenied();,"/**
     * The currently set of denied permission bits.
     * <br>This value represents all <b>denied</b> permissions
     * in the raw bitwise representation.
     *
     * <p>Use {@link #getDeniedPermissions()} to retrieve a {@link java.util.List List}
     * with {@link net.dv8tion.jda.api.Permission Permissions} for this value
     *
     * @return long value of denied permissions
     */",net.dv8tion.jda.api.requests.restaction
"public int getShardTotal()
        {
            return shardTotal;
        }","/**
         * The recommended shard total
         *
         * @return The shard total
         */",net.dv8tion.jda.api.utils
"@Nonnull
    @Override
    GuildWelcomeScreenManager reset(long... fields);","/**
     * Resets the specified fields.
     * <br>Example: {@code manager.reset(GuildWelcomeScreenManager.DESCRIPTION, GuildWelcomeScreenManager.CHANNELS);}
     *
     * <p><b>Flag Constants:</b>
     * <ul>
     *     <li>{@link #ENABLED}</li>
     *     <li>{@link #DESCRIPTION}</li>
     *     <li>{@link #CHANNELS}</li>
     * </ul>
     *
     * @param  fields
     *         Integer value containing the flags to reset.
     *
     * @return GuildWelcomeScreenManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"@RequestMapping(value = ""register"", method = RequestMethod.POST)
    public Mono<Void> register(@Valid @RequestBody UserCreateDTO dto) {
        return service.register(dto);
    }","/**
     * This method sends the DTO to the service's register method.
     *
     * @param dto -> UserCreateDTO comes from the corresponding request body
     * @return Mono<Void>
     * @since 1.0
     */",org.khasanof.citiesapi.controller.user
void onConnectionLost();,"/**
     * This method is used to indicate to JDA that the UDP connection has been lost, whether that be due internet loss
     * or some other unknown reason. This is similar to
     * {@link #onConnectionError(net.dv8tion.jda.api.audio.hooks.ConnectionStatus)} as it provides a default error
     * reason of {@link net.dv8tion.jda.api.audio.hooks.ConnectionStatus#ERROR_LOST_CONNECTION}.
     */",net.dv8tion.jda.api.audio.factory
"@Nonnull
    default MessageCreateAction setMessageReference(long messageId)
    {
        return setMessageReference(Long.toUnsignedString(messageId));
    }","/**
     * Message reference used for a reply.
     * <br>The client will show this message as a reply to the target message.
     *
     * <p>You can only reply to messages from the same channel.
     * By default, this will mention the author of the target message, this can be disabled using {@link #mentionRepliedUser(boolean)}.
     *
     * <p>This also requires {@link net.dv8tion.jda.api.Permission#MESSAGE_HISTORY Permission.MESSAGE_HISTORY} in the channel.
     * If this permission is missing, you receive {@link net.dv8tion.jda.api.requests.ErrorResponse#REPLY_FAILED_MISSING_MESSAGE_HISTORY_PERM ErrorResponse.REPLY_FAILED_MISSING_MESSAGE_HISTORY_PERM}.
     *
     * <p>If the target message does not exist, this will result in {@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_MESSAGE ErrorResponse.UNKNOWN_MESSAGE}.
     * You can use {@link #failOnInvalidReply(boolean)} to allow unknown or deleted messages.
     *
     * @param  messageId
     *         The target message id to reply to
     *
     * @return The same instance for chaining
     */",net.dv8tion.jda.api.requests.restaction
void resetCodificationFrame();,"/**
     * Reset the gesture frame.
     */",jestures.core.tracking
"@Deprecated
    public JacksonResources() {
        this(HANDLE_UNKNOWN_PROPERTIES);
    }","/**
     * Create a default {@link ObjectMapper} that allows any field visibility,
     * registers modules to handle Discord4J specific mappings and ignores unknown properties.
     *
     * @deprecated use {@link #create()}
     */",discord4j.common
"@Nullable
    public ImageProxy getOldIcon()
    {
        final String oldIconUrl = getOldIconUrl();
        return oldIconUrl == null ? null : new ImageProxy(oldIconUrl);
    }","/**
     * Returns an {@link ImageProxy} for this guild's old icon.
     * <p>
     * <b>Note:</b> the old icon may not always be downloadable as it might have been removed from Discord.
     *
     * @return Possibly-null {@link ImageProxy} of this guild's old icon
     *
     * @see    #getOldIconUrl()
     */",net.dv8tion.jda.api.events.guild.update
IntentSet set0 = IntentSet.of(GUILDS);,"/**
     * Performs a logical <b>AND</b> of this intent set with the other intent set.
     * <p>
     * The resultant set is the <b>intersection</b> of this set and the other set. A intent is contained if and only
     * if it was
     * contained in both this set and the other set. This is analogous to {@link Set#retainAll(java.util.Collection)}.
     * <pre>
     * {@code
     * IntentSet set0 = IntentSet.of(GUILDS, GUILD_MEMBERS);
     * IntentSet set1 = IntentSet.of(GUILDS);
     *
     * set0.and(set1) = IntentSet.of(GUILDS)
     * }
     * </pre>
     *
     * @param other The other intent set.
     * @return The intersection of this set with the other set.
     */",discord4j.gateway.intent
"public Role getRole() {
        return role;
    }","/**
     * Gets the {@link Role} that was created in this event.
     *
     * @return The {@link Role} that was created.
     */",discord4j.core.event.domain.role
"public static ThreadUpdateAction threadUpdate(int shardIndex, ThreadUpdate dispatch) {
        return new ThreadUpdateAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link ThreadUpdate} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link ThreadUpdateAction}
     */",discord4j.common.store.action.gateway
"public long getChannelId()
    {
        return channelId;
    }","/**
     * The id for the responsible {@link GuildChannel} instance.
     *
     * @return The ID as a long or 0
     *
     * @since  4.0.0
     *
     * @see    #getChannel(net.dv8tion.jda.api.JDA)
     */",net.dv8tion.jda.api.exceptions
"@Nonnull
    @Override
    public Channel getEntity()
    {
        return getChannel();
    }","/**
     * The {@link Channel} entity affected by this update event.
     * <br>Equivalent with {@code getChannel()}.
     *
     * @return The {@link Channel} entity affected by this update event.
     */",net.dv8tion.jda.api.events.channel.update
"public long getMessageAuthorIdLong()
    {
        return messageAuthorId;
    }","/**
     * The user id of the original message author.
     * <br>This might be 0 for webhook messages.
     *
     * @return The user id of the original message author.
     */",net.dv8tion.jda.api.events.message.react
"public List<ThreadChannel> getThreads() {
        return threads;
    }","/**
     * Gets the thread channels in this portion of the threads list.
     *
     * @return The thread channels in this portion of the threads list.
     */",discord4j.core.object
"public Mono<Message> editReply(InteractionReplyEditSpec spec) {
        Objects.requireNonNull(spec);
        return Mono.defer(() -> {
                    InteractionReplyEditSpec actualSpec = getClient().getRestClient().getRestResources()
                            .getAllowedMentions()
                            .filter(allowedMentions -> !spec.isAllowedMentionsPresent())
                            .map(spec::withAllowedMentionsOrNull)
                            .orElse(spec);
                    return getInteractionResponse().editInitialResponse(actualSpec.asRequest());
                })
                .map(data -> new Message(getClient(), data));
    }","/**
     * Edits the initial reply sent when accepting this interaction with the given spec contents.
     * <p>
     * For component interactions, like buttons or select menus, this method modifies the message depending on the
     * initial response method chosen: if {@link #deferReply()} or {@link #reply()} was used, the <strong>new</strong>
     * message created with the reply; if {@link ComponentInteractionEvent#edit()} or
     * {@link ComponentInteractionEvent#deferEdit()} was used, this method will modify the message the component is on.
     * <p>
     * By default, this method will append any file added through {@code withFiles}. To replace or remove individual
     * attachments, use {@code withAttachment} along with {@link discord4j.core.object.entity.Attachment} objects from
     * the original message you want to keep. It is not required to include the new files as {@code Attachment} objects.
     * <p>
     * See the docs for {@link #editReply()} for examples and adapt them to a standalone spec.
     *
     * @param spec an immutable object that specifies how to edit the initial reply
     * @return a {@link Mono} where, upon successful completion, emits the updated message. If an error is received,
     * it is emitted through the {@code Mono}.
     */",discord4j.core.event.domain.interaction
"@RequestMapping(value = ""list"", method = RequestMethod.GET)
    public Flux<UserGetDTO> list() {
        return service.list();
    }","/**
     * This method is used to return the result.
     *
     * @return Flux<UserGetDTO>
     * @since 1.0
     */",org.khasanof.citiesapi.controller.user
"public static boolean getBoolean(@Nonnull DataObject root, @Nonnull String path, boolean fallback)
    {
        Boolean bool = get(root, path, (obj, key) -> obj.getBoolean(key, fallback), (arr, index) -> arr.getBoolean(index, fallback));
        return bool != null ? bool : fallback;
    }","/**
     * Parses the given {@code path} and finds the appropriate value within this {@link DataObject}.
     *
     * @param  root
     *         The root data object, which is the top level accessor.
     *         <br>The very first element in the path corresponds to a field of that name within this root object.
     * @param  path
     *         The path of the value, in accordance with the described grammar by {@link DataPath}.
     *         This must start with a name element, such as {@code ""foo""}.
     *
     * @throws ParsingException
     *         If the path is invalid or resolving fails due to missing elements
     * @throws IndexOutOfBoundsException
     *         If any of the elements in the path refer to an array index that is out of bounds
     * @throws IllegalArgumentException
     *         If null is provided or the path is empty
     *
     * @return The boolean value at the given path, if declared as optional this returns the provided fallback when the value is missing.
     */",net.dv8tion.jda.api.utils.data
boolean test(ApplicationCommandInteractionData acid);,"/**
     * Match whether the incoming interaction can be handled by this command.
     *
     * @param acid the incoming interaction data
     * @return {@code true} if this command can handle this interaction, {@code false} otherwise
     */",discord4j.rest.interaction
"public boolean isRelativeRateLimit()
    {
        return relativeRateLimit;
    }","/**
     * Whether to use {@code X-RateLimit-Reset-After} to determine the rate-limit backoff.
     * <br>If this is disabled, the default {@link RestRateLimiter} will use the {@code X-RateLimit-Reset} header timestamp to compute the relative backoff.
     *
     * @return True, if relative reset after is enabled
     */",net.dv8tion.jda.api.requests
"public static final Route STICKER_PACKS_GET = Route.get(""/sticker-packs"");","/**
     * Returns the list of available sticker packs.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/sticker#list-sticker-packs"">
     * https://discord.com/developers/docs/resources/sticker#list-sticker-packs</a>
     */",discord4j.rest.route
"@Nonnull
    List<LayoutComponent> getComponents();","/**
     * A List of {@link LayoutComponent LayoutComponents} that this modal contains.
     *
     * @return List of LayoutComponents
     */",net.dv8tion.jda.api.interactions.modals
"@Nonnull
    public R clear()
    {
        this.embeds.clear();
        this.components.clear();
        this.content.setLength(0);
        this.mentions.clear();
        this.messageFlags = 0;
        return (R) this;
    }","/**
     * Clears this builder's state, resetting it to the initial state identical to creating a new instance.
     *
     * <p><b>WARNING:</b> This will remove all the files added to the builder, but will not close them.
     * You can use {@link #closeFiles()} <em>before</em> calling {@code clear()} to close the files explicitly.
     *
     * @return The same builder instance for chaining
     */",net.dv8tion.jda.api.utils.messages
"@Nonnull
    @CheckReturnValue
    default PermissionOverrideAction setAllowed(@Nullable Collection<Permission> permissions)
    {
        if (permissions == null || permissions.isEmpty())
            return setAllowed(0);
        Checks.noneNull(permissions, ""Permissions"");
        return setAllowed(Permission.getRaw(permissions));
    }","/**
     * Sets the value of explicitly granted permissions
     * using a Collection of {@link net.dv8tion.jda.api.Permission Permissions}.
     * <br><b>Note: Permissions not marked as {@link net.dv8tion.jda.api.Permission#isChannel() isChannel()} will have no affect!</b>
     *
     * <p>Example: {@code setAllow(EnumSet.of(Permission.VIEW_CHANNEL))}</p>
     *
     * @param  permissions
     *         The Collection of Permissions representing the granted
     *         permissions for the new PermissionOverride.
     *         <br>If the provided value is {@code null} the permissions are reset to the default of none
     *
     * @throws java.lang.IllegalArgumentException
     *         If the any of the specified Permissions is {@code null}
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have {@link Permission#MANAGE_PERMISSIONS Permission.MANAGE_PERMISSIONS}
     *         on the channel and tries to set permissions it does not have in the channel
     *
     * @return The current PermissionOverrideAction - for chaining convenience
     *
     * @see    java.util.EnumSet EnumSet
     * @see    #setAllowed(net.dv8tion.jda.api.Permission...) setAllow(Permission...)
     */",net.dv8tion.jda.api.requests.restaction
"public boolean isGuildDeafened()
    {
        return guildDeafened;
    }","/**
     * Whether the member was deafened by a moderator in this event
     *
     * @return True, if a moderator deafened this member,
     *         <br>False, if a moderator un-deafened this member
     */",net.dv8tion.jda.api.events.guild.voice
"public GuildService getGuildService() {
        return guildService;
    }","/**
     * Access a low-level representation of the API endpoints for the Guild resource. It is recommended you use
     * methods like {@link #getGuildById(Snowflake)}, {@link #restGuild(GuildData)} or
     * {@link RestGuild#create(RestClient, Snowflake)}.
     *
     * @return a handle to perform low-level requests to the API
     */",discord4j.rest
"@Nonnull
    EntitlementPaginationAction guild(long guildId);","/**
     * Filters {@link Entitlement Entitlement}s by a guild id
     *
     * @param guildId
     *        The guild id to filter by
     *
     * @return The current {@link EntitlementPaginationAction EntitlementPaginationAction} for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction.pagination
"public Publisher<?> onUnknownChannelCreate(UnknownChannelCreateEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when a guild channel is created, but its {@link discord4j.core.object.entity.channel.Channel.Type type}
     * is not supported or implemented.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"@Incubating
    default void setSpeakingMode(@Nonnull SpeakingMode... mode)
    {
        Checks.notNull(mode, ""Speaking Mode"");
        setSpeakingMode(Arrays.asList(mode));
    }","/**
     * The {@link SpeakingMode} that should be used when sending audio via
     * the provided {@link AudioSendHandler} from {@link #setSendingHandler(AudioSendHandler)}.
     * By default this will use {@link SpeakingMode#VOICE}.
     *
     * @param  mode
     *         The speaking modes
     *
     * @throws IllegalArgumentException
     *         If the provided array is null or empty
     *
     * @incubating Discord has not officially confirmed that this feature will be available to bots
     *
     * @see    #getSpeakingMode()
     */",net.dv8tion.jda.api.managers
MemberNode head = this.queue.peek();,"/**
     * Trims the queue by removing all elements with a count higher than 1.
     */",net.dv8tion.jda.api.utils.cache
"public Flux<GuildScheduledEventUserData> getSubscribedUsersAfter(Snowflake userId, @Nullable Boolean withMember) {
        Function<Map<String, Object>, Flux<GuildScheduledEventUserData>> doRequest = params -> {
            Optional.ofNullable(withMember).ifPresent(value -> params.put(""with_member"", value));
            return restClient.getGuildService().getScheduledEventUsers(guildId, id, params);
        };
        return PaginationUtil.paginateAfter(doRequest, data -> Snowflake.asLong(data.user().id()), userId.asLong(), 100);
    }","/**
     * Request to retrieve <i>all</i> subscribed users <i>after</i> the specified ID.
     * <p>
     * The returned {@code Flux} will emit items in chronological order (older to newest). It is recommended to limit
     * the emitted items by invoking either {@link Flux#takeWhile(Predicate)} (to retrieve IDs within a specified range)
     * or {@link Flux#take(long)} (to retrieve a specific amount of IDs).
     * <p>
     * The following example will get <i>all</i> users from {@code userId} to {@code myOtherUserId}:
     * {@code getSubscribedUsersAfter(userId).takeWhile(user -> user.getId().compareTo(myOtherUserId) <= 0)}
     *
     * @param userId The ID of the <i>oldest</i> user to retrieve.
     * @param withMember Whether to optionally include the member object in the returned data (if the user is a member).
     * @return A {@link Flux} that continually emits <i>all</i> {@link GuildScheduledEventUserData users} <i>after</i>
     * the specified ID. If an error is received, it is emitted through the {@code Flux}.
     * @see
     * <a href=""https://discord.com/developers/docs/resources/guild-scheduled-event#get-guild-scheduled-event-users"">
     * Get Guild Scheduled Event Users</a>
     */",discord4j.rest.entity
"public Optional<String> getCurrentGuildAvatarUrl(Image.Format format) {
        return Optional.ofNullable(currentAvatar)
            .map(avatar -> ImageUtil.getUrl(String.format(AVATAR_IMAGE_PATH,
                guildId, Snowflake.asString(memberId), avatar), format));
    }","/**
     * Gets the current member's guild avatar URL, if present.
     *
     * @param format the format for the URL.
     * @return The current member's guild avatar URL, if present.
     */",discord4j.core.event.domain.guild
"@Nonnull
    default Modal.Builder createCopy()
    {
        return new Builder(getId(), getTitle())
                .addComponents(getComponents());
    }","/**
     * Creates a new preconfigured {@link Modal.Builder} with the same settings used for this modal.
     * <br>This can be useful to create an updated version of this modal without needing to rebuild it from scratch.
     *
     * @return The {@link Modal.Builder} used to create the modal
     */",net.dv8tion.jda.api.interactions.modals
"@Nonnull
    @CheckReturnValue
    RoleManager setPermissions(long perms);","/**
     * Sets the {@link net.dv8tion.jda.api.Permission Permissions} of the selected {@link net.dv8tion.jda.api.entities.Role Role}.
     *
     * <p>Permissions may only include already present Permissions for the currently logged in account.
     * <br>You are unable to give permissions you don't have!
     *
     * @param  perms
     *         The new raw permission value for the selected {@link net.dv8tion.jda.api.entities.Role Role}
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have permission to apply one of the specified permissions
     *
     * @return RoleManager for chaining convenience
     *
     * @see    #setPermissions(Collection)
     * @see    #setPermissions(Permission...)
     */",net.dv8tion.jda.api.managers
"@Nonnull
    @CheckReturnValue
    default ChannelOrderAction setCategory(@Nullable Category category)
    {
        return setCategory(category, false);
    }","/**
     * Set the parent category for the currently selected channel.
     *
     * <p>By default, this will not sync the permissions with the new category.
     * You can use {@link #setCategory(Category, boolean)} to sync permissions.
     *
     * @param  category
     *         The new parent category, or null to not have any category
     *
     * @throws IllegalStateException
     *         If no entity has been selected yet, use {@link #selectPosition(Object)}
     * @throws IllegalArgumentException
     *         If the provided category is not in the same guild as the channel
     *
     * @return The current ChannelOrderAction
     */",net.dv8tion.jda.api.requests.restaction.order
String getSessionId();,"/**
     * Retrieve the ID of the current gateway session.
     *
     * @return the ID of the current gateway session. Used for resuming and voice.
     */",discord4j.gateway
"public Set<Snowflake> getCurrentRoleIds() {
        return currentRoleIds.stream()
            .map(Snowflake::of)
            .collect(Collectors.toSet());
    }","/**
     * Gets a list of {@link Snowflake} IDs of roles the {@link Member} is currently assigned.
     *
     * @return The IDs of the roles the {@link Member} is assigned.
     */",discord4j.core.event.domain.guild
"public LegacyMessageEditSpec setComponents(LayoutComponent... components) {
        return setComponents(Arrays.asList(components));
    }","/**
     * Sets the components of the message.
     *
     * @param components The message components.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public Optional<Instant> getRequestedToSpeakAt() {
        return data.requestToSpeakTimestamp()
                .map(timestamp -> DateTimeFormatter.ISO_OFFSET_DATE_TIME.parse(timestamp, Instant::from));
    }","/**
     * Gets the time at which the user requested to speak, if present.
     *
     * @return The time at which the user requested to speak, if present.
     */",discord4j.core.object
"public static final Route REACTIONS_GET = Route.get(""/channels/{channel.id}/messages/{message.id}/reactions/{emoji}"");","/**
     * Get a list of users that reacted with this emoji. Returns an array of user objects on success.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/channel#get-reactions"">
     * https://discord.com/developers/docs/resources/channel#get-reactions</a>
     */",discord4j.rest.route
"public Set<Webhook> getWebhooks() {
        return webhooks;
    }","/**
     * Get the webhooks that are involved in the entries of this portion of the audit log.
     *
     * @return The webhooks that are involved in the entries of this portion of the audit log.
     */",discord4j.core.object.audit
"@Nonnull
    @CheckReturnValue
    ThreadChannelAction setInvitable(boolean isInvitable);","/**
     * Sets whether this channel allows all members to add new members.
     * <br>When set to false, only moderators and the thread owner can add new members.
     *
     * @param  isInvitable
     *         True, if all members should be allowed to add new members
     *
     * @return The current ThreadChannelAction for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
boolean isAvailableForPurchase();,"/**
         * Whether this role has been published for user purchasing. Only {@link #hasSubscriptionListing() premium roles} 
         * can be purchased. However, a premium role must be published before it can be purchased. 
         * Additionally, a premium role can be unpublished after it has been published. Doing so will make it 
         * no longer available for purchase but will not remove the role from users who have already purchased it.
         *
         * @return True, if this role is purchasable
         *
         * @see    #hasSubscriptionListing()
         */",net.dv8tion.jda.api.entities
"@Nonnull
    @Unmodifiable
    default List<MediaChannel> getMediaChannels()
    {
        return getGuild().getMediaChannelCache().applyStream(stream ->
                stream.filter(channel -> equals(channel.getParentCategory()))
                        .sorted()
                        .collect(Helpers.toUnmodifiableList())
        );
    }","/**
     * All {@link net.dv8tion.jda.api.entities.channel.concrete.MediaChannel MediaChannels} listed for this Category
     *
     * @return Immutable list of all child ForumChannels
     */",net.dv8tion.jda.api.entities.channel.concrete
"default void setPresenceProvider(@Nullable final IntFunction<OnlineStatus> statusProvider, @Nullable final IntFunction<? extends Activity> activityProvider)
    {
        this.getShardCache().forEach(jda -> jda.getPresence().setPresence(statusProvider == null ? null : statusProvider.apply(jda.getShardInfo().getShardId()), activityProvider == null ? null : activityProvider.apply(jda.getShardInfo().getShardId())));
    }","/**
     * Sets the provider that provides the {@link net.dv8tion.jda.api.OnlineStatus OnlineStatus} and
     * {@link net.dv8tion.jda.api.entities.Activity Activity} for all shards.
     *
     * <p>This will also change the status for shards that are created in the future.
     *
     * @param  statusProvider
     *         The {@link net.dv8tion.jda.api.OnlineStatus OnlineStatus}
     *         to be used (OFFLINE/null {@literal ->} INVISIBLE)
     * @param  activityProvider
     *         A {@link net.dv8tion.jda.api.entities.Activity Activity} instance or null to reset
     *
     * @throws java.lang.IllegalArgumentException
     *         If the provided OnlineStatus is {@link net.dv8tion.jda.api.OnlineStatus#UNKNOWN UNKNOWN}
     *
     * @see    net.dv8tion.jda.api.entities.Activity#playing(String)
     * @see    net.dv8tion.jda.api.entities.Activity#streaming(String, String)
     */",net.dv8tion.jda.api.sharding
"@Nonnull
        public String getMajorParameters()
        {
            return major;
        }","/**
         * The string of major parameters used by this route.
         * <br>This is important for rate-limit handling.
         *
         * @return The string of major parameters used by this route
         */",net.dv8tion.jda.api.requests
"@Nonnull
    @Incubating
    EnumSet<SpeakingMode> getSpeakingMode();","/**
     * The {@link SpeakingMode} that should be used when sending audio via
     * the provided {@link AudioSendHandler} from {@link #setSendingHandler(AudioSendHandler)}.
     * By default this will use {@link SpeakingMode#VOICE}.
     *
     * @return The current speaking mode, represented in an {@link EnumSet}
     *
     * @incubating Discord has not officially confirmed that this feature will be available to bots
     *
     * @see    #setSpeakingMode(Collection)
     */",net.dv8tion.jda.api.managers
"@Override
    public boolean equals(@Nullable final Object obj) {
        return (obj instanceof Snowflake) && (((Snowflake) obj).id == id);
    }","/**
     * Indicates whether some other object is ""equal to"" this {@code Snowflake}.
     * The other object is considered equal if:
     * <ul>
     * <li>It is also a {@code Snowflake} and;</li>
     * <li>Both instances have equal {@link #asLong() IDs}.</li>
     * </ul>
     *
     * @param obj An object to be tested for equality.
     * @return {@code true} if the other object is ""equal to"" this one, false otherwise.
     */",discord4j.common.util
"@Nonnull
    @CheckReturnValue
    InviteAction setMaxUses(@Nullable final Integer maxUses);","/**
     * Sets the max uses for the invite. Set this to {@code 0} if the invite should have unlimited uses. Default is {@code 0}.
     * {@code null} will reset this to the default value.
     *
     * @param  maxUses
     *         The max uses for this invite or {@code null} to use the default value.
     *
     * @throws IllegalArgumentException
     *         If maxUses is negative.
     *
     * @return The current InviteAction for chaining.
     */",net.dv8tion.jda.api.requests.restaction
"@Nullable
    public AudioChannelUnion getChannelJoined()
    {
        return (AudioChannelUnion) next;
    }","/**
     * The {@link AudioChannelUnion} that was joined
     *
     * @return The {@link AudioChannelUnion}, or {@code null} if the member has disconnected
     */",net.dv8tion.jda.api.events.guild.voice
"@Nonnull
    @CheckReturnValue
    ScheduledEventAction setImage(@Nullable Icon icon);","/**
     * Sets the cover image for the new {@link ScheduledEvent ScheduledEvent}.
     *
     * @param  icon
     *         The cover image for the new {@link ScheduledEvent ScheduledEvent},
     *         or {@code null} for no cover image
     *
     * @return The current ScheduledEventAction, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
"@Nonnull
    public Result<T> onFailure(@Nonnull Consumer<? super Throwable> callback)
    {
        Checks.notNull(callback, ""Callback"");
        if (isFailure())
            callback.accept(error);
        return this;
    }","/**
     * Passive error handler.
     * <br>This will apply the provided callback if {@link #isFailure()} is true
     * and return the same result for further chaining.
     *
     * @param  callback
     *         The passive callback
     *
     * @throws IllegalArgumentException
     *         If the callback is null
     *
     * @return The same result instance
     */",net.dv8tion.jda.api.utils
"@Nonnull
    @CheckReturnValue
    default Button withId(@Nonnull String id)
    {
        Checks.notEmpty(id, ""ID"");
        Checks.notLonger(id, ID_MAX_LENGTH, ""ID"");
        return new ButtonImpl(id, getLabel(), getStyle(), null, isDisabled(), getEmoji());
    }","/**
     * Returns a copy of this button with the provided id.
     *
     * @param  id
     *         The id to use
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If the provided {@code id} is null or empty.</li>
     *             <li>If the character limit for {@code id}, defined by {@link #ID_MAX_LENGTH} as {@value #ID_MAX_LENGTH},
     *             is exceeded.</li>
     *         </ul>
     *
     * @return New button with the changed id
     */",net.dv8tion.jda.api.interactions.components.buttons
"@Nonnull
    public static SubcommandData fromSubcommand(@Nonnull Command.Subcommand subcommand)
    {
        Checks.notNull(subcommand, ""Subcommand"");
        SubcommandData data = new SubcommandData(subcommand.getName(), subcommand.getDescription());
        data.setNameLocalizations(subcommand.getNameLocalizations().toMap());
        data.setDescriptionLocalizations(subcommand.getDescriptionLocalizations().toMap());
        subcommand.getOptions()
                .stream()
                .map(OptionData::fromOption)
                .forEach(data::addOptions);
        return data;
    }","/**
     * Converts the provided {@link Command.Subcommand} into a SubCommandData instance.
     *
     * @param  subcommand
     *         The subcommand to convert
     *
     * @throws IllegalArgumentException
     *         If null is provided or the subcommand has illegal configuration
     *
     * @return An instance of SubCommandData
     */",net.dv8tion.jda.api.interactions.commands.build
"@Nonnull
    @CheckReturnValue
    M setAvailableTags(@Nonnull List<? extends BaseForumTag> tags);","/**
     * Sets the <b><u>available tags</u></b> of the selected {@link IPostContainer}.
     * <br>Tags will be ordered based on the provided list order.
     *
     * <p>This is a full replacement of the tags list, all missing tags will be removed.
     * You can use {@link ForumTagData} to create new tags or update existing ones.
     *
     * <p><b>Example</b>
     * <pre>{@code
     * List<BaseForumTag> tags = new ArrayList<>(channel.getAvailableTags());
     * tags.add(new ForumTagData(""question"").setModerated(true)); // add a new tag
     * tags.set(0, ForumTagData.from(tags.get(0)).setName(""bug report"")); // update an existing tag
     * // Update the tag list
     * channel.getManager().setAvailableTags(tags).queue();
     * }</pre>
     *
     * @param  tags
     *         The new available tags in the desired order.
     *
     * @throws IllegalArgumentException
     *         If the provided list is null or contains null elements
     *
     * @return ChannelManager for chaining convenience
     *
     * @see    IPostContainer#getAvailableTags()
     */",net.dv8tion.jda.api.managers.channel.attribute
public abstract String asFormat();,"/**
     * Gets the formatted version of this emoji (i.e., to display in the client).
     *
     * @return The formatted version of this emoji (i.e., to display in the client).
     */",discord4j.core.object.reaction
"public Optional<Guild> getGuild() {
        return Optional.ofNullable(guild);
    }","/**
     * Gets the {@link Guild} involved in this event, if present.
     *
     * @return The {@link Guild} involved in this event, if present.
     */",discord4j.core.event.domain.guild
"public static String forGuildResourceNavigation(final Guild.ResourceNavigation resourceNavigation) {
        return ""<id:"" + resourceNavigation.getValue() + "">"";
    }","/**
     * Gets a <i>raw</i> mention for a {@link Guild.ResourceNavigation}.
     *
     * <p>This is the format utilized to directly mention a Guild Resource Navigation.</p>
     *
     * @param resourceNavigation The type of the resource navigation to mention.
     * @return The <i>raw</i> mention.
     */",discord4j.core.util
"public C build() {
        return build(DefaultRouter::new);
    }","/**
     * Create a client capable of connecting to Discord REST API and to establish Gateway and Voice Gateway connections,
     * using a {@link DefaultRouter} that is capable of working in monolithic environments.
     *
     * @return a configured {@link DiscordClient} based on this builder parameters
     */",discord4j.core
"@Nonnull
    @CheckReturnValue
    Builder<? extends SelectMenu, ? extends Builder<?, ?>> createCopy();","/**
     * Creates a new preconfigured {@link SelectMenu.Builder} with the same settings used for this select menu.
     * <br>This can be useful to create an updated version of this menu without needing to rebuild it from scratch.
     *
     * @return The {@link SelectMenu.Builder} used to create the select menu
     */",net.dv8tion.jda.api.interactions.components.selections
"private RecordingFactory() {
    }","/*******************************************************************************
 * Copyright (c) 2018 Giulianini Luca
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *******************************************************************************/",jestures.core.view.utils
"public List<ApplicationCommandInteractionOption> getOptions() {
        return data.options().toOptional().orElse(Collections.emptyList()).stream()
                .map(data -> new ApplicationCommandInteractionOption(gateway, data, guildId,
                        this.data.resolved().toOptional().orElse(null)))
                .collect(Collectors.toList());
    }","/**
     * Gets the options of the invoked command.
     *
     * @return The options of the invoked command.
     */",discord4j.core.object.command
"@Nullable
        EmojiUnion getEmoji();","/**
         * The emoji that is used for this recommended channel.
         * <br>This will return {@code null} if no emoji was set
         *
         * <p>The emoji will always be from this guild, if not a unicode emoji
         * <br><b>{@link CustomEmoji#isAnimated()} will always return {@code false} if:</b>
         * <ul>
         *     <li>This welcome screen came from an {@link Invite.Guild invite's guild}</li>
         *     <li>{@link net.dv8tion.jda.api.utils.cache.CacheFlag#EMOJI CacheFlag.EMOJI} is disabled</li>
         * </ul>
         *
         * @return The emoji that is used for this recommended channel or {@code null}
         */",net.dv8tion.jda.api.entities
"@Nonnull
    @CheckReturnValue
    PermOverrideManager clear(long permissions);","/**
     * Clears the provided {@link net.dv8tion.jda.api.Permission Permissions} bits
     * from the selected {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverride}.
     * <br>This will cause the provided Permissions to be inherited
     *
     * @param  permissions
     *         The permissions to clear from the selected {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverride}
     *
     * @return PermOverrideManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"public GatewayBootstrap<GatewayOptions> gateway() {
        return GatewayBootstrap.create(this);
    }","/**
     * Start bootstrapping a connection to the real-time Discord Gateway. The resulting builder can be configured to
     * create a {@link GatewayDiscordClient} which groups all connecting shards providing a single
     * {@link EventDispatcher} to publish Gateway updates and {@link Store} for entity caching.
     * <p>
     * The following are some of the features configured by this builder:
     * <ul>
     *     <li>Sharding configuration</li>
     *     <li>Initial event listeners and customization</li>
     *     <li>Gateway intents</li>
     *     <li>Initial bot status</li>
     *     <li>Custom entity cache factory</li>
     *     <li>Distributed architecture options</li>
     *     <li>Member caching options</li>
     *     <li>Guild subscriptions</li>
     *     <li>Threading model customization</li>
     *     <li>Entity fetching strategy</li>
     *     <li>Gateway and voice connection options</li>
     * </ul>
     *
     * @return a bootstrap to create {@link GatewayDiscordClient} instances.
     */",discord4j.core
"public static final Route GUILD_EMOJIS_GET = Route.get(""/guilds/{guild.id}/emojis"");","/**
     * Returns a list of emoji objects for the given guild.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/emoji#list-guild-emojis"">
     * https://discord.com/developers/docs/resources/emoji#list-guild-emojis</a>
     */",discord4j.rest.route
"public MutablePair() {
        super();
    }","/**
     * Create a new pair instance of two nulls.
     */",net.dv8tion.jda.internal.utils.tuple
"@Nonnull
    EnumSet<Permission> getPermissions(@Nonnull GuildChannel channel);","/**
     * The Permissions this PermissionHolder holds in the specified {@link GuildChannel GuildChannel}.
     * <br>Permissions returned by this may be different from {@link #getPermissions()}
     * due to the GuildChannel's {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverrides}.
     * <br><u>Changes to the returned set do not affect this entity directly.</u>
     *
     * @param  channel
     *         The {@link GuildChannel GuildChannel} of which to get Permissions for
     *
     * @throws java.lang.IllegalArgumentException
     *         If the channel is null
     *
     * @return Set of Permissions granted to this Permission Holder in the specified channel.
     */",net.dv8tion.jda.api.entities
"final List<ProjectCommit> myProjectCommits = this.assignmentService.findByEmployeeIdAndProjectId(this.credentialService.findByUsername(authentication.getName()).getEmployee().getEmployeeId(), Integer.parseInt(projectId));","/**
	 * display employee-show-commits view to show current user commits on a specific project by this url : /employee-show-my-commits
	 * @param projectId
	 * @param authentication
	 * @param model
	 * @return employee-show-commits
	 */",com.pfa.app.controller.web.employee
void setOnGestureRecognized(GestureListener listener);,"/**
     * Attache the listener.
     *
     * @param listener
     *            the listener
     */",jestures.core.recognition
"public static final Route GROUP_DM_RECIPIENT_ADD = Route.put(""/channels/{channel.id}/recipients/{user.id}"");","/**
     * Adds a recipient to a Group DM using their access token.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/channel#group-dm-add-recipient"">
     * https://discord.com/developers/docs/resources/channel#group-dm-add-recipient</a>
     */",discord4j.rest.route
"@Nonnull
    @CheckReturnValue
    GuildManager setBanner(@Nullable Icon banner);","/**
     * Sets the Banner {@link net.dv8tion.jda.api.entities.Icon Icon} of this {@link net.dv8tion.jda.api.entities.Guild Guild}.
     *
     * @param  banner
     *         The new banner for this {@link net.dv8tion.jda.api.entities.Guild Guild}
     *         or {@code null} to reset
     *
     * @throws java.lang.IllegalStateException
     *         If the guild's {@link net.dv8tion.jda.api.entities.Guild#getFeatures() features} do not include {@code BANNER}
     *
     * @return GuildManager for chaining convenience
     */",net.dv8tion.jda.api.managers
void attacheKinect(KinectObserver kinect);,"/**
     * Attache kinect instance for notification.
     *
     * @param kinect
     *            the KinectObserver
     */",jestures.sensor.kinect
"public Mono<StageInstanceData> edit(final StageInstanceModifyRequest request, @Nullable String reason) {
        return restClient.getStageInstanceService().modifyStageInstance(channelId, request, reason);
    }","/**
     * Requests to edit this stage instance.
     *
     * @param request A {@link StageInstanceModifyRequest} to parameterize this request.
     * @param reason The reason, if present.
     * @return A {@link Mono} where, upon successful completion, emits the edited {@link StageInstanceData}. If an error
     * is received, it is emitted through the {@code Mono}.
     */",discord4j.rest.entity
"@Nonnull
        public Builder setTitle(@Nonnull String title)
        {
            Checks.notBlank(title, ""Title"");
            Checks.notLonger(title, MAX_TITLE_LENGTH, ""Title"");
            this.title = title;
            return this;
        }","/**
         * Sets the title for this modal.
         *
         * @param  title 
         *         The title
         *
         * @throws IllegalArgumentException
         *         If the provided title is null, blank or longer than {@value #MAX_TITLE_LENGTH} characters
         *
         * @return The same builder instance for chaining
         */",net.dv8tion.jda.api.interactions.modals
"@Nonnull
    <C extends T> ChannelCacheView<C> ofType(@Nonnull Class<C> type);","/**
     * Creates a decorator around this cache, filtered to only provide access to the given type.
     *
     * @param type
     *        The type class (Like {@code TextChannel.class})
     * @param <C>
     *        The type parameter
     *
     * @throws IllegalArgumentException
     *         If null is provided
     *
     * @return The filtered cache view
     */",net.dv8tion.jda.api.utils.cache
"public PartialStickerData getStickerData() {
        return data;
    }","/**
     * Gets the data of the sticker.
     *
     * @return The data of the sticker.
     */",discord4j.core.object.entity
"@Nonnull
    PermissionOverrideAction getManager();","/**
     * Returns the {@link net.dv8tion.jda.api.requests.restaction.PermissionOverrideAction PermissionOverrideAction} to modify this PermissionOverride.
     * <br>In the PermissionOverrideAction you can modify the permissions of the override.
     * You modify multiple fields in one request by chaining setters before calling {@link net.dv8tion.jda.api.requests.RestAction#queue() RestAction.queue()}.
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have {@link net.dv8tion.jda.api.Permission#MANAGE_PERMISSIONS Permission.MANAGE_PERMISSIONS}
     *
     * @return The PermissionOverrideAction of this override.
     */",net.dv8tion.jda.api.entities
long getResponseNumber();,"/**
     * The current sequence for this event.
     * <br>This can be used to keep events in order when making sequencing system.
     *
     * @return The current sequence number for this event
     */",net.dv8tion.jda.api.events
"@Nonnull
    @CheckReturnValue
    default CommandListUpdateAction addCommands(@Nonnull CommandData... commands)
    {
        Checks.noneNull(commands, ""Command"");
        return addCommands(Arrays.asList(commands));
    }","/**
     * Adds up to
     * {@value Commands#MAX_SLASH_COMMANDS} slash commands,
     * {@value Commands#MAX_USER_COMMANDS} user context commands, and
     * {@value Commands#MAX_MESSAGE_COMMANDS} message context commands.
     *
     * <p>When a command is not listed in this request, it will be deleted.
     *
     * @param  commands
     *         The {@link CommandData commands} to add
     *
     * @throws IllegalArgumentException
     *         If null or more than
     *         {@value Commands#MAX_SLASH_COMMANDS} slash commands,
     *         {@value Commands#MAX_USER_COMMANDS} user context commands, or
     *         {@value Commands#MAX_MESSAGE_COMMANDS} message context commands, are provided
     *
     * @return The CommandUpdateAction instance, for chaining
     *
     * @see    Commands#slash(String, String) Commands.slash(...)
     * @see    Commands#message(String) Commands.message(...)
     * @see    Commands#user(String) Commands.user(...)
     */",net.dv8tion.jda.api.requests.restaction
"public Optional<Instant> getCurrentPremiumSince() {
        return Optional.ofNullable(currentPremiumSince)
            .map(timestamp -> DateTimeFormatter.ISO_OFFSET_DATE_TIME.parse(timestamp, Instant::from));
    }","/**
     * Gets when the user started boosting the guild, if present.
     *
     * @return When the user started boosting the guild, if present.
     */",discord4j.core.event.domain.guild
"public Flux<VoiceState> getSpeakers() {
        return getVoiceStates()
                .filter(voiceState -> !voiceState.isSuppressed() && !voiceState.getRequestedToSpeakAt().isPresent());
    }","/**
     * Requests to retrieve the voice states of this channel associated to speaker users.
     *
     * @return A {@link Flux} that continually emits the {@link VoiceState voice states} of this stage channel
     * associated to speaker users. If an error is received, it is emitted through the {@code Flux}.
     */",discord4j.core.object.entity.channel
"@Override
    @Nonnull
    @CheckReturnValue
    AuditableRestAction<Void> delete();","/**
     * Deletes this GuildChannel.
     *
     * <p>Possible ErrorResponses include:
     * <ul>
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_CHANNEL UNKNOWN_CHANNEL}
     *     <br>If this channel was already deleted</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS}
     *     <br>The send request was attempted after the account lost
     *         {@link net.dv8tion.jda.api.Permission#MANAGE_CHANNEL Permission.MANAGE_CHANNEL} in the channel.</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS}
     *     <br>If we were removed from the Guild</li>
     * </ul>
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         if the currently logged in account doesn't have {@link net.dv8tion.jda.api.Permission#MANAGE_CHANNEL MANAGE_CHANNEL}
     *         for the channel.
     *
     * @return {@link net.dv8tion.jda.api.requests.restaction.AuditableRestAction AuditableRestAction}
     */",net.dv8tion.jda.api.entities.channel.middleman
"public List<MessageComponent> getComponents() {
        return getInteraction().getCommandInteraction()
                .map(ApplicationCommandInteraction::getComponents)
                .orElse(Collections.emptyList()); // the list should never actually be empty, but just in case
    }","/**
     * Gets the components from the modal
     *
     * @return The components from the modal
     */",discord4j.core.event.domain.interaction
"@Nonnull
    T getSelectedEntity();","/**
     * The entity which is currently at the {@link #getSelectedPosition() selected position}
     *
     * @throws java.lang.IllegalStateException
     *         If no entity has been selected yet, use {@link #selectPosition(Object)}
     *
     * @return The currently selected entity
     */",net.dv8tion.jda.api.requests.restaction.order
"@Nullable
    @Unmodifiable
    public List<IntegrationPrivilege> getCommandPrivileges(@Nonnull String id)
    {
        Checks.notNull(id, ""Id"");
        return privileges.get(id);
    }","/**
     * The {@link IntegrationPrivilege IntegrationPrivileges} that have been applied to the command with the given id in this guild.
     *
     * <br><b>If the privileges are ""Synced"" (No custom config applied), or a command with this id doesn't exist, this will return null.</b>
     *
     * <p>This does not include privileges applied to the application directly. Use {@link #getApplicationPrivileges()} for that.
     *
     * @param  id
     *         The id of the command
     *
     * @throws IllegalArgumentException
     *         If the provided id is null
     *
     * @return Immutable List containing all IntegrationPrivileges that have been applied to the command with the given id in this guild.
     */",net.dv8tion.jda.api.interactions.commands
"public int getNewPositionRaw()
    {
        return newPositionRaw;
    }","/**
     * The new position
     *
     * @return The new position
     */",net.dv8tion.jda.api.events.role.update
"public List<ThreadMember> getThreadMembers() {
        return dispatch.members().stream().map(data -> new ThreadMember(getClient(), data)).collect(Collectors.toList());
    }","/**
     * Returns all thread member objects from the synced threads for the current user, indicating which threads the
     * current user has been added to
     */",discord4j.core.event.domain.thread
"default int getRateLimitPerUser() {
        return getData().rateLimitPerUser().toOptional()
                .orElseThrow(IllegalStateException::new);
    }","/**
     * Gets the amount of seconds a user has to wait before sending another message (0-21600).
     * <p>
     * Bots, as well as users with the permission {@code manage_messages} or {@code manage_channel}, are unaffected.
     *
     * @return The amount of seconds a user has to wait before sending another message (0-21600).
     */",discord4j.core.object.entity.channel
"public int getOldColorRaw()
    {
        return getOldValue();
    }","/**
     * The raw rgb value of the old color
     *
     * @return The raw rgb value of the old color
     */",net.dv8tion.jda.api.events.role.update
"public Mono<GuildApplicationCommandPermissionsData> modifyApplicationCommandPermissions(long applicationId,
                                                                                            long guildId,
                                                                                            long commandId,
                                                                                            ApplicationCommandPermissionsRequest request) {
        return exchange(Routes.APPLICATION_COMMAND_PERMISSIONS_MODIFY.newRequest(applicationId, guildId, commandId),
                GuildApplicationCommandPermissionsData.class);
    }","/**
     * Edits command permissions for a specific command for your application in a guild and returns a guild
     * application command permissions object. You can add up to 100 permission overwrites for a command.
     *
     * @param applicationId your application ID
     * @param guildId the guild ID
     * @param commandId the command ID
     * @param request a request body containing the permissions to be set
     * @return a Mono with command permissions object for the requested guild, or an error Mono in case a request fails
     */",discord4j.oauth2
"public boolean isWebhookMessage()
    {
        return getMessage().isWebhookMessage();
    }","/**
     * Whether or not the Message received was sent via a Webhook.
     * <br>This is a shortcut for {@code getMessage().isWebhookMessage()}.
     *
     * @return True, if the Message was sent via Webhook
     */",net.dv8tion.jda.api.events.message
"new AudioFormat(48000f, 16, 2, true, true);","/**
     * Audio Input Format expected by JDA if {@link #isOpus()} returns false. 48KHz 16bit stereo signed BigEndian PCM.
     */",net.dv8tion.jda.api.audio
"public boolean wasVerified()
    {
        return getOldValue();
    }","/**
     * Whether the account was verified
     *
     * @return True, if this account was previously verified
     */",net.dv8tion.jda.api.events.self
"public Builder initialStatus(@Nullable StatusUpdate initialStatus) {
            this.initialStatus = initialStatus;
            return this;
        }","/**
         * Set the initial presence status the bot will identify with.
         *
         * @param initialStatus a {@link StatusUpdate} to be used when authenticating
         * @return this builder
         */",discord4j.gateway
"@Nullable
    IPermissionHolder getPermissionHolder();","/**
     * This method will return the {@link net.dv8tion.jda.api.entities.IPermissionHolder PermissionHolder} of this PermissionOverride.
     * It can be used to get the general permissions of that PermissionHolder, no matter if it is a {@link net.dv8tion.jda.api.entities.Member Member} or a {@link net.dv8tion.jda.api.entities.Role Role}.
     * <br>Similar to {@link #getMember()} this will return {@code null} if the member is not cached.
     *
     * <p>To get the concrete Member or Role, use {@link PermissionOverride#getMember()} or {@link PermissionOverride#getRole()}!
     *
     * @return Possibly-null {@link net.dv8tion.jda.api.entities.IPermissionHolder IPermissionHolder} of this PermissionOverride.
     *
     * @see    PermissionOverride#getRole()
     * @see    PermissionOverride#getMember()
     */",net.dv8tion.jda.api.entities
"public int getOldPosition()
    {
        return getOldValue();
    }","/**
     * The old position
     *
     * @return The old position
     */",net.dv8tion.jda.api.events.role.update
"@Nonnull
    public String getUrl()
    {
        return ""https://discord.gg/"" + getCode();
    }","/**
     * The invite url.
     *
     * @return The invite url
     */",net.dv8tion.jda.api.entities
"@Nonnull
    @CheckReturnValue
    WebhookManager setAvatar(@Nullable Icon icon);","/**
     * Sets the <b><u>default avatar</u></b> of the selected {@link net.dv8tion.jda.api.entities.Webhook Webhook}.
     *
     * @param  icon
     *         The new default avatar {@link net.dv8tion.jda.api.entities.Icon Icon}
     *         for the selected {@link net.dv8tion.jda.api.entities.Webhook Webhook}
     *         or {@code null} to reset
     *
     * @return WebhookManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"public ApplicationCommandInteractionOptionValue(final GatewayDiscordClient gateway, @Nullable final Long guildId,
                                                    final int type, final String value,
                                                    @Nullable final ApplicationCommandInteractionResolvedData resolved) {
        this.gateway = gateway;
        this.guildId = guildId;
        this.value = value;
        this.type = type;
        this.resolved = resolved;
    }",/** The gateway associated to this object. */,discord4j.core.object.command
"@Deprecated
    public Mono<Void> replyWithPremiumRequired() {
        return Mono.defer(() -> createInteractionResponse(InteractionResponseType.PREMIUM_REQUIRED, MultipartRequest.ofRequest(InteractionApplicationCommandCallbackData.builder().build())));
    }","/**
     * Requests to respond to the interaction with a notification instructing the user that this interaction requires a premium subscription.
     *
     * @return A {@link Mono} where, upon successful completion, emits nothing; indicating the interaction response has been sent. If an error is received, it is emitted through the {@code Mono}.
     * @deprecated in favor of using {@link discord4j.core.object.component.Button#premium(Snowflake)}. This will continue to function but may be eventually unsupported
     */",discord4j.core.event.domain.interaction
"@Nonnull
    @CheckReturnValue
    default AutoCompleteCallbackAction addChoiceDoubles(@Nonnull double... choices)
    {
        return addChoices(Arrays.stream(choices)
                .mapToObj(it -> new Command.Choice(String.valueOf(it), it))
                .collect(Collectors.toList()));
    }","/**
     * Add up to {@value OptionData#MAX_CHOICES} choices which can be picked from by the user.
     * <br>The user may continue writing inputs instead of using one of your choices.
     *
     * <p>The string values of the provided doubles will be used as value and name for the {@link net.dv8tion.jda.api.interactions.commands.Command.Choice Choices}.
     *
     * @param  choices
     *         The choice suggestions to present to the user
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If {@code null} is provided</li>
     *             <li>If more than {@value OptionData#MAX_CHOICES} choices are added</li>
     *             <li>If the option type is incompatible with the choice type</li>
     *             <li>If the numeric value of any of the choices is not between {@value OptionData#MIN_NEGATIVE_NUMBER} and {@value OptionData#MAX_POSITIVE_NUMBER}</li>
     *         </ul>
     *
     * @return The same callback action, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction.interactions
boolean isReconnect();,"/**
         * Whether this node is reconnecting. Can be used to setup a priority based system.
         *
         * @return True, if this session is reconnecting
         */",net.dv8tion.jda.api.utils
"@Override
	public Assignment findById(final Integer employeeId, final Integer projectId, final LocalDateTime commitDate) {
		return this.rep.findById(employeeId, projectId, commitDate).orElseThrow(() -> new NoSuchElementException(""###### NO ELEMENT FOUND !!!!! ######""));
	}","/**
	 * retrieve a specific assignment by its composite ids
	 * @param employeeId
	 * @param projectId
	 * @param commitDate
	 * @return a specific assignment
	 */",com.pfa.app.service.impl
"Mono<Void> onGuildMemberAdd(int shardIndex, GuildMemberAdd dispatch);","/**
     * Updates the internal state of the store according to the given {@link GuildMemberAdd} gateway dispatch. This
     * will typically perform an insert operation on the related {@link MemberData}, add the ID of the member
     * into the list returned by {@link GuildData#members()}, and increment the count returned by
     * {@link GuildData#memberCount()}.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a {@link Mono} completing when the operation is done
     */",discord4j.common.store.api.layout
"@Nonnull
    public EmbedBuilder setTitle(@Nullable String title, @Nullable String url)
    {
        if (title == null)
        {
            this.title = null;
            this.url = null;
        }
        else
        {
            Checks.notEmpty(title, ""Title"");
            Checks.check(title.length() <= MessageEmbed.TITLE_MAX_LENGTH, ""Title cannot be longer than %d characters."", MessageEmbed.TITLE_MAX_LENGTH);
            if (Helpers.isBlank(url))
                url = null;
            urlCheck(url);

            this.title = title;
            this.url = url;
        }
        return this;
    }","/**
     * Sets the Title of the embed.
     * <br>You can provide {@code null} as url if no url should be used.
     * <br>If you want to set a URL without a title, use {@link #setUrl(String)} instead.
     *
     * <p><b><a href=""https://raw.githubusercontent.com/discord-jda/JDA/assets/assets/docs/embeds/04-setTitle.png"">Example</a></b>
     *
     * @param  title
     *         the title of the embed
     * @param  url
     *         Makes the title into a hyperlink pointed at this url.
     *
     * @throws java.lang.IllegalArgumentException
     *         <ul>
     *             <li>If the provided {@code title} is an empty String.</li>
     *             <li>If the character limit for {@code title}, defined by {@link net.dv8tion.jda.api.entities.MessageEmbed#TITLE_MAX_LENGTH} as {@value net.dv8tion.jda.api.entities.MessageEmbed#TITLE_MAX_LENGTH},
     *             is exceeded.</li>
     *             <li>If the character limit for {@code url}, defined by {@link net.dv8tion.jda.api.entities.MessageEmbed#URL_MAX_LENGTH} as {@value net.dv8tion.jda.api.entities.MessageEmbed#URL_MAX_LENGTH},
     *             is exceeded.</li>
     *             <li>If the provided {@code url} is not a properly formatted http or https url.</li>
     *         </ul>
     *
     * @return the builder after the title has been set
     */",net.dv8tion.jda.api
"@Nonnull
    @CheckReturnValue
    RoleAction setName(@Nullable String name);","/**
     * Sets the name for new role (optional)
     *
     * @param  name
     *         The name for the new role, null to use default name
     *
     * @throws java.lang.IllegalArgumentException
     *         If the provided name is longer than 100 characters
     *
     * @return The current RoleAction, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
"@Nullable
    public String getSubcommandGroup()
    {
        return subcommandGroup;
    }","/**
     * Returns the subcommand group of the slash command
     *
     * @return the subcommand group of the slash command
     */",net.dv8tion.jda.api.interactions.commands
"public Optional<MessageComponent.Type> getComponentType() {
        return data.componentType().toOptional().map(MessageComponent.Type::of);
    }","/**
     * Gets the type of the component.
     *
     * @return The type of the component.
     */",discord4j.core.object.command
"public Publisher<?> onEntitlementUpdate(EntitlementUpdateEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when an entitlement is updated.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"This method could not be tested due to the lack of a Discord verified application
    public Flux<SKU> getSKUs() {
        return getApplicationInfo().flatMapMany(applicationInfo -> {
            return getRestClient().getMonetizationService()
                .getAllSkus(applicationInfo.getId().asLong())
                .map(data -> new SKU(this, data));
        });
    }","/**
     * Request to retrieve all the {@link SKU SKUs} for the current application.
     *
     * @return A {@link Flux} that emits the {@link SKU SKUs} for the application upon successful completion. If an
     * error is received, it is emitted through the {@code Flux}.
     */",discord4j.core
"public static GetChannelByIdAction getChannelById(long channelId) {
        return new GetChannelByIdAction(channelId);
    }","/**
     * Creates an action to retrieve data for the channel corresponding to the given channel ID.
     *
     * @param channelId the channel ID
     * @return a new {@link GetChannelByIdAction}
     */",discord4j.common.store.action.read
"public ResolvedChannelData getData() {
        return data;
    }","/**
     * Returns the raw data as represented by Discord.
     *
     * @return the raw data
     */",discord4j.core.object.command
"public InteractionApplicationCommandCallbackReplyMono reply(final String content) {
        return reply().withContent(content);
    }","/**
     * Requests to respond to the interaction with a message initialized with the specified content. Properties
     * specifying how to build the reply message to the interaction can be set via the {@code withXxx} methods of the
     * returned {@link InteractionApplicationCommandCallbackReplyMono}.
     * <p>
     * For component interactions, like buttons or select menus, this method will create a <strong>new</strong> message.
     * If you want to modify the message the component is on, see {@link ComponentInteractionEvent#edit()} or
     * {@link ComponentInteractionEvent#deferEdit()}.
     * <p>
     * After calling {@code reply}, you are not allowed to call other acknowledging or reply method and have to
     * either work with the initial reply using {@link #getReply()}, {@link #editReply()}, {@link #deleteReply()}, or
     * using followup messages with {@link #createFollowup()}, {@link #editFollowup(Snowflake)} or
     * {@link #deleteFollowup(Snowflake)}.
     *
     * @param content a string to populate the message with
     * @return A {@link InteractionApplicationCommandCallbackReplyMono} where, upon successful completion, emits nothing;
     * indicating the interaction response has been sent. If an error is received, it is emitted through the {@code
     * InteractionApplicationCommandCallbackMono}.
     */",discord4j.core.event.domain.interaction
"@Nonnull
    @CheckReturnValue
    default AutoCompleteCallbackAction addChoiceLongs(@Nonnull long... choices)
    {
        return addChoices(Arrays.stream(choices)
                .mapToObj(it -> new Command.Choice(String.valueOf(it), it))
                .collect(Collectors.toList()));
    }","/**
     * Add up to {@value OptionData#MAX_CHOICES} choices which can be picked from by the user.
     * <br>The user may continue writing inputs instead of using one of your choices.
     *
     * <p>The string values of the provided longs will be used as value and name for the {@link net.dv8tion.jda.api.interactions.commands.Command.Choice Choices}.
     *
     * @param  choices
     *         The choice suggestions to present to the user
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If {@code null} is provided</li>
     *             <li>If more than {@value OptionData#MAX_CHOICES} choices are added</li>
     *             <li>If the option type is incompatible with the choice type</li>
     *             <li>If the numeric value of any of the choices is not between {@value OptionData#MIN_NEGATIVE_NUMBER} and {@value OptionData#MAX_POSITIVE_NUMBER}</li>
     *         </ul>
     *
     * @return The same callback action, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction.interactions
"public ResettableInterval(Scheduler scheduler) {
        this.scheduler = scheduler;
        this.task = Disposables.swap();
    }","/**
     * Create a {@link ResettableInterval} that emits ticks on the given {@link Scheduler} upon calling
     * {@link #start(Duration, Duration)}.
     *
     * @param scheduler the Reactor {@link Scheduler} to use to emit ticks
     */",discord4j.common
"public VoiceReactorResources(ReactorResources parent) {
        super(parent.getHttpClient(), parent.getTimerTaskScheduler(), parent.getBlockingTaskScheduler());
        this.udpClient = UdpClient.create();
        this.sendTaskScheduler = parent.getTimerTaskScheduler();
        this.receiveTaskScheduler = parent.getTimerTaskScheduler();
    }","/**
     * Create Voice Gateway resources based off {@link ReactorResources} properties, and providing defaults for the
     * remaining properties.
     *
     * @param parent the resources instance to get properties from
     */",discord4j.voice
"@Nonnull
    public SessionState getState()
    {
        return state;
    }","/**
     * The new session state.
     *
     * @return {@link SessionState}
     */",net.dv8tion.jda.api.events.session
"@JsonIgnore
    public int getShardIndex() {
        return shardIndex;
    }","/**
     * Return the shard index this payload is targeted at.
     *
     * @return a 0-based shard index
     */",discord4j.gateway.json
Mono<Long> countExactMembersInGuild(long guildId);,"/**
     * Counts the exact number of members for the given guild ID. If some members are not present in the store and thus
     * is not able to return an accurate count, it will error with {@link ExactResultNotAvailableException}.
     *
     * @param guildId the guild ID
     * @return A {@link Mono} emitting the member count
     */",discord4j.common.store.api.layout
"@Nonnull
        String getDefaultAvatarId();","/**
         * Gets the asset id of the member's default avatar
         * 
         * @return never-null String containing the asset id of the member's
         *         default avatar
         */",net.dv8tion.jda.api.entities
"@Nullable
    String getTopic();","/**
     * The topic set for this channel.
     * <br>If no topic has been set, this returns null.
     *
     * @return Possibly-null String containing the topic of this channel.
     */",net.dv8tion.jda.api.entities.channel.middleman
"public StageInstance(final GatewayDiscordClient gateway, final StageInstanceData data) {
        this.gateway = gateway;
        this.data = data;
        this.rest = RestStageInstance.create(gateway.rest(), Snowflake.of(data.channelId()));
    }","/**
     * Constructs a {@code StageInstance} with an associated {@link GatewayDiscordClient} and Discord data.
     *
     * @param gateway The {@link GatewayDiscordClient} associated to this object, must be non-null.
     * @param data The raw stage instance data as represented by Discord, must be non-null.
     */",discord4j.core.object.entity
"@Nonnull
    @CheckReturnValue
    MemberAction setMute(boolean mute);","/**
     * Whether the user should be voice muted in the guild.
     * <br>Default: {@code false}
     *
     * @param  mute
     *         Whether the user should be voice muted in the guild.
     *
     * @return The current MemberAction for chaining
     */",net.dv8tion.jda.api.requests.restaction
"public LegacyGuildPruneSpec addRoles(Collection<Snowflake> roleIds) {
        map.addAll(""include_roles"", roleIds.stream().map(Snowflake::asString).collect(Collectors.toList()));
        return this;
    }","/**
     * Include multiple roles in the prune request. By default, prune will not remove users with roles, therefore
     * this method can be used to include such users.
     *
     * @param roleIds the role IDs to include for prune
     * @return this spec
     */",discord4j.core.spec.legacy
"public ApplicationCommandInteractionOption getFocusedOption() {
        return getOptions().stream()
                .map(this::getFocusedOption)
                .filter(Optional::isPresent)
                .findFirst()
                .flatMap(Function.identity())
                .orElseThrow(() -> new IllegalStateException(""No focused option found""));
    }","/**
     * Gets the currently focused option for auto-complete.
     *
     * @return The currently focused option for auto-complete.
     */",discord4j.core.event.domain.interaction
"public final Mono<ChannelData> getPrivateChannel() {
        return restClient.getUserService().createDM(DMCreateRequest.builder().recipientId(Snowflake.asString(id)).build());
    }","/**
     * Requests to retrieve the private channel (DM) to this user.
     *
     * @return A {@link Mono} where, upon successful completion, emits the {@link ChannelData private channel} to
     * this user. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.rest.entity
"@Nonnull
    @CheckReturnValue
    default Button withStyle(@Nonnull ButtonStyle style)
    {
        Checks.notNull(style, ""Style"");
        Checks.check(style != ButtonStyle.UNKNOWN, ""Cannot make button with unknown style!"");
        if (getStyle() == ButtonStyle.LINK && style != ButtonStyle.LINK)
            throw new IllegalArgumentException(""You cannot change a link button to another style!"");
        if (getStyle() != ButtonStyle.LINK && style == ButtonStyle.LINK)
            throw new IllegalArgumentException(""You cannot change a styled button to a link button!"");
        return new ButtonImpl(getId(), getLabel(), style, getUrl(), isDisabled(), getEmoji());
    }","/**
     * Returns a copy of this button with the provided style.
     *
     * <p>You cannot use this convert link buttons.
     *
     * @param  style
     *         The style to use
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If the provided {@code style} is null.</li>
     *             <li>If the provided {@code style} tries to change whether this button is a {@link ButtonStyle#LINK LINK} button.</li>
     *         </ul>
     *
     * @return New button with the changed style
     */",net.dv8tion.jda.api.interactions.components.buttons
"Mono<ScheduledEvent> getScheduledEventById(Snowflake guildId, Snowflake eventId);","/**
     * Requests to retrieve the {@link ScheduledEvent} represented by the supplied IDs.
     *
     * @param guildId The ID of the guild.
     * @param eventId The ID of the scheduled event.
     * @return A {@link Mono} where, upon successful completion, emits the {@link ScheduledEvent} as represented by the
     * supplied IDs. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.retriever
"This method could not be tested due to the lack of a Discord verified application
    public Flux<SKU> getSKUs(long applicationId) {
        return getRestClient().getMonetizationService()
            .getAllSkus(applicationId)
            .map(data -> new SKU(this, data));
    }","/**
     * Request to retrieve the {@link SKU SKU} for the application with the given ID.
     *
     * @param applicationId The ID of the application.
     * @return A {@link Mono} that emits the {@link SKU SKU} for the application with the given ID upon successful
     * completion. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core
"public Set<GuildSticker> getStickers() {
        return stickers;
    }","/**
     * Gets a list of ALL stickers of the {@link Guild}.
     *
     * @return A list of ALL stickers of the {@link Guild}.
     */",discord4j.core.event.domain.guild
"public static PresenceUpdateAction presenceUpdate(int shardIndex, PresenceUpdate dispatch) {
        return new PresenceUpdateAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link PresenceUpdate} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link PresenceUpdateAction}
     */",discord4j.common.store.action.gateway
"@Nonnull
    @CheckReturnValue
    ThreadChannelManager setAutoArchiveDuration(@Nonnull ThreadChannel.AutoArchiveDuration autoArchiveDuration);","/**
     * Sets the inactive time before autoarchiving of this ThreadChannel.
     *
     * <p>This is limited to the choices offered in {@link ThreadChannel.AutoArchiveDuration}
     *
     * @param  autoArchiveDuration
     *         The new duration before an inactive channel will be autoarchived.
     *
     * @return this ThreadChannelManager for chaining convenience.
     *
     * @see ThreadChannel#getAutoArchiveDuration()
     */",net.dv8tion.jda.api.managers.channel.concrete
"@Nonnull
    @CheckReturnValue
    M setPosition(int position);","/**
     * Sets the <b><u>position</u></b> of the selected {@link GuildChannel GuildChannel}.
     *
     * <p><b>To modify multiple channels you should use
     * <code>Guild.{@link Guild#modifyTextChannelPositions() modifyTextChannelPositions()}</code>
     * instead! This is not the same as looping through channels and using this to update positions!</b>
     *
     * @param  position
     *         The new position for the selected {@link GuildChannel GuildChannel}
     *
     * @return ChannelManager for chaining convenience
     */",net.dv8tion.jda.api.managers.channel.attribute
"public Flux<ChannelData> getChannels() {
        return restClient.getGuildService().getGuildChannels(id);
    }","/**
     * Return a {@link Flux} of guild channels.
     *
     * @return a sequence of this guild channels
     */",discord4j.rest.entity
"static EmissionStrategy park(Duration duration) {
        return new ParkEmissionStrategy(duration.toNanos());
    }","/**
     * Create an {@link EmissionStrategy} that will indefinitely park emissions on overflow or non-serialized
     * scenarios until it resolves, the emitter is cancelled or the sink is terminated.
     *
     * @param duration the {@link Duration} indicating how long to disable the emitting thread after each failed attempt
     * @return a strategy that awaits emissions on overflowing sinks
     */",discord4j.common.sinks
"Mono<Void> onMessageReactionRemoveEmoji(int shardIndex, MessageReactionRemoveEmoji dispatch);","/**
     * Updates the internal state of the store according to the given {@link MessageReactionRemoveEmoji} gateway
     * dispatch. This will typically perform an update operation on a related {@link MessageData} that is already
     * present in the store in order to remove all reactions for a specific emoji.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a {@link Mono} completing when the operation is done
     */",discord4j.common.store.api.layout
"@Nonnull
    @CheckReturnValue
    ThreadChannelManager setLocked(boolean locked);","/**
     * Sets the locked state of this ThreadChannel.
     *
     * <p>This is the equivalent of archiving as a moderator.
     *
     * @param  locked
     *         The new locked state for the selected {@link ThreadChannel}
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account is not the thread owner or does not have the {@link net.dv8tion.jda.api.Permission#MANAGE_THREADS MANAGE_THREADS} permission.
     *
     * @return this ThreadChannelManager for chaining convenience.
     *
     * @see ThreadChannel#isLocked()
     */",net.dv8tion.jda.api.managers.channel.concrete
"public static GetVoiceStatesAction getVoiceStates() {
        return new GetVoiceStatesAction();
    }","/**
     * Creates an action to retrieve data for all voice states present in a store.
     *
     * @return a new {@link GetVoiceStatesAction}
     */",discord4j.common.store.action.read
"public LegacyInviteCreateSpec setTargetApplicationId(Snowflake targetApplicationId) {
        requestBuilder.targetApplicationId(targetApplicationId.asString());
        return this;
    }","/**
     * Sets the id of the embedded application to open for this invite, required if `target_type` is 2, the
     * application must have the `EMBEDDED` flag.
     *
     * @param targetApplicationId The id of the embedded application to open for this invite.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public GuildScheduledEventEntityMetadataData getData() {
        return data;
    }","/**
     * Gets the data of the entity metadata.
     *
     * @return The data of the entity metadata.
     */",discord4j.core.object
"@Nonnull
    @CheckReturnValue
    GuildManager setDescription(@Nullable String description);","/**
     * Sets the Description {@link net.dv8tion.jda.api.entities.Icon Icon} of this {@link net.dv8tion.jda.api.entities.Guild Guild}.
     *
     * @param  description
     *         The new description for this {@link net.dv8tion.jda.api.entities.Guild Guild}
     *         or {@code null} to reset
     *
     * @throws java.lang.IllegalStateException
     *         If the guild's {@link net.dv8tion.jda.api.entities.Guild#getFeatures() features} do not include {@code VERIFIED}
     *
     * @return GuildManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"@Nonnull
    SnowflakeCacheView<NewsChannel> getNewsChannelCache();","/**
     * Sorted {@link net.dv8tion.jda.api.utils.cache.SnowflakeCacheView SnowflakeCacheView} of {@link NewsChannel}.
     * <br>In {@link Guild} cache, channels are sorted according to their position and id.
     *
     * <p>This getter exists on any instance of {@link IGuildChannelContainer} and only checks the caches with the relevant scoping.
     * For {@link Guild}, {@link JDA}, or {@link ShardManager},
     * this returns the relevant channel with respect to the cache within each of those objects.
     * For a guild, this would mean it only returns channels within the same guild.
     * <br>If this is called on {@link JDA} or {@link ShardManager}, this may return null immediately after building, because the cache isn't initialized yet.
     * To make sure the cache is initialized after building your {@link JDA} instance, you can use {@link JDA#awaitReady()}.
     *
     * @return {@link net.dv8tion.jda.api.utils.cache.SortedSnowflakeCacheView SortedSnowflakeCacheView}
     */",net.dv8tion.jda.api.entities.channel.attribute
Mono<Long> countGuilds();,"/**
     * Counts the number of guilds present in the store.
     *
     * @return A {@link Mono} emitting the guild count
     */",discord4j.common.store.api.layout
"@Nonnull
    SnowflakeCacheView<TextChannel> getTextChannelCache();","/**
     * Sorted {@link net.dv8tion.jda.api.utils.cache.SnowflakeCacheView SnowflakeCacheView} of {@link TextChannel}.
     * <br>In {@link Guild} cache, channels are sorted according to their position and id.
     *
     * <p>This getter exists on any instance of {@link IGuildChannelContainer} and only checks the caches with the relevant scoping.
     * For {@link Guild}, {@link JDA}, or {@link ShardManager},
     * this returns the relevant channel with respect to the cache within each of those objects.
     * For a guild, this would mean it only returns channels within the same guild.
     * <br>If this is called on {@link JDA} or {@link ShardManager}, this may return null immediately after building, because the cache isn't initialized yet.
     * To make sure the cache is initialized after building your {@link JDA} instance, you can use {@link JDA#awaitReady()}.
     *
     * @return {@link net.dv8tion.jda.api.utils.cache.SortedSnowflakeCacheView SortedSnowflakeCacheView}
     */",net.dv8tion.jda.api.entities.channel.attribute
"public ChannelService getChannelService() {
        return channelService;
    }","/**
     * Access a low-level representation of the API endpoints for the Channel resource. It is recommended you use
     * methods like {@link #getChannelById(Snowflake)}, {@link #restChannel(ChannelData)} or
     * {@link RestChannel#create(RestClient, Snowflake)}.
     *
     * @return a handle to perform low-level requests to the API
     */",discord4j.rest
"public BigInteger asBigInteger() {
        return new BigInteger(asString());
    }","/**
     * Gets the <i>unsigned</i> ID of this {@code Snowflake} as a BigInteger.
     *
     * @return The <i>unsigned</i> ID of this {@code Snowflake} as a BigInteger.
     */",discord4j.common.util
"Route.CompiledRoute route = Route.Messages.GET_MESSAGE_HISTORY.compile(channel.getId()).withQueryParams(""before"", messageId);","/**
     * Constructs a {@link net.dv8tion.jda.api.entities.MessageHistory MessageHistory} with the initially retrieved history
     * of messages sent before the mentioned message ID (exclusive).
     * <br>The provided ID need not be valid!
     *
     * <p>Alternatively you can use {@link net.dv8tion.jda.api.entities.channel.middleman.MessageChannel#getHistoryBefore(String, int) MessageChannel.getHistoryBefore(...)}
     *
     * <p><b>Example</b>
     * <br>{@code MessageHistory history = MessageHistory.getHistoryBefore(channel, messageId).limit(60).complete()}
     * <br>Will return a MessageHistory instance with the first 60 messages sent before the provided message ID.
     *
     * <p>Alternatively you can provide an epoch millisecond timestamp using {@link TimeUtil#getDiscordTimestamp(long) MiscUtil.getDiscordTimestamp(long)}:
     * <br><pre><code>
     * long timestamp = System.currentTimeMillis(); // or any other epoch millis timestamp
     * String discordTimestamp = Long.toUnsignedString(MiscUtil.getDiscordTimestamp(timestamp));
     * MessageHistory history = MessageHistory.getHistoryBefore(channel, discordTimestamp).complete();
     * </code></pre>
     *
     * @param  channel
     *         The {@link net.dv8tion.jda.api.entities.channel.middleman.MessageChannel MessageChannel}
     * @param  messageId
     *         The pivot ID to use
     *
     * @throws java.lang.IllegalArgumentException
     *         If any of the provided arguments is {@code null};
     *         Or if the provided messageId contains whitespace
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If this is a TextChannel and the currently logged in account does not
     *         have the permission {@link net.dv8tion.jda.api.Permission#MESSAGE_HISTORY Permission.MESSAGE_HISTORY}
     *
     * @return {@link net.dv8tion.jda.api.entities.MessageHistory.MessageRetrieveAction MessageRetrieveAction}
     *
     * @see    net.dv8tion.jda.api.entities.channel.middleman.MessageChannel#getHistoryBefore(String, int)  MessageChannel.getHistoryBefore(String, int)
     * @see    net.dv8tion.jda.api.entities.channel.middleman.MessageChannel#getHistoryBefore(long, int)    MessageChannel.getHistoryBefore(long, int)
     * @see    net.dv8tion.jda.api.entities.channel.middleman.MessageChannel#getHistoryBefore(Message, int) MessageChannel.getHistoryBefore(Message, int)
     */",net.dv8tion.jda.api.entities
"public LegacyGuildCreateSpec setVerificationLevel(@Nullable Guild.VerificationLevel verificationLevel) {
        builder.verificationLevel(verificationLevel == null ?
                Possible.absent() : Possible.of(verificationLevel.getValue()));
        return this;
    }","/**
     * Sets the verification level required before a member can send messages in the created {@link Guild}.
     *
     * @param verificationLevel The verification level for the guild.
     * @return This spec.
     */",discord4j.core.spec.legacy
Flux<UserGetDTO> list();,"/**
     * This method is used to get list the UserGetDTO.
     *
     * @return Flux<CityGetDTO>
     * @since 1.0
     */",org.khasanof.citiesapi.service.user
"@Nullable
    public CloseCode getCloseCode()
    {
        return CloseCode.from(code);
    }","/**
     * Possibly-null {@link net.dv8tion.jda.api.requests.CloseCode CloseCode}
     * representing the meaning for this ShutdownEvent.
     * <br>The raw close code can be retrieved from {@link #getCode()}
     * <br>If this is {@code null}, JDA does not know what the meaning for the connection loss was.
     *
     * @return Possibly-null {@link net.dv8tion.jda.api.requests.CloseCode CloseCode}
     */",net.dv8tion.jda.api.events.session
"@Nonnull
    @CheckReturnValue
    InviteAction setMaxAge(@Nullable final Integer maxAge);","/**
     * Sets the max age in seconds for the invite. Set this to {@code 0} if the invite should never expire. Default is {@code 86400} (24 hours).
     * {@code null} will reset this to the default value.
     *
     * @param  maxAge
     *         The max age for this invite or {@code null} to use the default value.
     *
     * @throws IllegalArgumentException
     *         If maxAge is negative.
     *
     * @return The current InviteAction for chaining.
     */",net.dv8tion.jda.api.requests.restaction
"public List<ApplicationCommandInteractionOption> getOptions() {
        return data.options().toOptional().orElse(Collections.emptyList()).stream()
                .map(data -> new ApplicationCommandInteractionOption(gateway, data, guildId, resolved))
                .collect(Collectors.toList());
    }","/**
     * Gets the options, present if this option is a group or subcommand.
     *
     * @return The options, present if this option is a group or subcommand.
     */",discord4j.core.object.command
"public Scheduler getBlockingTaskScheduler() {
        return blockingTaskScheduler;
    }","/**
     * Get the {@link Scheduler} configured by this provider to be used in blocking tasks.
     *
     * @return a blocking-capable {@link Scheduler}
     */",discord4j.common
"public String asFormat() {
        return ReactionEmoji.Custom.custom(this).asFormat();
    }","/**
     * Gets the formatted version of this emoji (i.e., to display in the client).
     *
     * @return The formatted version of this emoji (i.e., to display in the client).
     */",discord4j.core.object.entity
String name();,"/**
   * The option name to be displayed in the menu.
   *
   * @return the name
   */",io.github.augustoravazoli.termenu.core
void setSelfDeafened(boolean deafened);,"/**
     * Sets whether connections from this AudioManager should be deafened.
     * <br>This does not include being muted, that value can be set individually from {@link #setSelfMuted(boolean)}
     * and checked via {@link #isSelfMuted()}
     *
     * @param deafened
     *        Whether connections from this AudioManager should be deafened.
     */",net.dv8tion.jda.api.managers
"@Nonnull
    @CheckReturnValue
    RoleManager givePermissions(@Nonnull Collection<Permission> perms);","/**
     * Adds the specified {@link net.dv8tion.jda.api.Permission Permissions} to the selected {@link net.dv8tion.jda.api.entities.Role Role}.
     *
     * <p>Permissions may only include already present Permissions for the currently logged in account.
     * <br>You are unable to give permissions you don't have!
     *
     * @param  perms
     *         The permission to give to the selected {@link net.dv8tion.jda.api.entities.Role Role}
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have permission to apply one of the specified permissions
     *
     * @return RoleManager for chaining convenience
     *
     * @see    #setPermissions(Collection)
     * @see    #setPermissions(Permission...)
     * @see    java.util.EnumSet EnumSet
     * @see    net.dv8tion.jda.api.Permission#getRaw(java.util.Collection) Permission.getRaw(Collection)
     */",net.dv8tion.jda.api.managers
"Mono<RoleData> onGuildRoleUpdate(int shardIndex, GuildRoleUpdate dispatch);","/**
     * Updates the internal state of the store according to the given {@link GuildRoleUpdate} gateway dispatch. This
     * will typically perform an update operation on a related {@link RoleData} that is already present in the store.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a {@link Mono} completing when the operation is done, optionally returning the old state of the
     * {@link RoleData} before the update
     */",discord4j.common.store.api.layout
"public Optional<ThreadMetadata> getThreadMetadata() {
        return data.threadMetadata().toOptional();
    }","/**
     * Gets the associated thread metadata, if the provided channel is a thread.
     *
     * @return Associated {@link ThreadMetadata}, if present.
     */",discord4j.core.object.command
"public Optional<String> getName() {
        return data.name().toOptional();
    }","/**
     * Gets the name of the invoked command.
     *
     * @return The name of the invoked command.
     */",discord4j.core.object.command
"@Nullable
    public String getIconUrl()
    {
        String iconId = getIconId();
        return iconId == null ? null : String.format(ICON_URL, roleId, iconId);
    }","/**
     * The URL of the {@link net.dv8tion.jda.api.entities.Role Role} icon image.
     * If no icon has been set or an emoji is used in its place, this returns {@code null}.
     * <p>The Role icon can be modified using {@link RoleManager#setIcon(Icon)}.
     *
     * @return Possibly-null String containing the Role's icon URL.
     *
     * @since  4.3.1
     */",net.dv8tion.jda.api.entities
"@Nonnull
    public List<ForumTag> getNewTags()
    {
        SortedSnowflakeCacheView<ForumTag> cache = getChannel().asThreadChannel().getParentChannel().asForumChannel().getAvailableTagCache();
        return getNewValue().stream()
                .map(cache::getElementById)
                .filter(Objects::nonNull)
                .sorted()
                .collect(Helpers.toUnmodifiableList());
    }","/**
     * The new list of applied tags.
     *
     * <p>This requires {@link net.dv8tion.jda.api.utils.cache.CacheFlag#FORUM_TAGS CacheFlag.FORUM_TAGS} to be enabled.
     *
     * @return The updated list of applied tags
     */",net.dv8tion.jda.api.events.channel.update
"public Scheduler getSendTaskScheduler() {
        return sendTaskScheduler;
    }","/**
     * Returns the {@link Scheduler} used to run the voice send loop.
     *
     * @return the send scheduler
     */",discord4j.voice
"public static ClientActivity custom(String name) {
        return of(Activity.Type.CUSTOM, ""Custom Status"", null, Objects.requireNonNull(name));
    }","/**
     * Creates a {@link Activity.Type#CUSTOM custom} activity.
     *
     * @param name the custom status used in this activity
     * @return a custom activity with the given ""state"" value
     */",discord4j.core.object.presence
"public long getThreadMemberIdLong()
    {
        return threadMemberId;
    }","/**
     * The id of the {@link ThreadMember}.
     *
     * @return Long containing the Id.
     */",net.dv8tion.jda.api.events.thread.member
"@Nonnull
    @CheckReturnValue
    ThreadChannelManager setArchived(boolean archived);","/**
     * Sets the archived state of this ThreadChannel.
     *
     * @param  archived
     *         The new archived state for the selected {@link ThreadChannel}
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account is not the thread owner or does not have the {@link net.dv8tion.jda.api.Permission#MANAGE_THREADS MANAGE_THREADS} permission.
     *         Or if the thread is locked (archived by a moderator) and the current account does not have the {@link net.dv8tion.jda.api.Permission#MANAGE_THREADS MANAGE_THREADS} permission.
     *
     * @return this ThreadChannelManager for chaining convenience
     *
     * @see ThreadChannel#isArchived()
     */",net.dv8tion.jda.api.managers.channel.concrete
"@Override
    public boolean equals(final Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj instanceof Pair<?, ?>) {
            final Pair<?, ?> other = (Pair<?, ?>) obj;
            return Objects.equals(getLeft(), other.getLeft())
                && Objects.equals(getRight(), other.getRight());
        }
        return false;
    }","/**
     * <p>Compares this pair to another based on the two elements.</p>
     *
     * @param obj  the object to compare to, null returns false
     * @return true if the elements of the pair are equal
     */",net.dv8tion.jda.internal.utils.tuple
"@Nonnull
    Webhook getWebhook();","/**
     * The target {@link net.dv8tion.jda.api.entities.Webhook Webhook}
     * that will be modified by this manager
     *
     * @return The target {@link net.dv8tion.jda.api.entities.Webhook Webhook}
     */",net.dv8tion.jda.api.managers
"public static final Route FOLLOW_NEWS_CHANNEL = Route.post(""/channels/{channel.id}/followers"");","/**
     * Follow a News Channel to send messages to a target channel. Requires the `MANAGE_WEBHOOKS` permission in the
     * target channel. Returns a followed channel object.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/channel#follow-news-channel"">
     * https://discord.com/developers/docs/resources/channel#follow-news-channel</a>
     */",discord4j.rest.route
"public LegacyMessageEditSpec addEmbed(Consumer<? super LegacyEmbedCreateSpec> spec) {
        final LegacyEmbedCreateSpec mutatedSpec = new LegacyEmbedCreateSpec();
        spec.accept(mutatedSpec);

        // if the Possible or the Optional is empty
        if (this.embeds.isAbsent() || !this.embeds.get().isPresent()) {
            this.embeds = Possible.of(Optional.of(new ArrayList<>(1)));
        }

        this.embeds.get().get().add(mutatedSpec.asRequest());
        return this;
    }","/**
     * Adds an embed to the edit request.
     * <p>
     * <b>Warning:</b> This method does <i>not</i> add an embed to the embeds already existing on the message. That is,
     * if a message has embeds A and B, editing it with {@code addEmbed(C)} will result in the message having <i>only</i>
     * embed C. To actually add embed C to the message, all embeds must be sent
     * (i.e., do {@code addEmbed(A).addEmbed(B).addEmbed(C)}.
     *
     * @param spec An {@link LegacyEmbedCreateSpec} consumer used to attach rich content when creating a message.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
    List<Entitlement> getEntitlements();","/**
     * Returns the list of {@link Entitlement entitlements} for the current guild and user.
     * <br>If this interaction is not from a guild, it will only contain entitlements of the user.
     *
     * @return The {@link List List} of {@link Entitlement Entitlement}
     */",net.dv8tion.jda.api.interactions
"public Publisher<?> onInviteDelete(InviteDeleteEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when an invite to a channel has expired.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"public static MessageCreateAction messageCreate(int shardIndex, MessageCreate dispatch) {
        return new MessageCreateAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link MessageCreate} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link MessageCreateAction}
     */",discord4j.common.store.action.gateway
"public Optional<Snowflake> getParentId() {
        return data.parentId().toOptional().map(Snowflake::of);
    }","/**
     * Gets the thread parent id, if the provided channel is a thread.
     *
     * @return The parent ID as a {@link Snowflake}, if present.
     */",discord4j.core.object.command
"public Instant getJoinTime() {
        return DateTimeFormatter.ISO_OFFSET_DATE_TIME.parse(data.joinedAt(), Instant::from);
    }","/**
     * Gets when the user joined the guild.
     *
     * @return When the user joined the guild.
     */",discord4j.core.object.command
"public static ChannelUpdateAction channelUpdate(int shardIndex, ChannelUpdate dispatch) {
        return new ChannelUpdateAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link ChannelUpdate} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link ChannelUpdateAction}
     */",discord4j.common.store.action.gateway
long getRuleIdLong();,"/**
     * The id of the {@link AutoModRule} which has been triggered.
     *
     * @return The id of the rule
     */",net.dv8tion.jda.api.entities.automod
"public static CountTotalAction countVoiceStates() {
        return new CountTotalAction(CountableEntity.VOICE_STATES);
    }","/**
     * Creates an action to count the number of voice states present in a store.
     *
     * @return a new {@link CountTotalAction}
     */",discord4j.common.store.action.read
"public GuildCreateFromTemplateMono createGuild(String name) {
        return GuildCreateFromTemplateMono.of(name, this);
    }","/**
     * Requests to create a new guild from this template. Properties specifying how to create a new guild from this
     * template can be set via the {@code withXxx} methods of the returned {@link GuildCreateFromTemplateMono}.
     *
     * @param name the name of the guild to create
     * @return A {@link GuildCreateFromTemplateMono} where, upon successful completion, emits the {@link Guild created
     * guild}. If an error is received, it is emitted through the {@code GuildCreateFromTemplateMono}.
     */",discord4j.core.object
"public StageChannel(final GatewayDiscordClient gateway, final ChannelData data) {
        super(gateway, data);
    }","/**
     * Constructs a {@code StageChannel} with an associated {@link GatewayDiscordClient} and Discord data.
     *
     * @param gateway The {@link GatewayDiscordClient} associated to this object, must be non-null.
     * @param data The raw data as represented by Discord, must be non-null.
     */",discord4j.core.object.entity.channel
"@Nonnull
    default Guild getGuild()
    {
        return getWebhook().getGuild();
    }","/**
     * The {@link net.dv8tion.jda.api.entities.Guild Guild} this Manager's
     * {@link net.dv8tion.jda.api.entities.Webhook Webhook} is in.
     * <br>This is logically the same as calling {@code getWebhook().getGuild()}
     *
     * @return The parent {@link net.dv8tion.jda.api.entities.Guild Guild}
     */",net.dv8tion.jda.api.managers
"@Nonnull
    @CheckReturnValue
    GuildManager setExplicitContentLevel(@Nonnull Guild.ExplicitContentLevel level);","/**
     * Sets the {@link net.dv8tion.jda.api.entities.Guild.ExplicitContentLevel Explicit Content Level} of this {@link net.dv8tion.jda.api.entities.Guild Guild}.
     *
     * @param  level
     *         The new MFA Level for this {@link net.dv8tion.jda.api.entities.Guild Guild}
     *
     * @throws IllegalArgumentException
     *         If the provided level is {@code null} or UNKNOWN
     *
     * @return GuildManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"public static CountTotalAction countEmojis() {
        return new CountTotalAction(CountableEntity.EMOJIS);
    }","/**
     * Creates an action to count the number of emojis present in a store.
     *
     * @return a new {@link CountTotalAction}
     */",discord4j.common.store.action.read
void attacheSensor(Sensor sensor);,"/**
     * Attache the {@link Sensor}.
     *
     * @param sensor
     *            the {@link Sensor}
     */",jestures.core.tracking
"@Nullable
    default VoiceChannel getVoiceChannelById(long id)
    {
        return (VoiceChannel) getChannelCache().getElementById(ChannelType.VOICE, id);
    }","/**
     * Gets a {@link VoiceChannel VoiceChannel} that has the same id as the one provided.
     * <br>If there is no channel with an id that matches the provided one, then this returns {@code null}.
     *
     * <p>This getter exists on any instance of {@link IGuildChannelContainer} and only checks the caches with the relevant scoping.
     * For {@link Guild}, {@link JDA}, or {@link ShardManager},
     * this returns the relevant channel with respect to the cache within each of those objects.
     * For a guild, this would mean it only returns channels within the same guild.
     * <br>If this is called on {@link JDA} or {@link ShardManager}, this may return null immediately after building, because the cache isn't initialized yet.
     * To make sure the cache is initialized after building your {@link JDA} instance, you can use {@link JDA#awaitReady()}.
     *
     * @param  id
     *         The id of the {@link VoiceChannel VoiceChannel}.
     *
     * @return Possibly-null {@link VoiceChannel VoiceChannel} with matching id.
     */",net.dv8tion.jda.api.entities.channel.attribute
"@Nonnull
    @CheckReturnValue
    ChannelAction<T> syncPermissionOverrides();","/**
     * Syncs the permission overrides of the channel with the category.
     *
     * <p>If setting permission overwrites, only permissions your bot has in the guild can be allowed/denied.
     * In order to properly sync permissions the currently logged in account must have all allowed/denied permissions or {@link Permission#MANAGE_ROLES} in the parent category.
     *
     * @throws IllegalArgumentException
     *         If no parent has been configured. You have to use {@link #setParent(Category)} before calling this method.
     *
     * @return The current ChannelAction, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
"@Nonnull
    public List<IntegrationPrivilege> getPrivileges()
    {
        return privileges;
    }","/**
     * The list of new {@link IntegrationPrivilege IntegrationPrivileges}.
     *
     * @return Unmodifiable list containing the new IntegrationPrivileges.
     */",net.dv8tion.jda.api.events.interaction.command
"public static boolean isRequestingEntireList(RequestGuildMembers request) {
        return request.query().toOptional().map(String::isEmpty).orElse(false) && request.limit() == 0;
    }","/**
     * Return whether the given {@link RequestGuildMembers} instance is requesting an entire guild's list of members.
     *
     * @param request the request to check
     * @return {@code true} if this request will attempt to retrieve the complete list of guild members, and {@code
     * false} otherwise
     */",discord4j.core.util
"@Nonnull
    public Timestamp minus(long millis)
    {
        return new Timestamp(format, timestamp - millis);
    }","/**
     * Creates a new timestamp instance with the provided offset into the past relative to the current timestamp.
     *
     * @param  millis
     *         The millisecond offset for the new timestamp
     *
     * @return Copy of this timestamp with the relative offset
     *
     * @see    #minus(Duration)
     */",net.dv8tion.jda.api.utils
"@Nullable
    default ForumChannel getForumChannelById(long id)
    {
        return (ForumChannel) getChannelCache().getElementById(ChannelType.FORUM, id);
    }","/**
     * Gets a {@link ForumChannel} that has the same id as the one provided.
     * <br>If there is no channel with an id that matches the provided one, then this returns {@code null}.
     *
     * <p>This getter exists on any instance of {@link IGuildChannelContainer} and only checks the caches with the relevant scoping.
     * For {@link Guild}, {@link JDA}, or {@link ShardManager},
     * this returns the relevant channel with respect to the cache within each of those objects.
     * For a guild, this would mean it only returns channels within the same guild.
     * <br>If this is called on {@link JDA} or {@link ShardManager}, this may return null immediately after building, because the cache isn't initialized yet.
     * To make sure the cache is initialized after building your {@link JDA} instance, you can use {@link JDA#awaitReady()}.
     *
     * @param  id
     *         The id of the {@link ForumChannel}.
     *
     * @return Possibly-null {@link ForumChannel} with matching id.
     */",net.dv8tion.jda.api.entities.channel.attribute
"Mono<PresenceData> getPresenceById(long guildId, long userId);","/**
     * Retrieves data for the presence corresponding to the given guild ID and user ID.
     *
     * @param guildId the guild ID
     * @param userId  the user ID
     * @return A {@link Mono} emitting the presence, or empty if not found
     */",discord4j.common.store.api.layout
"public long getNewOwnerIdLong()
    {
        return nextId;
    }","/**
     * The new owner user id
     *
     * @return The new owner id
     */",net.dv8tion.jda.api.events.guild.update
"@Nonnull
    default String getUserId()
    {
        return Long.toUnsignedString(getUserIdLong());
    }","/**
     * The id of the user that triggered this execution.
     *
     * @return The id of the user
     */",net.dv8tion.jda.api.entities.automod
"@Nonnull
    default String getId()
    {
        return Long.toUnsignedString(getIdLong());
    }","/**
     * The Snowflake id of this entity. This is unique to every entity and will never change.
     *
     * @return Never-null String containing the Id.
     */",net.dv8tion.jda.api.entities
"public static final Route GUILD_MEMBERS_LIST = Route.get(""/guilds/{guild.id}/members"");","/**
     * Returns a list of guild member objects that are members of the guild.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/guild#list-guild-members"">
     * https://discord.com/developers/docs/resources/guild#list-guild-members</a>
     */",discord4j.rest.route
"@Nonnull
    @CheckReturnValue
    public RestAction<User> retrieveUser()
    {
        User user = getUser();
        if (user != null)
            return new CompletedRestAction<>(getJDA(), user);
        return getJDA().retrieveUserById(getUserIdLong());
    }","/**
     * Retrieves the {@link User} who owns the reaction.
     * <br>If a user is known, this will return {@link #getUser()}.
     *
     * @return {@link RestAction} - Type: {@link User}
     *
     * @since  4.2.1
     */",net.dv8tion.jda.api.events.message.react
"public static VoiceReactorResources.Builder builder(ReactorResources reactorResources) {
        return builder()
                .httpClient(reactorResources.getHttpClient())
                .timerTaskScheduler(reactorResources.getTimerTaskScheduler())
                .blockingTaskScheduler(reactorResources.getBlockingTaskScheduler());
    }","/**
     * Returns a new builder to create {@link VoiceReactorResources} from a pre-configured {@link ReactorResources},
     * copying its settings.
     *
     * @return a builder to create {@link VoiceReactorResources} with settings copied from parent resources
     */",discord4j.voice
"public LegacyInviteCreateSpec setTargetType(Invite.Type targetType) {
        requestBuilder.targetType(targetType.getValue());
        return this;
    }","/**
     * Sets the type of target for this voice channel invite.
     *
     * @param targetType The type of target for this voice channel invite.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
    @CheckReturnValue
    GuildWelcomeScreenManager setWelcomeChannels(@Nonnull Collection<? extends GuildWelcomeScreen.Channel> channels);","/**
     * Sets the welcome channels of the welcome screen.
     *
     * <p>The order of the {@link Collection} defines in what order the channels appear on Discord.
     *
     * @param  channels
     *         The new welcome channels to use, can be an empty list to remove all welcome channels.
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If {@code channels} is {@code null}</li>
     *             <li>If more than {@value GuildWelcomeScreen#MAX_WELCOME_CHANNELS} welcome channels are set</li>
     *         </ul>
     *
     * @return GuildWelcomeScreenManager for chaining convenience
     *
     * @see    #setWelcomeChannels(GuildWelcomeScreen.Channel...)
     */",net.dv8tion.jda.api.managers
"void stopSensor() throws SensorException, IllegalSensorStateException;","/**
     * Stop the sensor with the default configuration setted in the constructor specific sensor.
     *
     * @throws SensorException
     *             if the sensor encurres in problems during stopping phase.
     *
     * @throws IllegalSensorStateException
     *             if sensor is started outside recognition
     */",jestures.sensor
"public static final Route GUILD_ROLE_CREATE = Route.post(""/guilds/{guild.id}/roles"");","/**
     * Create a new role for the guild. Requires the 'MANAGE_ROLES' permission. Returns the new role object on success.
     * Fires a Guild Role Create Gateway event. All JSON params are optional.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/guild#create-guild-role"">
     * https://discord.com/developers/docs/resources/guild#create-guild-role</a>
     */",discord4j.rest.route
"public Optional<ApplicationCommandInteractionResolved> getResolved() {
        return data.resolved().toOptional()
                .map(data -> new ApplicationCommandInteractionResolved(gateway, data, guildId));
    }","/**
     * Gets the converted users + roles + channels + attachments.
     *
     * @return The converted users + roles + channels + attachments.
     */",discord4j.core.object.command
"public static GuildCreateAction guildCreate(int shardIndex, GuildCreate dispatch) {
        return new GuildCreateAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link GuildCreate} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link GuildCreateAction}
     */",discord4j.common.store.action.gateway
"public List<ApplicationCommandPermission> getPermissions() {
        return data.permissions()
                .stream()
                .map(data -> new ApplicationCommandPermission(gateway, getGuildId(), data))
                .collect(Collectors.toList());
    }","/**
     * Returns the permissions for the command in the guild.
     *
     * @return the permissions for the command in the guild.
     */",discord4j.core.object.command
"public static long getLong(@Nonnull DataObject root, @Nonnull String path, long fallback)
    {
        Long longValue = get(root, path, (obj, key) -> obj.getLong(key, fallback), (arr, index) -> arr.getLong(index, fallback));
        return longValue == null ? fallback : longValue;
    }","/**
     * Parses the given {@code path} and finds the appropriate value within this {@link DataObject}.
     * <br>If the resulting value is a string, this will parse the string using {@link Long#parseLong(String)}.
     *
     * @param  root
     *         The root data object, which is the top level accessor.
     *         <br>The very first element in the path corresponds to a field of that name within this root object.
     * @param  path
     *         The path of the value, in accordance with the described grammar by {@link DataPath}.
     *         This must start with a name element, such as {@code ""foo""}.
     *
     * @throws ParsingException
     *         If the path is invalid or resolving fails due to missing elements
     * @throws IndexOutOfBoundsException
     *         If any of the elements in the path refer to an array index that is out of bounds
     * @throws IllegalArgumentException
     *         If null is provided or the path is empty
     *
     * @return The long value at the given path, returning the fallback if the path resolves to an optional value that is missing.
     */",net.dv8tion.jda.api.utils.data
"public static GuildScheduledEventUpdateAction guildScheduledEventUpdate(int shardIndex, GuildScheduledEventUpdate dispatch) {
        return new GuildScheduledEventUpdateAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link GuildScheduledEventUpdate} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link GuildScheduledEventUpdate}
     */",discord4j.common.store.action.gateway
"s getPosition() always returns -1.
     *
     * @throws IllegalStateException
     *         If this role is not in the guild cache
     *
     * @return The position of this {@link net.dv8tion.jda.api.entities.Role Role}",/** Used to keep consistency between color values used in the API */,net.dv8tion.jda.api.entities
"public List<Snowflake> getRoleIds() {
        return this.roleIds;
    }","/**
     * Gets the role IDs in which the option will add the user.
     *
     * @return The role IDs in which the option will add the user.
     */",discord4j.core.object.onboarding
Mono<Long> countChannels();,"/**
     * Counts the number of channels present in the store.
     *
     * @return A {@link Mono} emitting the channel count
     */",discord4j.common.store.api.layout
"public static CountTotalAction countMembers() {
        return new CountTotalAction(CountableEntity.MEMBERS);
    }","/**
     * Creates an action to count the number of members present in a store.
     *
     * @return a new {@link CountTotalAction}
     */",discord4j.common.store.action.read
"public RestRole getRoleById(final Snowflake guildId, final Snowflake roleId) {
        return RestRole.create(this, guildId, roleId);
    }","/**
     * Requests to retrieve the role represented by the supplied IDs.
     *
     * @param guildId The ID of the guild.
     * @param roleId The ID of the role.
     * @return A {@link RestRole} as represented by the supplied IDs.
     */",discord4j.rest
"public boolean isMuted()
    {
        return muted;
    }","/**
     * Whether the member was muted in this event.
     *
     * @return True, if the member was muted with this event
     *         <br>False, if the member was un-muted in this event
     */",net.dv8tion.jda.api.events.guild.voice
"public Snowflake getMessageAuthorId() {
        return Snowflake.of(messageAuthorId);
    }","/**
     * Gets the {@link Snowflake} ID of the {@link User} who sent the {@link Message} that was reacted to.
     * Note that this id will be 0 if the message was sent by a webhook.
     *
     * @return The ID of the {@link User} who sent the {@link Message} that was reacted to.
     */",discord4j.core.event.domain.message
"void setFaction(Faction faction, boolean alt);","/**
     * Sets the faction of the FPlayer
     *
     * @param faction faction to set.
     */",com.massivecraft.factions
"static EventDispatcher replayingWithTimeout(Duration maxAge) {
        return builder()
                .eventSink(spec -> spec.replay().limit(maxAge))
                .build();
    }","/**
     * Create an {@link EventDispatcher} that is time-bounded and retains all elements whose age is at most {@code
     * maxAge}, replaying them to late subscribers. Be aware that using this type of dispatcher with operators such
     * as {@link Flux#retry()} or {@link Flux#repeat()} that re-subscribe to the dispatcher will observe the same
     * elements as the backlog contains.
     *
     * @param maxAge the maximum age of the contained items
     * @return an {@link EventDispatcher} that will replay elements up to {@code maxAge} duration to late subscribers
     */",discord4j.core.event
"public int getGreen() {
        return (rgb >> 8) & 0xFF;
    }","/**
     * Returns the green value for this color, as an integer in the range 0-255.
     *
     * @return The green value for this color.
     */",discord4j.rest.util
"protected Upgrade(String upgradeName) {
        this.upgradeName = upgradeName;
        setupUpgrade();
    }","/**
     * Map representing each level cost
     */",com.massivecraft.factions.addon.upgradeaddon
"@Nonnull
    Set<String> getMentionedUsers();","/**
     * The IDs for users which are allowed to be mentioned, or an empty list.
     *
     * @return The user IDs which are mention whitelisted
     */",net.dv8tion.jda.api.utils.messages
"public static final Route MESSAGES_GET = Route.get(""/channels/{channel.id}/messages"");","/**
     * Returns the messages for a channel. If operating on a guild channel, this endpoint requires the 'READ_MESSAGES'
     * permission to be present on the current user. Returns an array of message objects on success.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/channel#get-channel-messages"">
     * https://discord.com/developers/docs/resources/channel#get-channel-messages</a>
     */",discord4j.rest.route
"public LegacyNewsChannelCreateSpec setParentId(@Nullable Snowflake parentId) {
        requestBuilder.parentId(parentId == null ? Possible.absent() : Possible.of(parentId.asString()));
        return this;
    }","/**
     * Sets the identifier of the parent category of the created {@link NewsChannel}.
     *
     * @param parentId The parent category identifier.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nullable
    public Role getRole()
    {
        return override.getRole();
    }","/**
     * The {@link Role} for the override.
     *
     * @return Possibly-null role
     */",net.dv8tion.jda.api.events.guild.override
"public CompletableFuture<Optional<UpdateResult>> updateDocument(final String collection, final String fieldName, final Object value, final Bson operation) {
        return getCollection(collection).thenApplyAsync(optionalMongoCollection -> optionalMongoCollection.map(mongoCollection -> mongoCollection.updateOne(Filters.eq(fieldName, value), operation)));
    }","/**
     * Updates a {@link Document} of a MongoCollection asynchronously
     * @param collection name of the collection
     * @param fieldName name of the field in the collection
     * @param value value of the given field in the collection
     * @param operation {@link Bson}
     * @return {@link UpdateResult} of the update
     */",io.github.heliumdioxid.database.mongo
void stop();,"/**
     * Stops the Kinect.
     */",jestures.sensor.kinect
long getCloudflare();,"/**
         * The current cloudflare rate-limit reset time.
         * <br>This is the rate-limit applied on the current IP.
         *
         * @return The timestamp when the cloudflare rate-limit expires (unix timestamp in milliseconds)
         */",net.dv8tion.jda.api.requests
"@Nonnull
    public ForumTag getTag()
    {
        return tag;
    }","/**
     * The {@link ForumTag} that was affected by this event
     *
     * @return The {@link ForumTag}
     */",net.dv8tion.jda.api.events.channel.forum
"public CompletableFuture<Optional<DeleteResult>> deleteDocument(final String collection, final String fieldName, final Object value) {
        return getCollection(collection).thenApplyAsync(optionalMongoCollection -> optionalMongoCollection.map(mongoCollection -> mongoCollection.deleteOne(Filters.eq(fieldName, value))));
    }","/**
     * Deletes a {@link Document} of a MongoCollection asynchronously
     * @param collection name of the collection
     * @param fieldName name of the field in the collection
     * @param value value of the given field in the collection
     * @return {@link DeleteResult} of the deletion
     */",io.github.heliumdioxid.database.mongo
"@Nonnull
    @CheckReturnValue
    GuildManager setSplash(@Nullable Icon splash);","/**
     * Sets the Splash {@link net.dv8tion.jda.api.entities.Icon Icon} of this {@link net.dv8tion.jda.api.entities.Guild Guild}.
     *
     * @param  splash
     *         The new splash for this {@link net.dv8tion.jda.api.entities.Guild Guild}
     *         or {@code null} to reset
     *
     * @throws java.lang.IllegalStateException
     *         If the guild's {@link net.dv8tion.jda.api.entities.Guild#getFeatures() features} do not include {@code INVITE_SPLASH}
     *
     * @return GuildManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"@Nonnull
    public static CommandData message(@Nonnull String name)
    {
        return new CommandDataImpl(Command.Type.MESSAGE, name);
    }","/**
     * Create a message context menu command builder.
     *
     * @param  name
     *         The command name, 1-32 characters
     *
     * @throws IllegalArgumentException
     *         If the name is not between 1-32 characters long
     *
     * @return {@link CommandData}
     */",net.dv8tion.jda.api.interactions.commands.build
Flux<Guild> getGuilds();,"/**
     * Requests to retrieve the guilds the current client is in.
     *
     * @return A {@link Flux} that continually emits the {@link Guild guilds} that the current client is in. If an error
     *         is received, it is emitted through the {@code Flux}.
     */",discord4j.core.retriever
void refreshUsers();,"/**
     * Load the Users.
     */",jestures.core.view
"@Nonnull
    @CheckReturnValue
    ChannelAction<T> setUserlimit(@Nullable Integer userlimit);","/**
     * Sets the userlimit for the new {@link AudioChannel}.
     * <br>The limit maximum varies by type.
     * <ul>
     *     <li>{@link ChannelType#VOICE} - {@value VoiceChannel#MAX_USERLIMIT}</li>
     *     <li>{@link ChannelType#STAGE} - {@value StageChannel#MAX_USERLIMIT}</li>
     * </ul>
     *
     * @param  userlimit
     *         The userlimit for the new AudioChannel or {@code null}/{@code 0} to use no limit
     *
     * @throws UnsupportedOperationException
     *         If this ChannelAction is not for a AudioChannel
     * @throws IllegalArgumentException
     *         If the provided userlimit is negative or above the permitted limit
     *
     * @return The current ChannelAction, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
"@Nonnull
    AutoModTriggerType getType();","/**
     * The type of trigger for this config.
     *
     * @return {@link AutoModTriggerType}
     */",net.dv8tion.jda.api.entities.automod.build
"@Nonnull
        @CheckReturnValue
        public CompiledRoute withQueryParams(@Nonnull String... params)
        {
            Checks.notNull(params, ""Params"");
            Checks.check(params.length >= 2, ""Params length must be at least 2"");
            Checks.check((params.length & 1) == 0, ""Params length must be a multiple of 2"");

            List<String> newQuery;
            if (query == null)
            {
                newQuery = new ArrayList<>(params.length / 2);
            }
            else
            {
                newQuery = new ArrayList<>(query.size() + params.length / 2);
                newQuery.addAll(query);
            }

            // Assuming names don't need encoding
            for (int i = 0; i < params.length; i += 2)
            {
                Checks.notEmpty(params[i], ""Query key ["" + i/2 + ""]"");
                Checks.notNull(params[i + 1], ""Query value ["" + i/2 + ""]"");
                newQuery.add(params[i] + '=' + EncodingUtil.encodeUTF8(params[i + 1]));
            }

            return new CompiledRoute(this, newQuery);
        }","/**
         * Returns a copy of this CompiledRoute with the provided parameters added as query.
         * <br>This will use <a href=""https://en.wikipedia.org/wiki/Percent-encoding"" target=""_blank"">percent-encoding</a>
         * for all provided <em>values</em> but not for the keys.
         *
         * <p><b>Example Usage</b><br>
         * <pre>{@code
         * Route.CompiledRoute history = Route.GET_MESSAGE_HISTORY.compile(channelId);
         *
         * // returns a new route
         * route = history.withQueryParams(
         *   ""limit"", 100
         * );
         * // adds another parameter ontop of limit
         * route = route.withQueryParams(
         *   ""after"", messageId
         * );
         *
         * // now the route has both limit and after, you can also do this in one call:
         * route = history.withQueryParams(
         *   ""limit"", 100,
         *   ""after"", messageId
         * );
         * }</pre>
         *
         * @param  params
         *         The parameters to add as query, alternating key and value (see example)
         *
         * @throws IllegalArgumentException
         *         If the number of arguments is not even or null is provided
         *
         * @return A copy of this CompiledRoute with the provided parameters added as query
         */",net.dv8tion.jda.api.requests
"public Optional<NewsChannel> getOld() {
        return Optional.ofNullable(old);
    }","/**
     * Gets the old version of the {@link NewsChannel} that was updated in this event, if present.
     * This may not be available if {@code NewsChannels} are not stored.
     *
     * @return The old version of the updated {@link NewsChannel}, if present.
     */",discord4j.core.event.domain.channel
"public static final Route CHANNEL_GET = Route.get(""/channels/{channel.id}"");","/**
     * Get a channel by ID. Returns a guild channel or dm channel object.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/channel#get-channel"">
     * https://discord.com/developers/docs/resources/channel#get-channel</a>
     */",discord4j.rest.route
"@Nonnull
    public static DataObject getObject(@Nonnull DataArray root, @Nonnull String path)
    {
        DataObject obj = optObject(root, path);
        if (obj == null)
            pathError(path, ""Object"");
        return obj;
    }","/**
     * Parses the given {@code path} and finds the appropriate value within this {@link DataArray}.
     *
     * @param  root
     *         The root data array, which is the top level accessor.
     *         <br>The very first element in the path corresponds to a field of that name within this root object.
     * @param  path
     *         The path of the value, in accordance with the described grammar by {@link DataPath}.
     *         This must start with an index element, such as {@code ""[0]""}.
     *
     * @throws ParsingException
     *         If the path is invalid or resolving fails due to missing elements
     * @throws IndexOutOfBoundsException
     *         If any of the elements in the path refer to an array index that is out of bounds
     * @throws IllegalArgumentException
     *         If null is provided or the path is empty
     *
     * @return The DataObject at the given path
     */",net.dv8tion.jda.api.utils.data
"@Nonnull
    static Button of(@Nonnull ButtonStyle style, @Nonnull String idOrUrl, @Nonnull Emoji emoji)
    {
        Checks.check(style != ButtonStyle.UNKNOWN, ""Cannot make button with unknown style!"");
        Checks.notNull(style, ""Style"");
        Checks.notNull(emoji, ""Emoji"");
        if (style == ButtonStyle.LINK)
            return link(idOrUrl, emoji);
        Checks.notEmpty(idOrUrl, ""Id"");
        Checks.notLonger(idOrUrl, ID_MAX_LENGTH, ""Id"");
        return new ButtonImpl(idOrUrl, """", style, false, emoji);
    }","/**
     * Create a button with the provided {@link ButtonStyle style}, URL or ID, and {@link Emoji}.
     * <br>The button is enabled and has no text label.
     * To use labels you can use {@code of(style, idOrUrl, label).withEmoji(emoji)}
     *
     * <p>See {@link #link(String, Emoji)} or {@link #primary(String, Emoji)} for more details.
     *
     * @param  style
     *         The button style
     * @param  idOrUrl
     *         Either the ID or URL for this button
     * @param  emoji
     *         The emoji to use as the button label
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If any provided argument is null or empty.</li>
     *             <li>If the id is longer than {@value #ID_MAX_LENGTH}, as defined by {@link #ID_MAX_LENGTH}.</li>
     *             <li>If the url is longer than {@value #URL_MAX_LENGTH}, as defined by {@link #URL_MAX_LENGTH}.</li>
     *         </ul>
     *
     * @return The button instance
     */",net.dv8tion.jda.api.interactions.components.buttons
"public static RestUser create(RestClient restClient, Snowflake id) {
        return new RestUser(restClient, id.asLong());
    }","/**
     * Create a {@link RestUser} for a given ID. This method does not perform any API request.
     *
     * @param restClient the client to make API requests
     * @param id the ID of this entity
     * @return a {@code RestUser} represented by this {@code id}.
     */",discord4j.rest.entity
"the null case is handled with an exception
    public static byte[] getAudioData(@Nonnull short[] decoded, double volume)
    {
        if (decoded == null)
            throw new IllegalArgumentException(""Cannot get audio data from null"");
        int byteIndex = 0;
        byte[] audio = new byte[decoded.length * 2];
        for (short s : decoded)
        {
            if (volume != 1.0)
                s = (short) (s * volume);

            byte leftByte  = (byte) ((s >>> 8) & 0xFF);
            byte rightByte = (byte)  (s        & 0xFF);
            audio[byteIndex] = leftByte;
            audio[byteIndex + 1] = rightByte;
            byteIndex += 2;
        }
        return audio;
    }","/**
     * Decodes and adjusts the opus audio for the specified volume.
     * <br>The provided volume should be a double precision floating point in the interval from 0 to 1.
     * In this case 0.5 would represent 50% volume for instance.
     *
     * @param  decoded
     *         The decoded audio data
     * @param  volume
     *         The volume
     *
     * @throws java.lang.IllegalArgumentException
     *         If {@code decoded} is null
     *
     * @return The stereo PCM audio data as specified by {@link net.dv8tion.jda.api.audio.AudioReceiveHandler#OUTPUT_FORMAT}.
     */",net.dv8tion.jda.api.audio
MilenageBuffer<T> encrypt(Cipher cipher);,"/**
     * Encrypts this buffer with given {@link javax.crypto.Cipher} object
     *
     * @param cipher {@link javax.crypto.Cipher} object
     * @return New result {@link threegpp.milenage.MilenageBuffer} object
     */",threegpp.milenage
"@Nonnull
    @CheckReturnValue
    default R mentionUsers(@Nonnull String... userIds)
    {
        Checks.notNull(userIds, ""User IDs"");
        return mentionUsers(Arrays.asList(userIds));
    }","/**
     * Used to provide a whitelist of {@link net.dv8tion.jda.api.entities.User Users} that should be pinged,
     * even when they would not be pinged otherwise according to the Set of allowed mention types.
     *
     * <p><b>Note:</b> When a User is whitelisted this way, then parsing of User mentions is automatically disabled.
     * <br>Also note that whitelisting users or roles implicitly disables parsing of other mentions, if not otherwise set via
     * {@link #setDefaultMentions(Collection)} or {@link #setAllowedMentions(Collection)}.
     *
     * @param  userIds
     *         Ids of Users that should be explicitly whitelisted to be pingable.
     *
     * @throws IllegalArgumentException
     *         If null is provided
     *
     * @return The same instance for chaining
     *
     * @see    #setAllowedMentions(Collection)
     * @see    #setDefaultMentions(Collection)
     */",net.dv8tion.jda.api.utils.messages
"@Nonnull
    public Timestamp plus(long millis)
    {
        return new Timestamp(format, timestamp + millis);
    }","/**
     * Creates a new timestamp instance with the provided offset into the future relative to the current timestamp.
     *
     * @param  millis
     *         The millisecond offset for the new timestamp
     *
     * @return Copy of this timestamp with the relative offset
     *
     * @see    #plus(Duration)
     */",net.dv8tion.jda.api.utils
"public StoreChannelEditMono edit() {
        return StoreChannelEditMono.of(this);
    }","/**
     * Requests to edit this store channel. Properties specifying how to edit this store channel can be set via the
     * {@code withXxx} methods of the returned {@link StoreChannelEditMono}.
     *
     * @return A {@link StoreChannelEditMono} where, upon successful completion, emits the edited {@link StoreChannel}.
     * If an error is received, it is emitted through the {@code StoreChannelEditMono}.
     */",discord4j.core.object.entity.channel
"public int getNewMaxMembers()
    {
        return getNewValue();
    }","/**
     * The new max members for this guild
     *
     * @return The new max members for this guild
     */",net.dv8tion.jda.api.events.guild.update
"@Override
        public long getIdLong()
        {
            return id;
        }","/**
         * The ids of roles are their position as stored by Discord so this will not look like a typical snowflake.
         *
         * @return The id for the role this override is for
         */",net.dv8tion.jda.api.entities.templates
"public User getResolvedUser() {
        return getInteraction().getCommandInteraction()
                .flatMap(ApplicationCommandInteraction::getResolved)
                .flatMap(it -> it.getUser(getTargetId()))
                .orElseThrow(IllegalStateException::new);
    }","/**
     * Gets the resolved targeted User.
     *
     * @return The resolved targeted User.
     */",discord4j.core.event.domain.interaction
Queue<Vector2D> extractFeatureVector();,"/**
     * Get the feature vector.
     *
     * @return the {@link Queue} feature vector
     */",jestures.core.codification
"public Optional<String> getNewAvatar() {
        return Possible.flatOpt(user.avatar());
    }","/**
     * Gets the {@link User}'s new avatar, if present. This may not exist if the {@code User}'s discriminator has not
     * been changed.
     *
     * @return The user's new avatar, if present.
     */",discord4j.core.event.domain
"Map<String, Object> map = ExTermDecoder.unpackMap(ByteBuffer.wrap(data));","/**
     * Parses using {@link ExTermDecoder}.
     * The provided data must start with the correct version header (131).
     *
     * @param  data
     *         The data to decode
     *
     * @throws IllegalArgumentException
     *         If the provided data is null
     * @throws net.dv8tion.jda.api.exceptions.ParsingException
     *         If the provided ETF payload is incorrectly formatted or an I/O error occurred
     *
     * @return A DataObject instance for the provided payload
     *
     * @since  4.2.1
     */",net.dv8tion.jda.api.utils.data
"@Nullable
    Activity getActivity();","/**
     * The current Activity for this session.
     * <br>This might not be what the Discord Client displays due to session clashing!
     *
     * @return The {@link net.dv8tion.jda.api.entities.Activity Activity}
     *         of the current session or null if no activity is set
     */",net.dv8tion.jda.api.managers
"public LegacyGuildEditSpec setVerificationLevel(Guild.VerificationLevel verificationLevel) {
        requestBuilder.verificationLevelOrNull(verificationLevel.getValue());
        return this;
    }","/**
     * Sets the verification level required before a member can send messages in the modified {@link Guild}.
     *
     * @param verificationLevel The verification level for the guild.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public static final Route GUILD_TEMPLATE_MODIFY = Route.patch(""/guilds/{guild.id}/templates/{template.code}"");","/**
     * Modifies the template's metadata. Requires the MANAGE_GUILD permission. Returns the template object on success.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/template#modify-guild-template"">
     *         https://discord.com/developers/docs/resources/template#modify-guild-template</a>
     */",discord4j.rest.route
"public LegacyGuildEditSpec setAfkChannelId(@Nullable Snowflake afkChannelId) {
        requestBuilder.afkChannelId(Possible.of(Optional.ofNullable(afkChannelId).map(Snowflake::asString)));
        return this;
    }","/**
     * Sets the {@link Snowflake} identifier for the channel designated as AFK channel in this {@link Guild}.
     *
     * @param afkChannelId The identifier for the AFK channel.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
    @CheckReturnValue
    default RoleManager setIcon(@Nullable UnicodeEmoji emoji)
    {
        return setIcon(emoji == null ? null : emoji.getFormatted());
    }","/**
     * Sets the Unicode Emoji of this {@link net.dv8tion.jda.api.entities.Role Role} instead of a custom image.
     *
     * @param  emoji
     *         The new Unicode Emoji for this {@link net.dv8tion.jda.api.entities.Role Role}
     *         or {@code null} to reset
     *
     * @return RoleManager for chaining convenience
     *
     * @see    net.dv8tion.jda.api.entities.emoji.Emoji#fromUnicode(String) Emoji.fromUnicode(String)
     * @see    UnicodeEmoji
     */",net.dv8tion.jda.api.managers
"@Nonnull
    public Guild.MFALevel getNewMFALevel()
    {
        return getNewValue();
    }","/**
     * The new {@link net.dv8tion.jda.api.entities.Guild.MFALevel MFALevel}
     *
     * @return The new MFALevel
     */",net.dv8tion.jda.api.events.guild.update
"public MySQLConnectionConfig(final ConnectionData connectionData) {
        this.hikariConfig = new HikariConfig();
        this.connectionData = connectionData;
    }","/**
     * Creates a new instance of the MySQLConnectionConfig containing a {@link HikariConfig}
     * @param connectionData {@link ConnectionData} information for database-connection
     */",io.github.heliumdioxid.database.mysql.config
"public ActionMapper build() {
            return new ActionMapper(mappings);
        }","/**
         * Builds an {@link ActionMapper} with all declared mappings.
         *
         * @return a new {@link ActionMapper}
         */",discord4j.common.store.api
"@Nonnull
    public List<Role> getRoles()
    {
        return addedRoles;
    }","/**
     * The list of roles that were added
     *
     * @return The list of roles that were added
     */",net.dv8tion.jda.api.events.guild.member
"@Nonnull
    default EntitlementPaginationAction guild(@Nonnull Guild guild)
    {
        Checks.notNull(guild, ""guild"");
        return guild(guild.getIdLong());
    }","/**
     * Filters {@link Entitlement Entitlement}s by a {@link Guild Guild}
     *
     * @param guild
     *        The {@link Guild Guild} to filter by
     *
     * @throws java.lang.IllegalArgumentException
     *         If the provided {@code guild} is {@code null}
     *
     * @return The current {@link EntitlementPaginationAction EntitlementPaginationAction} for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction.pagination
"@Nullable
    public String getNewIconId()
    {
        return getNewValue();
    }","/**
     * The old icon id
     *
     * @return The old icon id, or null
     */",net.dv8tion.jda.api.events.guild.update
Mono<Long> countMembers();,"/**
     * Counts the number of members present in the store.
     *
     * @return A {@link Mono} emitting the member count
     */",discord4j.common.store.api.layout
"@Nonnull
    public String getApplicationId()
    {
        return Long.toUnsignedString(applicationId);
    }","/**
     * The id of the application of which privileges have been changed.
     *
     * @return id of the application of which privileges have been changed.
     */",net.dv8tion.jda.api.events.interaction.command
"default boolean includeUserInCombinedAudio(@Nonnull User user)
    {
        return true;
    }","/**
     * This method is a filter predicate used by JDA to determine whether or not to include a
     * {@link net.dv8tion.jda.api.entities.User User}'s audio when creating a CombinedAudio packet.
     * <p>
     * This method is especially useful in creating whitelist / blacklist functionality for receiving audio.
     * <p>
     * A few possible examples:
     * <ul>
     *  <li>Have this method always return false for Users that are bots.</li>
     *  <li>Have this method return false for users who have been placed on a blacklist for abusing the bot's functionality.</li>
     *  <li>Have this method only return true if the user is in a special whitelist of power users.</li>
     * </ul>
     * @param  user
     *         The user whose audio was received
     *
     * @return If true, JDA will include the user's audio when merging audio sources when created packets
     *         for {@link #handleCombinedAudio(CombinedAudio)}
     */",net.dv8tion.jda.api.audio
"@Nonnull
    @CheckReturnValue
    default AutoCompleteCallbackAction addChoiceStrings(@Nonnull String... choices)
    {
        return addChoices(Arrays.stream(choices)
                .map(it -> new Command.Choice(it, it))
                .collect(Collectors.toList()));
    }","/**
     * Add up to {@value OptionData#MAX_CHOICES} choices which can be picked from by the user.
     * <br>The user may continue writing inputs instead of using one of your choices.
     *
     * <p>The provided strings will be used as value and name for the {@link net.dv8tion.jda.api.interactions.commands.Command.Choice Choices}.
     *
     * @param  choices
     *         The choice suggestions to present to the user, each limited to {@value OptionData#MAX_CHOICE_NAME_LENGTH} characters
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If {@code null} is provided</li>
     *             <li>If more than {@value OptionData#MAX_CHOICES} choices are added</li>
     *             <li>If any of the choice names are empty or longer than {@value OptionData#MAX_CHOICE_NAME_LENGTH}</li>
     *             <li>If the string value of any of the choices is empty or longer than {@value OptionData#MAX_CHOICE_VALUE_LENGTH}</li>
     *         </ul>
     *
     * @return The same callback action, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction.interactions
"@Nullable
    public RoleIcon getOldIcon()
    {
        return getOldValue();
    }","/**
     * The old icon
     *
     * @return The old icon
     */",net.dv8tion.jda.api.events.role.update
"public static Function<GatewayDiscordClient, Mono<Void>> shutdownDestroyHandler() {
        return gateway -> {
            gateway.getEventDispatcher().shutdown();
            return Mono.empty();
        };
    }","/**
     * Destroy handler that calls {@link EventDispatcher#shutdown()} asynchronously.
     *
     * @return a shutdown destroy handler
     */",discord4j.core.shard
"public LegacyEmbedCreateSpec addField(String name, String value, boolean inline) {
        this.fields.add(EmbedFieldData.builder()
                .name(name)
                .value(value)
                .inline(inline)
                .build());
        return this;
    }","/**
     * Adds a field to the embed.
     *
     * @param name The name of the field.
     * @param value The text inside of the field.
     * @param inline Whether to inline the field or not.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
    Task<T> setTimeout(@Nonnull Duration timeout);","/**
     * Change the timeout duration for this task.
     * <br>This may be ignored for certain operations.
     *
     * <p>The provided timeout is relative to the start time of the task.
     * If the time has already passed, this will immediately cancel the task.
     *
     * @param  timeout
     *         The new timeout duration
     *
     * @throws IllegalArgumentException
     *         If null is provided or the timeout is not positive
     *
     * @return The current Task instance for chaining
     */",net.dv8tion.jda.api.utils.concurrent
"@Nonnull
    static StickerSnowflake fromId(long id)
    {
        return new StickerSnowflakeImpl(id);
    }","/**
     * Creates a sticker snowflake instance which only wraps an ID.
     *
     * <p>This is primarily used for message sending purposes.
     *
     * @param  id
     *         The sticker id
     *
     * @return A sticker snowflake instance
     *
     * @see    JDA#retrieveSticker(StickerSnowflake)
     */",net.dv8tion.jda.api.entities.sticker
void deleteFeatureVectorInLIstView(int indexClicked);,"/**
     * Delete the selected elem from the listView.
     *
     * @param indexClicked
     *            the index clicked
     */",recorder.view
"@Nullable
    public OffsetDateTime getOldTimeOutEnd()
    {
        return getOldValue();
    }","/**
     * The old end of the time out
     *
     * @return The old end of the time out
     */",net.dv8tion.jda.api.events.guild.member.update
"boolean hasPermission(@Nonnull GuildChannel channel, @Nonnull Collection<Permission> permissions);","/**
     * Checks whether or not this PermissionHolder has the {@link net.dv8tion.jda.api.Permission Permissions} in the provided
     * {@code Collection<Permission>} in the specified GuildChannel.
     *
     * @param  channel
     *         The {@link GuildChannel GuildChannel} in which to check.
     * @param  permissions
     *         Permissions to check for.
     *
     * @throws IllegalArgumentException
     *         If null is provided
     *
     * @return True, if all of the specified Permissions are granted to this PermissionHolder in the provided GuildChannel.
     */",net.dv8tion.jda.api.entities
s AuditLogs (up to {@value #MAX_REASON_LENGTH},"/**
     * The maximum length of an audit-log reason
     */",net.dv8tion.jda.api.requests.restaction
"default boolean canReceiveUser()
    {
        return false;
    }","/**
     * If this method returns true, then JDA will provide audio data to the {@link #handleUserAudio(UserAudio)} method.
     *
     * @return If true, JDA enables subsystems to provide user specific audio data.
     */",net.dv8tion.jda.api.audio
"@Nonnull
    @CheckReturnValue
    RestAction<Void> removeReactionById(@Nonnull String messageId, @Nonnull Emoji emoji, @Nonnull User user);","/**
     * Attempts to remove the reaction from a message represented by the specified {@code messageId}
     * in this MessageChannel.
     *
     * <p>The following {@link net.dv8tion.jda.api.requests.ErrorResponse ErrorResponses} are possible:
     * <ul>
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS}
     *     <br>The request was attempted after the account lost access to the
     *         {@link net.dv8tion.jda.api.entities.Guild Guild}
     *         typically due to being kicked or removed, or after {@link net.dv8tion.jda.api.Permission#VIEW_CHANNEL Permission.VIEW_CHANNEL}
     *         was revoked in the {@link TextChannel TextChannel}
     *     <br>Also can happen if the account lost the {@link net.dv8tion.jda.api.Permission#MESSAGE_HISTORY Permission.MESSAGE_HISTORY}</li>
     *
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS}
     *     <br>The request was attempted after the account lost
     *         {@link net.dv8tion.jda.api.Permission#MESSAGE_ADD_REACTION Permission.MESSAGE_ADD_REACTION} in the
     *         {@link TextChannel TextChannel}.</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_EMOJI}
     *     <br>The provided unicode character does not refer to a known emoji unicode character.
     *     <br>Proper unicode characters for emojis can be found here:
     *         <a href=""https://unicode.org/emoji/charts/full-emoji-list.html"" target=""_blank"">Emoji Table</a></li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_MESSAGE UNKNOWN_MESSAGE}
     *     <br>The provided {@code messageId} is unknown in this MessageChannel, either due to the id being invalid, or
     *         the message it referred to has already been deleted.</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_CHANNEL UNKNOWN_CHANNEL}
     *     <br>The request was attempted after the channel was deleted.</li>
     * </ul>
     *
     * @param  messageId
     *         The messageId to remove the reaction from
     * @param  emoji
     *         The emoji to remove
     * @param  user
     *         The target user of which to remove from
     *
     * @throws java.lang.IllegalArgumentException
     *         <ul>
     *             <li>If provided {@code messageId} is {@code null} or empty.</li>
     *             <li>If provided {@code emoji} is {@code null}.</li>
     *         </ul>
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have
     *         {@link net.dv8tion.jda.api.Permission#MESSAGE_MANAGE Permission.MESSAGE_MANAGE} in this channel.
     *
     * @return {@link net.dv8tion.jda.api.requests.RestAction}
     */",net.dv8tion.jda.api.entities.channel.middleman
"@Nonnull
    public List<ForumTag> getOldTags()
    {
        SortedSnowflakeCacheView<ForumTag> cache = getChannel().asThreadChannel().getParentChannel().asForumChannel().getAvailableTagCache();
        return getOldValue().stream()
                .map(cache::getElementById)
                .filter(Objects::nonNull)
                .sorted()
                .collect(Helpers.toUnmodifiableList());
    }","/**
     * The old list of applied tags.
     *
     * <p>This requires {@link net.dv8tion.jda.api.utils.cache.CacheFlag#FORUM_TAGS CacheFlag.FORUM_TAGS} to be enabled.
     *
     * @return The previous list of applied tags
     */",net.dv8tion.jda.api.events.channel.update
Member member = event.getMember();,"/**
     * Handle command without arguments.
     *
     * @param event
     *        The event for this command
     */",
"public ClientActivity withState(String state) {
        return new ClientActivity(ActivityUpdateRequest.builder()
                .from(activityUpdateRequest)
                .state(state)
                .build());
    }","/**
     * Create a new {@link ClientActivity} from this one by including the given ""state"" field value. For activity types
     * other than {@link Activity.Type#CUSTOM}, it will be shown as additional data under an activity's name.
     *
     * @param state the custom status or additional data to include under an activity
     * @return a new client activity based on this one with the given state value
     */",discord4j.core.object.presence
"public static Snowflake of(final String id) {
        return new Snowflake(Long.parseUnsignedLong(id));
    }","/**
     * Constructs a {@code Snowflake} utilizing an <i>unsigned</i> ID.
     *
     * @param id The <i>unsigned</i> ID to construct a {@code Snowflake}. Must be non-null.
     * @return A constructed {@code Snowflake} with the <i>unsigned</i> ID.
     * @throws NumberFormatException If {@code id} is not an <i>unsigned</i> ID.
     */",discord4j.common.util
"public GatewayDiscordClient getClient() {
        return gateway;
    }","/**
     * Get the {@link GatewayDiscordClient} that emitted this {@link Event}.
     *
     * @return The client emitting this event.
     */",discord4j.core.event.domain
"public static ActionMapper empty() {
        return EMPTY;
    }","/**
     * Returns an {@link ActionMapper} containing no mappings.
     *
     * @return an empty {@link ActionMapper}
     */",discord4j.common.store.api
"public Mono<MessageData> edit(MessageEditRequest request) {
        return restClient.getChannelService().editMessage(channelId, id, MultipartRequest.ofRequest(request));
    }","/**
     * Requests to edit this message.
     *
     * @param request The request body used to create a new message.
     * @return A {@link Mono} where, upon successful completion, emits the edited {@link MessageData}. If an error is
     * received, it is emitted through the {@code Mono}.
     * @see <a href=""https://discord.com/developers/docs/resources/channel#edit-message"">Edit Message</a>
     */",discord4j.rest.entity
"@Nonnull
    @CheckReturnValue
    ActionComponent withDisabled(boolean disabled);","/**
     * Returns a copy of this component with {@link #isDisabled()} set to the provided value.
     *
     * @param  disabled
     *         True, if this component should be disabled
     *
     * @throws UnsupportedOperationException
     *         If this component type cannot be disabled
     *
     * @return New enabled/disabled component instance
     */",net.dv8tion.jda.api.interactions.components
"default Mono<Message> getMessageById(Snowflake id, EntityRetrievalStrategy retrievalStrategy) {
        return getClient().withRetrievalStrategy(retrievalStrategy).getMessageById(getId(), id);
    }","/**
     * Requests to retrieve the message as represented by the supplied ID, using the given retrieval strategy.
     *
     * @param id                The ID of the message.
     * @param retrievalStrategy the strategy to use to get the message
     * @return A {@link Mono} where, upon successful completion, emits the {@link Message} as represented by the
     * supplied ID. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.object.entity.channel
"@Nullable
    public Long getPermissionsRaw()
    {
        return permissions;
    }","/**
     * Raw permission integer representing the default permissions of a command.
     * <br>This returns null if it is of type {@link DefaultMemberPermissions#ENABLED ENABLED}
     * <br>If the default member permissions are {@link DefaultMemberPermissions#DISABLED DISABLED}, this returns 0
     *
     * @return Raw permission integer representing the default member permissions of a command
     */",net.dv8tion.jda.api.interactions.commands
"public List<ApplicationCommandPermission> getPermissions() {
        return permissions.getPermissions();
    }","/**
     * Returns the permissions for the command in the guild.
     *
     * @return the permissions for the command in the guild.
     */",discord4j.core.event.domain.command
"@Nonnull
    @CheckReturnValue
    GuildManager setName(@Nonnull String name);","/**
     * Sets the name of this {@link net.dv8tion.jda.api.entities.Guild Guild}.
     *
     * @param  name
     *         The new name for this {@link net.dv8tion.jda.api.entities.Guild Guild}
     *
     * @throws IllegalArgumentException
     *         If the provided name is {@code null} or not between 2-100 characters long
     *
     * @return GuildManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"public static final Route GUILD_ROLE_POSITIONS_MODIFY = Route.patch(""/guilds/{guild.id}/roles"");","/**
     * Modify the positions of a set of role objects for the guild. Requires the 'MANAGE_ROLES' permission. Returns a
     * list of all of the guild's role objects on success. Fires multiple Guild Role Update Gateway events.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/guild#modify-guild-role-positions"">
     * https://discord.com/developers/docs/resources/guild#modify-guild-role-positions</a>
     */",discord4j.rest.route
"@Nonnull
        public String getCompiledRoute()
        {
            if (query == null)
                return compiledRoute;
            // Append query to url
            return compiledRoute + '?' + String.join(""&"", query);
        }","/**
         * The compiled route string of the endpoint,
         * including all arguments and query parameters.
         *
         * @return The compiled route string of the endpoint
         */",net.dv8tion.jda.api.requests
"public static void showSnackBar(final Pane snackBarContainer, final String message,
            final NotificationType.Duration secondsDuration, final DimDialogs textSize,
            final EventHandler<ActionEvent> event) {
        final JFXSnackbar bar = new JFXSnackbar(snackBarContainer);
        final SnackbarEvent eventToast = new SnackbarEvent(message, null, (long) secondsDuration.getValue() * 1000,
                false, event);
        bar.enqueue(eventToast);
    }","/**
     * Create a {@link JFXSnackbar}.
     *
     * @param snackBarContainer
     *            the {@link Pane} container
     * @param message
     *            the {@link String} message
     * @param secondsDuration
     *            duration
     * @param textSize
     *            the {@link DimDialogs} size
     * @param event
     *            the {@link ActionEvent}
     */",jestures.core.view.utils
"public InteractionReplyEditMono editReply() {
        return InteractionReplyEditMono.of(this);
    }","/**
     * Edits the initial reply sent when accepting this interaction. Properties specifying how to build the edit message
     * request can be set via the {@code withXxx} methods of the returned {@link InteractionReplyEditMono}.
     * <p>
     * For component interactions, like buttons or select menus, this method modifies the message depending on the
     * initial response method chosen: if {@link #deferReply()} or {@link #reply()} was used, the <strong>new</strong>
     * message created with the reply; if {@link ComponentInteractionEvent#edit()} or
     * {@link ComponentInteractionEvent#deferEdit()} was used, this method will modify the message the component is on.
     * <p>
     * By default, this method will append any file added through {@code withFiles}. To replace or remove individual
     * attachments, use {@code withAttachments} along with {@link discord4j.core.object.entity.Attachment} objects from
     * the original message you want to keep. It is not required to include the new files as {@code Attachment} objects.
     * <p>
     * For example, to replace all previous attachments, provide an empty {@code withAttachments} and your files:
     * <pre>{@code
     *  event.editReply()
     *     .withContentOrNull(""Replaced all attachments"")
     *     .withFiles(getFile())
     *     .withComponents(row)
     *     .withAttachments();
     * }</pre>
     * <p>
     * To replace a specific attachment, you need to pass the attachment details you want to keep. You could work from
     * the original {@link Message#getAttachments()} list and pass it to {@code withAttachments} and your files.
     * The following example removes only the first attachment:
     * <pre>{@code
     *  event.getReply()
     *     .flatMap(reply -> event.editReply()
     *             .withContentOrNull(""Replaced the first attachment"")
     *             .withFiles(getFile())
     *             .withComponents(row)
     *             .withAttachmentsOrNull(reply.getAttachments()
     *                     .stream()
     *                     .skip(1)
     *                     .collect(Collectors.toList())));
     * }</pre>
     * <p>
     * To clear all attachments, provide an empty {@code withAttachments}:
     * <pre>{@code
     *  event.editReply()
     *     .withContentOrNull(""Removed all attachments"")
     *     .withComponents(row)
     *     .withAttachments();
     * }</pre>
     *
     * @return a {@link InteractionReplyEditMono} where, upon successful completion, emits the updated message. If an
     * error is received, it is emitted through the {@code InteractionReplyEditMono}.
     */",discord4j.core.event.domain.interaction
"@Nonnull
        public B setMaxValues(int maxValues)
        {
            Checks.positive(maxValues, ""Max Values"");
            Checks.check(maxValues <= OPTIONS_MAX_AMOUNT, ""Max Values may not be greater than %d! Provided: %d"", OPTIONS_MAX_AMOUNT, maxValues);
            this.maxValues = maxValues;
            return (B) this;
        }","/**
         * The maximum amount of values a user can select.
         * <br>Default: {@code 1}
         *
         * <p>The maximum must not exceed the amount of available options.
         *
         * @param  maxValues
         *         The max values
         *
         * @throws IllegalArgumentException
         *         If the provided amount is less than 1 or greater than {@value #OPTIONS_MAX_AMOUNT}
         *
         * @return The same builder instance for chaining
         */",net.dv8tion.jda.api.interactions.components.selections
"@Nonnull
    public EmbedBuilder setFooter(@Nullable String text)
    {
        return setFooter(text, null);
    }","/**
     * Sets the Footer of the embed without icon.
     *
     * <p><b><a href=""https://raw.githubusercontent.com/discord-jda/JDA/assets/assets/docs/embeds/12-setFooter.png"">Example</a></b>
     *
     * @param  text
     *         the text of the footer of the embed. If this is not set or set to null, the footer will not appear in the embed.
     *
     * @throws java.lang.IllegalArgumentException
     *         If {@code text} is longer than {@value net.dv8tion.jda.api.entities.MessageEmbed#TEXT_MAX_LENGTH} characters,
     *         as defined by {@link net.dv8tion.jda.api.entities.MessageEmbed#TEXT_MAX_LENGTH}
     *
     * @return the builder after the footer has been set
     */",net.dv8tion.jda.api
"public List<String> getTrace() {
        return trace;
    }","/**
     * Gets the trace of the event. Used for debugging - the guilds the user is in.
     *
     * @return The trace provided by Discord, containing the guild the user is in.
     */",discord4j.core.event.domain.lifecycle
void deleteRecordedFeatureVector(int index);,"/**
     * Delete the feature vector in the list.
     *
     * @param index
     *            the index in the list.
     */",recorder.controller
"@Nonnull
    @CheckReturnValue
    R setThreadId(@Nullable String threadId);","/**
     * Set the target thread id for the webhook message.
     * <br>This allows sending webhook messages in the target thread,
     * however the webhook must be part of the thread parent channel.
     *
     * <p>This cannot be used with {@link net.dv8tion.jda.api.interactions.InteractionHook InteractionHooks}!
     *
     * @param  threadId
     *         The target thread id or null to unset
     *
     * @throws IllegalStateException
     *         If this is an interaction webhook
     * @throws IllegalArgumentException
     *         If the provided ID is not a valid snowflake
     *
     * @return The same message action, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
"public LegacyWebhookExecuteSpec setContent(String content) {
        this.content = Possible.of(content);
        return this;
    }","/**
     * Sets the created {@link discord4j.core.object.entity.Message} contents, up to 2000 characters.
     *
     * @param content The message contents.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public Snowflake getChannelId() {
        return this.channelId;
    }","/**
     * Get the {@link Snowflake} ID of the channel where the poll is.
     *
     * @return The ID of the channel where the poll is.
     */",discord4j.core.event.domain.poll
"@Nonnull
    @CheckReturnValue
    default R mentionRoles(@Nonnull long... roleIds)
    {
        Checks.notNull(roleIds, ""RoleId array"");
        String[] stringIds = new String[roleIds.length];
        for (int i = 0; i < roleIds.length; i++)
            stringIds[i] = Long.toUnsignedString(roleIds[i]);
        return mentionRoles(stringIds);
    }","/**
     * Used to provide a whitelist of {@link net.dv8tion.jda.api.entities.Role Roles} that should be pinged,
     * even when they would not be pinged otherwise according to the Set of allowed mention types.
     *
     * <p><b>Note:</b> When a Role is whitelisted this way, then parsing of Role mentions is automatically disabled.
     * <br>Also note that whitelisting users or roles implicitly disables parsing of other mentions, if not otherwise set via
     * {@link #setDefaultMentions(Collection)} or {@link #setAllowedMentions(Collection)}.
     *
     * @param  roleIds
     *         Ids of Roles that should be explicitly whitelisted to be pingable.
     *
     * @throws IllegalArgumentException
     *         If null is provided
     *
     * @return The same instance for chaining
     *
     * @see    #setAllowedMentions(Collection)
     * @see    #setDefaultMentions(Collection)
     */",net.dv8tion.jda.api.utils.messages
"@Nonnull
    default EnumSet<ChannelType> getChannelTypes()
    {
        return ChannelType.fromSortBucket(getSortBucket());
    }","/**
     * The {@link ChannelType ChannelTypes} for the {@link #getSortBucket() sorting bucket}.
     *
     * @return The channel types
     *
     * @see    ChannelType#fromSortBucket(int)
     */",net.dv8tion.jda.api.requests.restaction.order
"public Mono<EmojiData> getData() {
        return restClient.getEmojiService().getGuildEmoji(guildId, id);
    }","/**
     * Retrieve this guild emoji's data upon subscription.
     *
     * @return a {@link Mono} where, upon successful completion, emits the {@link EmojiData} belonging to this entity.
     * If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.rest.entity
"@Nonnull
    public String getNewOwnerId()
    {
        return Long.toUnsignedString(nextId);
    }","/**
     * The new owner user id
     *
     * @return The new owner id
     */",net.dv8tion.jda.api.events.guild.update
"@Nonnull
    static ForumTagSnowflake fromId(@Nonnull String id)
    {
        return new ForumTagSnowflakeImpl(MiscUtil.parseSnowflake(id));
    }","/**
     * Wraps the provided id into a ForumTagSnowflake instance.
     *
     * @param  id
     *         The id of an existing forum tag
     *
     * @throws IllegalArgumentException
     *         If the provided id is not a valid snowflake
     *
     * @return ForumTagSnowflake instance for the provided id
     */",net.dv8tion.jda.api.entities.channel.forums
"@Nonnull
    default MessageChannel getMessageChannel()
    {
        return ChannelUtil.safeChannelCast(getChannel(), MessageChannel.class);
    }","/**
     * The {@link net.dv8tion.jda.api.entities.channel.middleman.MessageChannel} this interaction happened in.
     * <br>If {@link #getChannelType()} is not a message channel type, this throws {@link IllegalStateException}!
     *
     * @throws IllegalStateException
     *         If {@link #getChannel()} is not a message channel
     *
     * @return The {@link net.dv8tion.jda.api.entities.channel.middleman.MessageChannel}
     */",net.dv8tion.jda.api.interactions
Flux<ThreadMember> getThreadMembers(Snowflake threadId);,"/**
     * Requests to retrieve the thread's members.
     *
     * @param threadId The ID of the thread.
     * @return A {@link Flux} that continually emits the thread's {@link ThreadMember members}. If an error is received,
     * it is emitted through the {@code Flux}.
     */",discord4j.core.retriever
"public User getCurrent() {
        return current;
    }","/**
     * Gets the current, new version of the {@link User} that has been updated in this event.
     *
     * @return The current version of the {@link User} updated in this event.
     */",discord4j.core.event.domain
boolean isSynced();,"/**
     * Whether or not this GuildChannel's {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverrides} match
     * those of {@link #getParentCategory() its parent category}. If the channel doesn't have a parent category, this will return true.
     *
     * <p>This requires {@link net.dv8tion.jda.api.utils.cache.CacheFlag#MEMBER_OVERRIDES CacheFlag.MEMBER_OVERRIDES} to be enabled.
     * <br>{@link net.dv8tion.jda.api.JDABuilder#createLight(String) createLight(String)} disables this CacheFlag by default.
     *
     * @return True, if this channel is synced with its parent category
     *
     * @since  4.2.1
     */",net.dv8tion.jda.api.entities.channel.attribute
"public StorageBackend getMessageBackend() {
        return messageBackend;
    }","/**
     * Returns the {@link StorageBackend} to use for message caching.
     *
     * @return the message backend
     */",discord4j.common.store.impl
"public LegacyGuildCreateSpec addChannel(String name, Channel.Type type) {
        builder.addChannel(PartialChannelCreateRequest.builder()
                .name(name)
                .type(type.getValue())
                .build());
        return this;
    }","/**
     * Adds the channel to the list of channels for the created {@link Guild}.
     *
     * @param name The name of the channel.
     * @param type The type of the channel.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
        static GlobalRateLimit create()
        {
            return new GlobalRateLimit()
            {
                private final AtomicLong classic = new AtomicLong(-1);
                private final AtomicLong cloudflare = new AtomicLong(-1);

                @Override
                public long getClassic()
                {
                    return classic.get();
                }

                @Override
                public void setClassic(long timestamp)
                {
                    classic.set(timestamp);
                }

                @Override
                public long getCloudflare()
                {
                    return cloudflare.get();
                }

                @Override
                public void setCloudflare(long timestamp)
                {
                    cloudflare.set(timestamp);
                }
            };
        }","/**
         * Creates a default instance of this interface.
         * <br>This uses {@link AtomicLong} to keep track of rate-limits.
         *
         * @return The default implementation
         */",net.dv8tion.jda.api.requests
"default Flux<Webhook> getWebhooks() {
        return getClient().getRestClient().getWebhookService()
                .getChannelWebhooks(getId().asLong())
                .map(data -> new Webhook(getClient(), data));
    }","/**
     * Requests to retrieve the webhooks of the channel.
     *
     * @return A {@link Flux} that continually emits the {@link Webhook webhooks} of the channel. If an error is
     * received, it is emitted through the {@code Flux}.
     */",discord4j.core.object.entity.channel
"@Nonnull
        default DirectAudioController getAudioController()
        {
            return getJDA().getDirectAudioController();
        }","/**
         * Shortcut to access the audio controller of this JDA instance
         *
         * @return The {@link DirectAudioController} for this JDA instance
         */",net.dv8tion.jda.api.hooks
"Mono<VoiceStateData> onVoiceStateUpdateDispatch(int shardIndex, VoiceStateUpdateDispatch dispatch);","/**
     * Updates the internal state of the store according to the given {@link VoiceStateUpdateDispatch} gateway
     * dispatch. This will typically perform an insert, update or delete operation on the related
     * {@link VoiceStateData}.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a {@link Mono} completing when the operation is done, optionally returning the old state of the
     * {@link VoiceStateData} before the update
     */",discord4j.common.store.api.layout
"@Nonnull
    @CheckReturnValue
    default PermissionOverrideAction clear(@Nonnull Permission... permissions)
    {
        return clear(Permission.getRaw(permissions));
    }","/**
     * Clears the provided {@link net.dv8tion.jda.api.Permission Permissions} bits
     * from the {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverride}.
     * <br>This will cause the provided Permissions to be inherited
     *
     * @param  permissions
     *         The permissions to clear from the {@link net.dv8tion.jda.api.entities.PermissionOverride PermissionOverride}
     *
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have {@link Permission#MANAGE_PERMISSIONS Permission.MANAGE_PERMISSIONS}
     *         on the channel and tries to set permissions it does not have in the channel
     * @throws IllegalArgumentException
     *         If any provided argument is null
     *
     * @return The current PermissionOverrideAction - for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction
"@Nullable
    @Unmodifiable
    public List<IntegrationPrivilege> getApplicationPrivileges()
    {
        return getCommandPrivileges(getJDA().getSelfUser().getApplicationId());
    }","/**
     * The {@link IntegrationPrivilege IntegrationPrivileges} that have been applied to this application in this guild.
     *
     * <br><b>If the privileges are ""Synced"" (No custom config applied), this will return null.</b>
     *
     * <p>This does not include privileges applied to a command itself. Use {@link #getCommandPrivileges(String)} for that.
     *
     * @return Immutable List containing all IntegrationPrivileges that have been applied to this application in this guild.
     */",net.dv8tion.jda.api.interactions.commands
"public static final Route GUILD_MEMBER_MODIFY = Route.patch(""/guilds/{guild.id}/members/{user.id}"");","/**
     * Modify attributes of a guild member. Returns a 200 OK with the guild member on success. Fires a Guild Member
     * Update Gateway event.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/guild#modify-guild-member"">
     * https://discord.com/developers/docs/resources/guild#modify-guild-member</a>
     */",discord4j.rest.route
"default long getGuildIdLong()
        {
            return getGuild().getIdLong();
        }","/**
         * Shortcut to access the guild id
         *
         * @return The guild id
         */",net.dv8tion.jda.api.hooks
"public RestScheduledEvent getScheduledEventById(final Snowflake guildId, final Snowflake eventId) {
        return RestScheduledEvent.create(this, guildId, eventId);
    }","/**
     * Requests to retrieve the scheduled event represented by the supplied ID.
     *
     * @param guildId The ID of the guild
     * @param eventId The ID of the event
     * @return A {@link RestScheduledEvent} as represented by the supplied IDs.
     */",discord4j.rest
"public Mono<PollAnswer> getAnswer() {
        return getPoll()
            .flatMap(poll -> Mono.justOrEmpty(poll.getAnswerById(this.answerId)));
    }","/**
     * Get the {@link PollAnswer} that was voted.
     *
     * @return The answer that was voted.
     */",discord4j.core.event.domain.poll
"@Nonnull
    @Unmodifiable
    public List<AuditLogChange> getChangesForKeys(@Nonnull AuditLogKey... keys)
    {
        Checks.notNull(keys, ""Keys"");
        List<AuditLogChange> changes = new ArrayList<>(keys.length);
        for (AuditLogKey key : keys)
        {
            AuditLogChange change = getChangeByKey(key);
            if (change != null)
                changes.add(change);
        }
        return Collections.unmodifiableList(changes);
    }","/**
     * Filters all changes by the specified keys
     *
     * @param  keys
     *         Varargs {@link net.dv8tion.jda.api.audit.AuditLogKey AuditLogKeys} to look for
     *
     * @throws java.lang.IllegalArgumentException
     *         If provided with null array
     *
     * @return Possibly-empty, never-null immutable list of {@link AuditLogChange AuditLogChanges}
     */",net.dv8tion.jda.api.audit
"public Mono<MemberData> getSelfMember(Snowflake guildId) {
        return guildService.getGuildMember(guildId.asLong(), restResources.getSelfId().asLong());
    }","/**
     * Requests to retrieve the bot user, represented as a member of the guild of the supplied ID
     *
     * @param guildId The ID of the guild
     * @return a {@link Mono} where, upon successful completion, emits the bot {@link MemberData member}. If an error is
     *         received, it is emitted through the {@code Mono}.
     */",discord4j.rest
"public LegacyRoleCreateSpec setHoist(boolean hoist) {
        this.hoist = hoist;
        return this;
    }","/**
     * Sets whether the created {@link Role} should be displayed separately in the sidebar.
     *
     * @param hoist The role hoisted property.
     * @return This spec.
     */",discord4j.core.spec.legacy
String[] packageNames = configuration.classDocCatalog.packageNames();,"/**
	 * Generate the class files for single classes specified on the command
	 * line.
	 * 
	 * @param classtree
	 *            the data structure representing the class tree.
	 */",net.winroad.wrdoclet
int getUserLimit();,"/**
     * The maximum amount of {@link net.dv8tion.jda.api.entities.Member Members} that be in an audio connection within this channel concurrently.
     * <br>Returns 0 if there is no limit.
     *
     * <p>Moderators with the {@link net.dv8tion.jda.api.Permission#VOICE_MOVE_OTHERS VOICE_MOVE_OTHERS} permission can bypass this limit.
     *
     * @return The maximum connections allowed in this channel concurrently
     */",net.dv8tion.jda.api.entities.channel.middleman
long getBannerIdLong();,"/**
     * The id for the pack banner.
     * <br>This is shown when you at the top of the pack pop-out in the client.
     *
     * @return The banner id, or {@code 0} if there is no banner
     */",net.dv8tion.jda.api.entities.sticker
"public Mono<Void> delete(@Nullable String reason) {
        return restClient.getWebhookService().deleteWebhook(id, reason);
    }","/**
     * Delete a webhook permanently. Requires the {@link Permission#MANAGE_WEBHOOKS} permission. Returns empty on
     * success.
     *
     * @param reason an optional reason for the audit log
     * @return a {@link Mono} where, upon subscription, emits a complete signal on success. If an error is received, it
     * is emitted through the {@code Mono}.
     */",discord4j.rest.entity
"public static final Route APPLICATION_EMOJI_CREATE = Route.post(""/applications/{application.id}/emojis"");","/**
     * Create a new emoji for the application. Returns the new emoji object on success.
     * <br>
     * Emojis and animated emojis have a maximum file size of 256 KiB.
     * Attempting to upload an emoji larger than this limit will fail and return 400 Bad Request and an error message, but not a JSON status code.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/emoji#create-application-emoji"">https://discord.com/developers/docs/resources/emoji#create-application-emoji</a>
     */",discord4j.rest.route
"@Nullable
        ImageProxy getAvatar();","/**
         * Returns an {@link ImageProxy} for this user's avatar image.
         *
         * @return Possibly-null {@link ImageProxy} of this user's avatar image
         *
         * @see    #getAvatarUrl()
         */",net.dv8tion.jda.api.entities
"public static final Route INVITE_DELETE = Route.delete(""/invites/{invite.code}"");","/**
     * Delete an invite. Requires the MANAGE_CHANNELS permission. Returns an invite object on success.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/invite#delete-invite"">
     * https://discord.com/developers/docs/resources/invite#delete-invite</a>
     */",discord4j.rest.route
"public Instant getTimestamp() {
        return Instant.ofEpochMilli(DISCORD_EPOCH + (id >>> 22));
    }","/**
     * Gets the timestamp of this {@code Snowflake}.
     *
     * @return The timestamp of this {@code Snowflake}.
     */",discord4j.common.util
"public LegacyInviteCreateSpec setTemporary(boolean temporary) {
        requestBuilder.temporary(temporary);
        return this;
    }","/**
     * Sets whether the created {@link Invite} only grants temporary membership. This property is {@code false} by
     * default.
     *
     * @param temporary {@code true} if this invite is temporary, {@code false} otherwise.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public Snowflake getEventId() {
        return Snowflake.of(data.guildScheduledEventId());
    }","/**
     * Gets the ID of the event the user is subscribed to.
     *
     * @return The ID of the event the user is subscribed to.
     */",discord4j.core.object
"@Nonnull
    static Button primary(@Nonnull String id, @Nonnull String label)
    {
        Checks.notEmpty(id, ""Id"");
        Checks.notEmpty(label, ""Label"");
        Checks.notLonger(id, ID_MAX_LENGTH, ""Id"");
        Checks.notLonger(label, LABEL_MAX_LENGTH, ""Label"");
        return new ButtonImpl(id, label, ButtonStyle.PRIMARY, false, null);
    }","/**
     * Creates a button with {@link ButtonStyle#PRIMARY PRIMARY} Style.
     * <br>The button is enabled and has no emoji attached by default.
     * You can use {@link #asDisabled()} and {@link #withEmoji(Emoji)} to further configure it.
     *
     * @param  id
     *         The custom button ID
     * @param  label
     *         The text to display on the button
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If any provided argument is null or empty.</li>
     *             <li>If the character limit for {@code id}, defined by {@link #ID_MAX_LENGTH} as {@value #ID_MAX_LENGTH},
     *             is exceeded.</li>
     *             <li>If the character limit for {@code label}, defined by {@link #LABEL_MAX_LENGTH} as {@value #LABEL_MAX_LENGTH},
     *             is exceeded.</li>
     *         </ul>
     *
     * @return The button instance
     */",net.dv8tion.jda.api.interactions.components.buttons
"public Mono<GuildTemplate> sync() {
        return gateway.getRestClient().getTemplateService()
                .syncTemplate(guildId, getCode())
                .map(data -> new GuildTemplate(gateway, data));
    }","/**
     * Requests to sync this template with the guild's current state.
     *
     * @return a {@link Mono} that, upon subscription, syncs a template with its guild. If an error is received, it
     * will be emitted through the Mono.
     */",discord4j.core.object
"public Optional<UserData> getUserData() {
        return Optional.ofNullable(userData);
    }","/**
     * Returns the user data, if present.
     *
     * @return an optional {@link UserData}
     */",discord4j.common.store.api.object
long getPackIdLong();,"/**
     * The ID of the pack the sticker is from.
     *
     * @return the ID of the pack the sticker is from
     */",net.dv8tion.jda.api.entities.sticker
"@Nonnull
    public List<UserSnowflake> getBannedUsers()
    {
        return bannedUsers;
    }","/**
     * List of successfully banned users.
     *
     * @return {@link List} of {@link UserSnowflake}
     */",net.dv8tion.jda.api.entities
"@Nonnull
    @Unmodifiable
    default List<ForumChannel> getForumChannels()
    {
        return getForumChannelCache().asList();
    }","/**
     * Gets all {@link ForumChannel} in the cache.
     *
     * <p>This copies the backing store into a list. This means every call
     * creates a new list with O(n) complexity. It is recommended to store this into
     * a local variable or use {@link #getForumChannelCache()} and use its more efficient
     * versions of handling these values.
     *
     * <p>This getter exists on any instance of {@link IGuildChannelContainer} and only checks the caches with the relevant scoping.
     * For {@link Guild}, {@link JDA}, or {@link ShardManager},
     * this returns the relevant channel with respect to the cache within each of those objects.
     * For a guild, this would mean it only returns channels within the same guild.
     * <br>If this is called on {@link JDA} or {@link ShardManager}, this may return null immediately after building, because the cache isn't initialized yet.
     * To make sure the cache is initialized after building your {@link JDA} instance, you can use {@link JDA#awaitReady()}.
     *
     * @return An immutable List of {@link ForumChannel}.
     */",net.dv8tion.jda.api.entities.channel.attribute
"public boolean isNews()
    {
        return isNews;
    }","/**
     * Whether or not this channel is considered an Announcement-/News-Channel.
     * <br>These channels can be used to crosspost messages to other guilds by using a follower type webhook.
     *
     * @return True, if this is considered a news channel
     */",net.dv8tion.jda.api.entities.templates
"public static final Route APPLICATION_EMOJI_DELETE = Route.delete(""/applications/{application.id}/emojis/{emoji.id}"");","/**
     * Delete the given emoji. Returns 204 No Content on success.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/emoji#delete-application-emoji"">https://discord.com/developers/docs/resources/emoji#delete-application-emoji</a>
     */",discord4j.rest.route
"public StatusUpdate getStatusUpdate() {
        return statusUpdate;
    }","/**
     * Converts this presence's data to an object for use by the gateway.
     *
     * @return An equivalent {@code StatusUpdate} for this presence.
     */",discord4j.core.object.presence
"void add(int key, GatewayClient client);","/**
     * Add a {@link GatewayClient} to be managed by this instance.
     *
     * @param key a key to later reference the added client
     * @param client the client to be managed
     */",discord4j.core.shard
"public Publisher<?> onMemberLeave(MemberLeaveEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when a user leaves a guild, or is kicked from it.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"public MongoClientSettings applyDefaultMongoClientSettings() {
         this.mongoClientSettings = MongoClientSettings.builder().applyConnectionString(new ConnectionString(""mongodb://"" + this.connectionData.getUsername() + "":"" + this.connectionData.getPassword() + ""@"" +
                this.connectionData.getHost() + "":"" + this.connectionData.getPort() + ""/"" + this.connectionData.getDatabase() + ""?ssl=true&sslInvalidHostNameAllowed=true"")).build();
         return this.mongoClientSettings;
    }","/**
     * Gets new {@link MongoClientSettings} based on given {@link ConnectionData} with active ssh values
     * @return {@link MongoClientSettings} containing recommended properties and connection-information
     */",io.github.heliumdioxid.database.mongo.config
"public Instant getCreation() {
        return createdAt;
    }","/**
     * Gets when this invite was created.
     *
     * @return When this invite was created.
     */",discord4j.core.event.domain
"@Nonnull
    IPermissionContainerUnion getChannel();","/**
     * The {@link net.dv8tion.jda.api.entities.channel.attribute.IPermissionContainer GuildChannel} that this PermissionOverride affects.
     *
     * @return Never-null related {@link net.dv8tion.jda.api.entities.channel.attribute.IPermissionContainer GuildChannel} that this override is part of.
     */",net.dv8tion.jda.api.entities
"public void start(Duration delay, Duration period) {
        this.task.update(Flux.interval(delay, period, scheduler)
                .subscribe(tick -> sink.emitNext(tick, this)));
    }","/**
     * Begin producing ticks at the given rate.
     *
     * @param delay the {@link Duration} to wait before emitting the first tick
     * @param period the period {@link Duration} used to emit ticks.
     * @see Flux#interval(Duration, Duration, Scheduler)
     */",discord4j.common
"public Builder udpClient(UdpClient udpClient) {
            this.udpClient = udpClient;
            return this;
        }","/**
         * Set the UDP client used to create voice protocol connections.
         *
         * @param udpClient the UDP client
         * @return this builder
         */",discord4j.voice
"public InteractionFollowupEditMono editFollowup(Snowflake messageId) {
        return InteractionFollowupEditMono.of(messageId, this);
    }","/**
     * Edits a follow-up message to this interaction. Properties specifying how to edit the follow-up message can be
     * set via the {@code withXxx} methods of the returned {@link InteractionFollowupEditMono}.
     *
     * @param messageId the follow-up message ID to edit
     * @return a {@link InteractionFollowupEditMono} where, upon successful completion, emits the updated follow-up
     * message. If an error is received, it is emitted through the {@code InteractionFollowupEditMono}.
     */",discord4j.core.event.domain.interaction
"public Snowflake getThreadId() {
        // ThreadMemberData#id is absent in GUILD_CREATE (threads self is part of)
        // TODO D4J should be able to include the missing value with the outer thread id when creating ThreadMember
        return Snowflake.of(data.id().toOptional().orElseThrow(IllegalStateException::new));
    }","/**
     * Gets the ID of thread which member is associated.
     *
     * @return The ID of thread channel.
     */",discord4j.core.object.entity
"public static final Route WEBHOOK_MESSAGE_GET = Route.get(""/webhooks/{webhook.id}/{webhook.token}/messages/{message.id}"");","/**
     * @see <a href=""https://discord.com/developers/docs/resources/webhook#get-webhook-message"">
     * https://discord.com/developers/docs/resources/webhook#get-webhook-message</a>
     */",discord4j.rest.route
FollowupInteractionHandler replyEphemeral(String content);,"/**
     * Build an interaction handler that will produce a text reply only to the interaction member.
     *
     * @param content the content to be sent as reply
     * @return a followup handler to continue processing this interaction asynchronously, until the interaction token
     * bound to this interaction expires after 15 minutes.
     */",discord4j.rest.interaction
"public LegacyGuildEditSpec setDiscoverySplash(@Nullable Image discoverySplash) {
        requestBuilder.splash(Possible.of(Optional.ofNullable(discoverySplash).map(Image::getDataUri)));
        return this;
    }","/**
     * Sets the image for the guild discovery splash (when the server has the DISCOVERABLE feature).
     *
     * @param discoverySplash The image for the guild discovery splash.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public Optional<PermissionSet> getEffectivePermissions() {
        return Possible.flatOpt(data.permissions()).map(PermissionSet::of);
    }","/**
     * Gets the computed permissions for the invoking user in the channel, including overwrites.
     * This field can be absent when you are not in a guild, e.g. when providing a DM channel.
     *
     * @return The permissions of the channel.
     */",discord4j.core.object.command
"@Nullable
    default String getIconUrl()
    {
        String iconId = getIconId();
        return iconId == null ? null : String.format(ICON_URL, getId(), iconId);
    }","/**
     * The url for the icon of this team.
     *
     * @return The icon url, or null if no icon is applied
     */",net.dv8tion.jda.api.entities
"public Mono<GuildChannel> getChannel(EntityRetrievalStrategy retrievalStrategy) {
        return gateway.withRetrievalStrategy(retrievalStrategy)
                .getChannelById(getChannelId())
                .cast(GuildChannel.class);
    }","/**
     * Requests to retrieve the channel associated to this overwrite, using the given retrieval strategy.
     *
     * @param retrievalStrategy the strategy to use to get the channel
     * @return A {@link Mono} where, upon successful completion, emits the {@link GuildChannel} associated to this
     * overwrite. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.object
Mono<Long> countPresencesInGuild(long guildId);,"/**
     * Counts the number of presences present in the store for the given guild ID.
     *
     * @param guildId the guild ID
     * @return A {@link Mono} emitting the presence count
     */",discord4j.common.store.api.layout
"public Builder receiveTaskScheduler(Scheduler receiveTaskScheduler) {
            this.receiveTaskScheduler = receiveTaskScheduler;
            return this;
        }","/**
         * Set the {@link Scheduler} used for voice receive loop.
         *
         * @param receiveTaskScheduler the voice receive scheduler
         * @return this builder
         */",discord4j.voice
Set<RestRole> getRoles();,"/**
     * Return the role set for this interaction member.
     *
     * @return the set of {@link RestRole} belonging to this member
     */",discord4j.rest.interaction
"public Optional<Role> getRole() {
        return Optional.ofNullable(role);
    }","/**
     * Gets the {@link Role} that was deleted in this event, if present. This may not be available if {@code Roles} are
     * not stored.
     *
     * @return The {@link Role} that was deleted in this event, if present.
     */",discord4j.core.event.domain.role
Mono<PermissionSet> getEffectivePermissions(Snowflake memberId);,"/**
     * Gets the permissions for the given member, taking into account permission overwrites in this channel.
     *
     * @param memberId The ID of the member to get permissions for.
     * @return The permissions for the given member.
     */",discord4j.core.object.entity.channel
"@Nonnull
    public String getThreadMemberId()
    {
        return Long.toUnsignedString(getThreadMemberIdLong());
    }","/**
     * The id of the {@link ThreadMember} that fired this and derived event.
     *
     * @return Never-null String containing the ID.
     */",net.dv8tion.jda.api.events.thread.member
Mono<StageInstance> getStageInstanceByChannelId(Snowflake channelId);,"/**
     * Requests to retrieve the stage instance associated to the supplied channel ID.
     *
     * @param channelId The ID of the channel.
     * @return A {@link Mono} where, upon successful completion, emits the {@link StageInstance} associated to the supplied
     *         channel ID. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.retriever
"@Nonnull
    DiscordLocale getUserLocale();","/**
     * Returns the selected language of the invoking user.
     *
     * @return The language of the invoking user
     */",net.dv8tion.jda.api.interactions
"public Publisher<?> onThreadChannelCreateEvent(ThreadChannelCreateEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when a thread is created, relevant to the current user, or when the current user is added to a thread.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"@Nullable
    Member getTargetMember();","/**
     * If this context menu command was used in a {@link net.dv8tion.jda.api.entities.Guild Guild},
     * this returns the member instance for the target user.
     *
     * @return The target member instance, or null if this was not in a guild.
     */",net.dv8tion.jda.api.interactions.commands.context
"public Mono<Void> delete(@Nullable String reason) {
        return restClient.getChannelService().deleteMessage(channelId, id, reason);
    }","/**
     * Requests to delete this message while optionally specifying a reason.
     *
     * @param reason The reason, if present.
     * @return A {@link Mono} where, upon successful completion, emits nothing; indicating the message has been deleted.
     * If an error is received, it is emitted through the {@code Mono}.
     * @see <a href=""https://discord.com/developers/docs/resources/channel#delete-message"">Delete Message</a>
     */",discord4j.rest.entity
"public Publisher<?> onEmojisUpdate(EmojisUpdateEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when an emoji is added, deleted or edited in a guild. The emojis set includes ALL emojis of the guild.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"@Nonnull
    static Button secondary(@Nonnull String id, @Nonnull Emoji emoji)
    {
        Checks.notEmpty(id, ""Id"");
        Checks.notNull(emoji, ""Emoji"");
        Checks.notLonger(id, ID_MAX_LENGTH, ""Id"");
        return new ButtonImpl(id, """", ButtonStyle.SECONDARY, false, emoji);
    }","/**
     * Creates a button with {@link ButtonStyle#SECONDARY SECONDARY} Style.
     * <br>The button is enabled and has no text label.
     * To use labels you can use {@code secondary(id, label).withEmoji(emoji)}
     *
     * <p>To disable the button you can use {@link #asDisabled()}.
     *
     * @param  id
     *         The custom button ID
     * @param  emoji
     *         The emoji to use as the button label
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If any provided argument is null or empty.</li>
     *             <li>If the character limit for {@code id}, defined by {@link #ID_MAX_LENGTH} as {@value #ID_MAX_LENGTH},
     *             is exceeded.</li>
     *         </ul>
     *
     * @return The button instance
     */",net.dv8tion.jda.api.interactions.components.buttons
"public Snowflake getNewsChannelId() {
        return Snowflake.of(data.channelId());
    }","/**
     * Returns the ID of the news channel that has been followed.
     *
     * @return the news channel ID
     */",discord4j.core.object
"@Nonnull
    @Override
    StandardGuildMessageChannelManager<?, ?> getManager();","/**
     * The maximum length a channel topic can be ({@value #MAX_TOPIC_LENGTH})
     * <br>Forum channels have a higher limit, defined by {@link ForumChannel#MAX_FORUM_TOPIC_LENGTH}
     */",net.dv8tion.jda.api.entities.channel.middleman
boolean isLinkedRole();,"/**
         * Whether this role is acquired through a user connection.
         * <br>Such as external services like twitter or reddit.
         * This also includes custom third-party applications, such as those managed by bots via {@link RoleConnectionMetadata}.
         *
         * @return True, if this role is acquired through a user connection
         *
         * @see    <a href=""https://discord.com/developers/docs/tutorials/configuring-app-metadata-for-linked-roles"" target=""_blank"">Configuring App Metadata for Linked Roles</a>
         */",net.dv8tion.jda.api.entities
"public LegacyGuildEditSpec setSystemChannelId(@Nullable Snowflake systemChannelId) {
        requestBuilder.systemChannelId(Possible.of(Optional.ofNullable(systemChannelId).map(Snowflake::asString)));
        return this;
    }","/**
     * Sets the id of the channel where guild notices such as welcome messages and boost events are posted.
     *
     * @param systemChannelId The id of the channel where guild notices such as welcome messages and boost events
     *                        are posted.
     * @return This spec.
     */",discord4j.core.spec.legacy
int cancelRequests();,"/**
     * Cancel all currently queued requests, which are not marked as {@link Work#isPriority() priority}.
     *
     * @return The number of cancelled requests
     */",net.dv8tion.jda.api.requests
"public boolean playerCanBuild(Player player, Location location) {
        return hasBuildPermission(player, location) && hasBreakPermission(player, location);
    }","/**
     * General check for WorldGuard region @ location.
     * @param player player in question.
     * @param location Location of block broken.
     * @return
     */",com.massivecraft.factions.integration
"public StageChannelEditMono edit() {
        return StageChannelEditMono.of(this);
    }","/**
     * Requests to edit this stage channel. Properties specifying how to edit this stage channel can be set via the
     * {@code withXxx} methods of the returned {@link StageChannelEditMono}.
     *
     * @return A {@link StageChannelEditMono} where, upon successful completion, emits the edited {@link StageChannel}.
     * If an error is received, it is emitted through the {@code StageChannelEditMono}.
     */",discord4j.core.object.entity.channel
"@Nullable
    Color getColor();","/**
     * The color this {@link net.dv8tion.jda.api.entities.Role Role} is displayed in.
     *
     * @return Color value of Role-color
     *
     * @see    #getColorRaw()
     */",net.dv8tion.jda.api.entities
"public Snowflake getChannelId() {
        return Snowflake.of(data.channelId());
    }","/**
     * Gets the channel ID associated to this stage instance.
     *
     * @return The channel ID associated to this stage instance.
     */",discord4j.core.object.entity
"public LegacyInviteCreateSpec setMaxAge(int maxAge) {
        requestBuilder.maxAge(maxAge);
        return this;
    }","/**
     * Sets the duration of the created {@link Invite} in seconds before expiration, or {@code 0} to never expire. If
     * unset, the default of 24 hours will be used.
     *
     * @param maxAge The duration of the invite in seconds, or {@code 0} to never expire.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
    OptionType getOptionType();","/**
     * The {@link OptionType} of the choices you can suggest.
     *
     * @return The option type
     */",net.dv8tion.jda.api.requests.restaction.interactions
"public PollAnswerObject getData() {
        return this.data;
    }","/**
     * Gets the raw data of the poll answer.
     *
     * @return the raw data of the poll answer
     */",discord4j.core.object.entity.poll
"@Nonnull
        public Builder setMinLength(int minLength)
        {
            if (minLength != -1)
            {
                Checks.notNegative(minLength, ""Minimum length"");
                Checks.check(minLength <= MAX_VALUE_LENGTH, ""Minimum length cannot be longer than %d characters!"", MAX_VALUE_LENGTH);
            }

            this.minLength = minLength;
            return this;
        }","/**
         * Sets the minimum length of this input field. Default is -1 (No minimum length).
         *
         * <p><b>This has to be between 0 and {@value #MAX_VALUE_LENGTH}, or -1 for no minimum length</b>
         *
         * @param  minLength
         *         The minimum amount of characters that need to be written, or -1
         *
         * @throws IllegalArgumentException
         *         If minLength is not -1 and is negative or greater than {@value #MAX_VALUE_LENGTH}
         *
         * @return The same builder instance for chaining
         */",net.dv8tion.jda.api.interactions.components.text
"public Mono<TemplateData> getData() {
        return restClient.getTemplateService().getTemplate(code);
    }","/**
     * Retrieve this template's data upon subscription.
     *
     * @return a template object
     */",discord4j.rest.entity
GatewayDiscordClient getClient();,"/**
     * Returns the {@link GatewayDiscordClient} that created this object. Methods in it are exclusively based on the
     * entity cache or {@link Store} in use. Refer to calling {@code getClient().rest()} to access a
     * {@link DiscordClient} that is capable of requesting entities directly from the REST API.
     *
     * @return The {@link GatewayDiscordClient} associated to this object.
     */",discord4j.core.object
"@RequestMapping(value = ""update"", method = RequestMethod.PUT)
    public Mono<Void> update(@Valid @RequestBody UserUpdateDTO dto) {
        return service.update(dto);
    }","/**
     * This method sends the DTO to the service's update method.
     *
     * @param dto -> UserUpdateDTO comes from the corresponding request body
     * @return Mono<Void>
     * @since 1.0
     */",org.khasanof.citiesapi.controller.user
"@Nonnull
    public Map<String, Object> getOptions()
    {
        return options;
    }","/**
     * Key-Value {@link java.util.Map Map} containing all Options made in this entry. The keys for the returned map are
     * case-insensitive keys defined in the regarding AuditLogChange value.
     * <br>To iterate only the changes you can use {@link java.util.Map#values() Map.values()}!
     *
     * <p>Options may include secondary targets or details that do not qualify as ""change"".
     * <br>An example of that would be the {@code member} option
     * for {@link net.dv8tion.jda.api.audit.ActionType#CHANNEL_OVERRIDE_UPDATE CHANNEL_OVERRIDE_UPDATE}
     * containing the user_id of a {@link net.dv8tion.jda.api.entities.Member Member}.
     *
     * @return Key-Value Map of changes
     */",net.dv8tion.jda.api.audit
"public Mono<Message> getTargetMessage() {
        return getClient().getMessageById(getInteraction().getChannelId(), getTargetId());
    }","/**
     * Requests to retrieve the targeted Message.
     *
     * @return A {@link Mono} where, upon successful completion, emits the {@link Message} targeted by the user.
     * If an error is received, it is emitted through the Mono.
     */",discord4j.core.event.domain.interaction
"public Mono<Role> getOptionAsRole(final String name) {
        return getOption(name)
            .flatMap(ApplicationCommandInteractionOption::getValue)
            .map(ApplicationCommandInteractionOptionValue::asRole)
            .orElse(Mono.empty());
    }","/**
     * Gets the value of the option corresponding to the provided name, if present, as a {@link Role}.
     *
     * @param name The name of the option.
     * @return A {@link Mono} containing the value of the option corresponding to the provided name, if present, or empty otherwise.
     * If the option is present but its value cannot be converted to a role, the {@link Mono} will complete with an error.
     */",discord4j.core.event.domain.interaction
"@Nonnull
    @Unmodifiable
    default List<StageChannel> getStageChannels()
    {
        return getGuild().getStageChannelCache().applyStream(stream ->
            stream.filter(channel -> equals(channel.getParentCategory()))
                  .sorted()
                  .collect(Helpers.toUnmodifiableList())
        );
    }","/**
     * All {@link StageChannel StageChannel}
     * listed for this Category
     *
     * @return Immutable list of all child StageChannel
     */",net.dv8tion.jda.api.entities.channel.concrete
"@Nonnull
    @CheckReturnValue
    ScheduledEventManager setImage(@Nullable Icon icon);","/**
     * Sets the cover image for the new {@link ScheduledEvent ScheduledEvent}.
     *
     * @param  icon
     *         The cover image for the new {@link ScheduledEvent ScheduledEvent},
     *         or {@code null} for no cover image.
     *
     * @return ScheduledEventManager for chaining convenience
     */",net.dv8tion.jda.api.managers
"@Nonnull
    @CheckReturnValue
    AutoModRuleManager setResponses(@Nonnull Collection<? extends AutoModResponse> responses);","/**
     * Sets what the rule should do upon triggering.
     *
     * <p>Note that each response type can only be used once.
     * If multiple responses of the same type are provided, the last one is used.
     *
     * @param  responses
     *         The responses to configure
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If {@code null} or {@link AutoModResponse.Type#UNKNOWN} is provided</li>
     *             <li>If the collection is empty</li>
     *         </ul>
     *
     * @return AutoModRuleManager for chaining convenience
     */",net.dv8tion.jda.api.managers
List<Role> roles = guild.getRoles();,"/**
     * Creates a new RoleOrderAction instance
     *
     * @param  guild
     *         The target {@link net.dv8tion.jda.api.entities.Guild Guild} of which
     *         to change the {@link net.dv8tion.jda.api.entities.Role Role} order
     * @param  useAscendingOrder
     *         Defines the ordering of the OrderAction. If {@code false}, the OrderAction will be in the ordering
     *         defined by Discord for roles, which is Descending. This means that the highest role appears at index {@code 0}
     *         and the lowest role at index {@code n - 1}. Providing {@code true} will result in the ordering being
     *         in ascending order, with the lower role at index {@code 0} and the highest at index {@code n - 1}.
     *         <br>As a note: {@link net.dv8tion.jda.api.entities.Member#getRoles() Member.getRoles()}
     *         and {@link net.dv8tion.jda.api.entities.Guild#getRoles() Guild.getRoles()} are both in descending order.
     */",net.dv8tion.jda.internal.requests.restaction.order
"@Nonnull
    @Unmodifiable
    default List<TextChannel> getTextChannelsByName(@Nonnull String name, boolean ignoreCase)
    {
        return getTextChannelCache().getElementsByName(name, ignoreCase);
    }","/**
     * Gets a list of all {@link TextChannel TextChannels}
     * in this Guild that have the same name as the one provided.
     * <br>If there are no channels with the provided name, then this returns an empty list.
     *
     * <p>This getter exists on any instance of {@link IGuildChannelContainer} and only checks the caches with the relevant scoping.
     * For {@link Guild}, {@link JDA}, or {@link ShardManager},
     * this returns the relevant channel with respect to the cache within each of those objects.
     * For a guild, this would mean it only returns channels within the same guild.
     * <br>If this is called on {@link JDA} or {@link ShardManager}, this may return null immediately after building, because the cache isn't initialized yet.
     * To make sure the cache is initialized after building your {@link JDA} instance, you can use {@link JDA#awaitReady()}.
     *
     * @param  name
     *         The name used to filter the returned {@link TextChannel TextChannels}.
     * @param  ignoreCase
     *         Determines if the comparison ignores case when comparing. True - case insensitive.
     *
     * @return Possibly-empty immutable list of all TextChannels names that match the provided name.
     */",net.dv8tion.jda.api.entities.channel.attribute
"@Nonnull
    @Override
    ChannelAction<VoiceChannel> createCopy(@Nonnull Guild guild);","/**
     * The maximum limit you can set with {@link VoiceChannelManager#setUserLimit(int)}. ({@value})
     */",net.dv8tion.jda.api.entities.channel.concrete
"public Flux<RegionData> getRegions() {
        return this.getVoiceService().getVoiceRegions();
    }","/**
     * Requests to retrieve the voice regions that are available.
     *
     * @return A {@link Flux} that continually emits the {@link RegionData regions} that are available. If an error is
     * received, it is emitted through the {@code Flux}.
     */",discord4j.rest
"public static CountInGuildAction countRolesInGuild(long guildId) {
        return new CountInGuildAction(InGuildEntity.ROLES, guildId);
    }","/**
     * Creates an action to count the number of roles present in a store for the given guild ID.
     *
     * @param guildId the guild ID
     * @return a new {@link CountInGuildAction}
     */",discord4j.common.store.action.read
"@Deprecated
    public Mono<StoreChannel> edit(final Consumer<? super LegacyStoreChannelEditSpec> spec) {
        return Mono.defer(
                () -> {
                    LegacyStoreChannelEditSpec mutatedSpec = new LegacyStoreChannelEditSpec();
                    spec.accept(mutatedSpec);
                    return getClient().getRestClient().getChannelService()
                            .modifyChannel(getId().asLong(), mutatedSpec.asRequest(), mutatedSpec.getReason());
                })
                .map(data -> EntityUtil.getChannel(getClient(), data))
                .cast(StoreChannel.class);
    }","/**
     * Requests to edit this store channel.
     *
     * @param spec A {@link Consumer} that provides a ""blank"" {@link LegacyStoreChannelEditSpec} to be operated on.
     * @return A {@link Mono} where, upon successful completion, emits the edited {@link StoreChannel}. If an error is
     * received, it is emitted through the {@code Mono}.
     * @deprecated use {@link #edit(StoreChannelEditSpec)} or {@link #edit()} which offer an immutable approach to build
     * specs
     */",discord4j.core.object.entity.channel
"public boolean isGuildMuted()
    {
        return guildMuted;
    }","/**
     * Whether the member was muted by a moderator in this event
     *
     * @return True, if a moderator muted this member,
     *         <br>False, if a moderator un-muted this member
     */",net.dv8tion.jda.api.events.guild.voice
"@Nullable
    public String getOldBannerId()
    {
        return getOldValue();
    }","/**
     * The old banner id
     *
     * @return The old banner id, or null if the banner didn't exist
     */",net.dv8tion.jda.api.events.guild.update
"@Nonnull
    @CheckReturnValue
    M setParent(@Nullable Category category);","/**
     * Sets the <b><u>{@link Category Parent Category}</u></b>
     * of the selected {@link GuildChannel GuildChannel}.
     *
     * @param  category
     *         The new parent for the selected {@link GuildChannel GuildChannel}
     *
     * @throws IllegalStateException
     *         If the target is a category itself
     * @throws IllegalArgumentException
     *         If the provided category is not from the same Guild
     *
     * @return ChannelManager for chaining convenience
     *
     * @since  3.4.0
     */",net.dv8tion.jda.api.managers.channel.attribute
"public PermissionSet getEffectivePermissions() {
        return PermissionSet.of(data.permissions().toOptional().orElseThrow(IllegalStateException::new));
    }","/**
     * Gets the total permissions of the member in the channel, including overwrites.
     *
     * @return The permissions of the member.
     */",discord4j.core.object.command
"public LegacyGuildPruneCountSpec setDays(int days) {
        map.set(""days"", days);
        return this;
    }","/**
     * Set the number of days to count prune for.
     *
     * @param days the number of days
     * @return this spec
     */",discord4j.core.spec.legacy
"@Nonnull
    public Permission getPermission()
    {
        return permission;
    }","/**
     * The {@link net.dv8tion.jda.api.Permission Permission} that is required for the operation
     *
     * <p><b>If this is a {@link net.dv8tion.jda.api.exceptions.HierarchyException HierarchyException}
     * this will always be {@link net.dv8tion.jda.api.Permission#UNKNOWN Permission.UNKNOWN}!</b>
     *
     * @return The required {@link net.dv8tion.jda.api.Permission Permission}
     */",net.dv8tion.jda.api.exceptions
"public Optional<Role> getRole(Snowflake roleId) {
        return data.roles().toOptional()
                .map(roles -> roles.get(roleId.asString()))
                .map(data -> new Role(gateway, data, Objects.requireNonNull(guildId)));
    }","/**
     * Gets the resolved role with the given ID, if present.
     *
     * @param roleId the ID of the role to get
     * @return the resolved role, if present
     */",discord4j.core.object.command
"public <T> Flux<T> withLimiter(Publisher<T> stage) {
        return Flux.usingWhen(
                acquire(),
                resource -> stage,
                this::release);
    }","/**
     * Provides a scope to perform reactive operations under this limiter resources. Resources are acquired on
     * subscription and released when the given stage has completed or terminated with an error.
     *
     * @param stage a {@link Mono} that will manage this limiter resources
     * @param <T> the type of the stage supplier
     * @return a {@link Mono} where each subscription represents acquiring a rate limiter resource
     */",discord4j.rest.request
"public BanData getData() {
        return data;
    }","/**
     * Gets the data of the ban.
     *
     * @return The data of the ban.
     */",discord4j.core.object
"@Nonnull
    public List<Object> toList()
    {
        return data;
    }","/**
     * Converts this DataArray to a {@link java.util.List}.
     *
     * @return The resulting list
     */",net.dv8tion.jda.api.utils.data
Flux<Role> getGuildRoles(Snowflake guildId);,"/**
     * Requests to retrieve the guild's roles.
     * <p>
     * The order of items emitted by the returned {@code Flux} is unspecified. Use {@link OrderUtil#orderRoles(Flux)}
     * to consistently order roles.
     *
     * @param guildId The ID of the guild.
     * @return A {@link Flux} that continually emits the guild's {@link Role roles}. If an error is received, it is
     * emitted through the {@code Flux}.
     */",discord4j.core.retriever
"default boolean isMember(@Nonnull User user)
    {
        return getMember(user) != null;
    }","/**
     * Check whether {@link #getMember(User)} returns null for the provided user.
     *
     * @param  user
     *         The user to check
     *
     * @throws java.lang.IllegalArgumentException
     *         If provided with null
     *
     * @return True, if the provided user is a member of this team
     */",net.dv8tion.jda.api.entities
MessageChannel channel = union.asMessageChannel();,"/**
     * Casts this union to a {@link Category}.
     * This method exists for developer discoverability.
     *
     * <p>Note: This is effectively equivalent to using the cast operator:
     * <pre><code>
     * //These are the same!
     * Category channel = union.asCategory();
     * Category channel2 = (Category) union;
     * </code></pre>
     *
     * You can use {@link #getType()} to see if the channel is of type {@link ChannelType#CATEGORY} to validate
     * whether you can call this method in addition to normal instanceof checks: <code>channel instanceof Category</code>
     *
     * @throws IllegalStateException
     *         If the channel represented by this union is not actually a {@link Category}.
     *
     * @return The channel as a {@link Category}
     */",net.dv8tion.jda.api.entities.channel.unions
MilenageBuffer<T> leftCircularBitRotation(final byte numBits);,"/**
     * Performs a circular bit shift to the left.
     *
     * @param numBits  Number of bits to be shifted to the left.
     * @return  New result {@link threegpp.milenage.MilenageBuffer} object.
     */",threegpp.milenage
"public RConstants() {
        this(R1_SAMPLE, R2_SAMPLE, R3_SAMPLE, R4_SAMPLE, R5_SAMPLE);
    }","/**
     * Default constructor
     *
     * Creates object from sample values given in 3GPP TS 35.206
     */",threegpp.milenage
"static DispatchEventMapper noOp() {
        return new DispatchEventMapper() {
            @Override
            public <D, S, E extends Event> Mono<E> handle(DispatchContext<D, S> context) {
                return Mono.empty();
            }
        };
    }","/**
     * Create a {@link DispatchEventMapper} that doesn't process any dispatches
     *
     * @return a {@link DispatchEventMapper} that does nothing
     */",discord4j.core.event.dispatch
"@Override
    public CompletableFuture<Boolean> isConnected() {
        return CompletableFuture.supplyAsync(() -> this.hikariDataSource != null && !this.hikariDataSource.isClosed() && !this.hikariDataSource.isRunning());
    }",/** {@inheritDoc} */,io.github.heliumdioxid.database.mysql
FPlayer me = FPlayers.getInstance().getById(player.getUniqueId().toString());,"/**
     * Determine if a player has access to do a
     * action in a specific area.
     *
     * @param player    Player in question
     * @param location  Location action occurred
     * @param action    Action Type
     * @param justCheck Check access, or take action
     * @return
     */",com.massivecraft.factions.listeners
"public static GetEmojisInGuildAction getEmojisInGuild(long guildId) {
        return new GetEmojisInGuildAction(guildId);
    }","/**
     * Creates an action to retrieve data for all emojis present in a store for the given guild ID.
     *
     * @param guildId the guild ID
     * @return a new {@link GetEmojisInGuildAction}
     */",discord4j.common.store.action.read
"public Mono<Role> getRole() {
        return Mono.justOrEmpty(getRoleId()).flatMap(id -> gateway.getRoleById(getGuildId(), id));
    }","/**
     * Requests to retrieve the role this overwrite is associated to, if present.
     *
     * @return A {@link Mono} where, upon successful completion, emits the {@link Role} this overwrite is associated to,
     * if present. If an error is received, it is emitted through the {@code Mono}.
     */",discord4j.core.object
"@Nonnull
    @CheckReturnValue
    MemberAction setRoles(@Nullable Collection<Role> roles);","/**
     * Sets the roles of the user for the guild.
     * <br>This will then be visible with {@link net.dv8tion.jda.api.entities.Member#getRoles() Member.getRoles()}.
     *
     * @param  roles
     *         The roles, or {@code null}
     *
     * @throws IllegalArgumentException
     *         If one of the provided roles is null or not from the same guild
     *
     * @return The current MemberAction for chaining
     */",net.dv8tion.jda.api.requests.restaction
"@SuppressWarnings(""unchecked"")
	public static void register(@SuppressWarnings(""rawtypes"") Map tagletMap) {
		WRAPITaglet tag = new WRAPITaglet();
		Taglet t = (Taglet) tagletMap.get(tag.getName());
		if (t != null) {
			tagletMap.remove(tag.getName());
		}
		tagletMap.put(tag.getName(), tag);
	}","/**
	 * Register this Taglet.
	 * 
	 * @param tagletMap
	 *            the map to register this tag to.
	 */",net.winroad.wrdoclet.taglets
"public static GuildRoleDeleteAction guildRoleDelete(int shardIndex, GuildRoleDelete dispatch) {
        return new GuildRoleDeleteAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link GuildRoleDelete} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link GuildRoleDeleteAction}
     */",discord4j.common.store.action.gateway
"@Override
    public CompletableFuture<Optional<MySQLConnectionHandler>> connect() {
        return isConnected().thenApplyAsync(connected -> {
            if (connected) {
                if (this.mySQLConnectionHandler == null)
                    return Optional.empty();

                return Optional.of(this.mySQLConnectionHandler);
            }

            this.hikariDataSource = new HikariDataSource(this.mySQLConnectionConfig.getHikariConfig());

            this.mySQLConnectionHandler = new MySQLConnectionHandler(this);
            return Optional.of(this.mySQLConnectionHandler);
        });
    }",/** {@inheritDoc} */,io.github.heliumdioxid.database.mysql
"public List<Snowflake> getFailedUserIds() {
        return data.failedUsers().stream().map(Snowflake::of).collect(Collectors.toList());
    }","/**
     * Gets the unsuccessful banned users ids.
     *
     * @return A list with all the user ids.
     */",discord4j.core.object
"default Flux<Event> on(ReactiveEventAdapter adapter) {
        return on(Event.class)
                .flatMap(event -> Flux.defer(() -> adapter.hookOnEvent(event))
                        .contextWrite(ctx -> ctx.put(LogUtil.KEY_SHARD_ID, event.getShardInfo().getIndex()))
                        .onErrorResume(t -> {
                            log.warn(format(Context.of(LogUtil.KEY_SHARD_ID, event.getShardInfo().getIndex()),
                                    ""Error while handling {}""), event.getClass().getSimpleName(), t);
                            return Mono.empty();
                        })
                        .then(Mono.just(event)));
    }","/**
     * Applies a given {@code adapter} to all events from this dispatcher. Errors occurring within the mapper will be
     * logged and discarded, preventing the termination of the ""infinite"" event sequence. This variant allows you to
     * have a single subscriber to this dispatcher, which is useful to collect all startup events.
     * <p>
     * A standard approach to this method is to subclass {@link ReactiveEventAdapter}, overriding the methods you want
     * to listen for:
     * <pre>
     * client.on(new ReactiveEventAdapter() {
     *
     *     public Publisher&lt;?&gt; onReady(ReadyEvent event) {
     *         return Mono.fromRunnable(() -&gt;
     *                 System.out.println(""Connected as "" + event.getSelf().getTag()));
     *     }
     *
     *     public Publisher&lt;?&gt; onMessageCreate(MessageCreateEvent event) {
     *         if (event.getMessage().getContent().equals(""!ping"")) {
     *             return event.getMessage().getChannel()
     *                     .flatMap(channel -&gt; channel.createMessage(""Pong!""));
     *         }
     *         return Mono.empty();
     *     }
     *
     * }).subscribe(); // nothing happens until you subscribe
     * </pre>
     * <p>
     * Each method requires a {@link Publisher} return like {@link Mono} or {@link Flux} and all errors
     * will be logged and discarded. To use a synchronous implementation you can wrap your code with
     * {@link Mono#fromRunnable(Runnable)}.
     * <p>
     * Continuing the chain will require your own error handling strategy.
     * Check the docs for {@link #on(Class)} for more details.
     *
     * @param adapter an adapter meant to be subclassed with its appropriate methods overridden
     * @return a new {@link Flux} with the type resulting from the given event mapper
     */",discord4j.core.event
"public int getMaxLength()
        {
            return maxLength;
        }","/**
         * The maximum length. This is -1 if none has been set.
         *
         * @return Maximum length or -1
         */",net.dv8tion.jda.api.interactions.components.text
boolean hasFaction();,"/**
     * Check if a player has a faction
     *
     * @return boolean
     */",com.massivecraft.factions
"@Nonnull
    @CheckReturnValue
    default CommandEditAction addOption(@Nonnull OptionType type, @Nonnull String name, @Nonnull String description)
    {
        return addOption(type, name, description, false);
    }","/**
     * Adds an option to this command.
     * <br>This will replace any existing options/subcommands/groups on the command.
     *
     * <p>Required options must be added before non-required options!
     *
     * @param  type
     *         The {@link OptionType}
     * @param  name
     *         The lowercase option name, 1-32 characters
     * @param  description
     *         The option description, 1-100 characters
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If you try to mix subcommands/options/groups in one command.</li>
     *             <li>If the option type is {@link OptionType#SUB_COMMAND} or {@link OptionType#SUB_COMMAND_GROUP}.</li>
     *             <li>If this option is required and you already added a non-required option.</li>
     *             <li>If more than 25 options are provided.</li>
     *             <li>If null is provided</li>
     *         </ul>
     *
     * @return The CommandEditAction instance, for chaining
     */",net.dv8tion.jda.api.requests.restaction
Mono<Long> countPresences();,"/**
     * Counts the number of presences present in the store.
     *
     * @return A {@link Mono} emitting the presence count
     */",discord4j.common.store.api.layout
"@Nonnull
    @CheckReturnValue
    M setDefaultReaction(@Nullable Emoji emoji);","/**
     * Sets the <b><u>default reaction emoji</u></b> of the selected {@link IPostContainer}.
     * <br>This does not support custom emoji from other guilds.
     *
     * @param  emoji
     *         The new default reaction emoji, or null to unset.
     *
     * @return ChannelManager for chaining convenience
     *
     * @see    IPostContainer#getDefaultReaction()
     */",net.dv8tion.jda.api.managers.channel.attribute
"public int getPositionRaw()
    {
        return this.rawPosition;
    }","/**
     * The actual position of the {@link net.dv8tion.jda.api.entities.templates.TemplateChannel TemplateChannel} as stored and given by Discord.
     * Channel positions are actually based on a pairing of the creation time (as stored in the snowflake id)
     * and the position. If 2 or more channels share the same position then they are sorted based on their creation date.
     * The more recent a channel was created, the lower it is in the hierarchy.
     *
     * @return The true, Discord stored, position of the {@link net.dv8tion.jda.api.entities.templates.TemplateChannel TemplateChannel}.
     */",net.dv8tion.jda.api.entities.templates
"@Nullable
        @Blocking
        Response execute();","/**
         * Executes the request on the calling thread (blocking).
         * <br>This might return null when the request has been skipped while executing.
         * Retries for certain response codes are already handled by this method.
         *
         * <p>After completion, it is advised to use {@link #isDone()} to check whether the request should be retried.
         *
         * @return {@link Response} instance, used to update the rate-limit data
         */",net.dv8tion.jda.api.requests
"public long getTimestamp()
    {
        return timestamp;
    }","/**
     * The unix epoch timestamp for this markdown timestamp.
     * <br>This is similar to {@link System#currentTimeMillis()} and provided in millisecond precision for easier compatibility.
     * Discord uses seconds precision instead.
     *
     * @return The millisecond unix epoch timestamp
     */",net.dv8tion.jda.api.utils
"@Nullable
    public static DataObject optObject(@Nonnull DataArray root, @Nonnull String path)
    {
        if (!path.endsWith(""?""))
            path += ""?"";
        return get(root, path, DataObject::getObject, DataArray::getObject);
    }","/**
     * Parses the given {@code path} and finds the appropriate value within this {@link DataArray}.
     *
     * @param  root
     *         The root data array, which is the top level accessor.
     *         <br>The very first element in the path corresponds to a field of that name within this root object.
     * @param  path
     *         The path of the value, in accordance with the described grammar by {@link DataPath}.
     *         This must start with an index element, such as {@code ""[0]""}.
     *
     * @throws ParsingException
     *         If the path is invalid or resolving fails due to missing elements
     * @throws IndexOutOfBoundsException
     *         If any of the elements in the path refer to an array index that is out of bounds
     * @throws IllegalArgumentException
     *         If null is provided or the path is empty
     *
     * @return The DataObject at the given path, or null if the path resolves to an optional value that is missing.
     */",net.dv8tion.jda.api.utils.data
"@Nonnull
    @CheckReturnValue
    default CommandEditAction addSubcommandGroups(@Nonnull Collection<? extends SubcommandGroupData> groups)
    {
        Checks.noneNull(groups, ""SubcommandGroups"");
        return addSubcommandGroups(groups.toArray(new SubcommandGroupData[0]));
    }","/**
     * Add up to 25 {@link SubcommandGroupData Subcommand-Groups} to this command.
     * <br>This will replace any existing options/subcommands/groups on the command.
     *
     * @param  groups
     *         The subcommand groups to add
     *
     * @throws IllegalArgumentException
     *         If null is provided, or more than 25 subcommand groups are provided.
     *         Also throws if you try to mix subcommands/options/groups in one command.
     *
     * @return The CommandEditAction instance, for chaining
     */",net.dv8tion.jda.api.requests.restaction
"public boolean isFromThread()
    {
        return getChannelType().isThread();
    }","/**
     * If the message event was from a {@link ThreadChannel ThreadChannel}
     *
     * @return If the message event was from a ThreadChannel
     *
     * @see ChannelType#isThread()
     */",net.dv8tion.jda.api.events.message
List<String> getAllUserGesture();,"/**
     * Get all user gestures.
     *
     * @return the {@link List} of gestures
     */",jestures.core.tracking
"@Nonnull
    EnumSet<Permission> getInherit();","/**
     * EnumSet of all {@link net.dv8tion.jda.api.Permission Permission} that are unaffected by this override.
     * <br><u>Changes to the returned set do not affect this entity directly.</u>
     *
     * @return Possibly-empty set of unaffected {@link net.dv8tion.jda.api.Permission Permissions}.
     */",net.dv8tion.jda.api.entities
"public static ThreadListSyncAction threadListSync(int shardIndex, ThreadListSync dispatch) {
        return new ThreadListSyncAction(shardIndex, dispatch);
    }","/**
     * Creates an action to execute when a {@link ThreadListSync} is received from the gateway.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a new {@link ThreadListSyncAction}
     */",discord4j.common.store.action.gateway
"public long getApplicationIdLong()
    {
        return applicationId;
    }","/**
     * The id of the application of which privileges have been changed.
     *
     * @return id of the application of which privileges have been changed.
     */",net.dv8tion.jda.api.events.interaction.command
"@Nonnull
    public CompletableFuture<Path> downloadToPath(int width, int height)
    {
        return downloadToPath(getUrl(width, height));
    }","/**
     * Downloads the data of this attachment, at the specified width and height, and stores it in a file with the same name as the queried file name (this would be the last segment of the URL).
     * <br>The attachment, if an image, may be resized at any size, however if the size does not fit the ratio of the image, then it will be cropped as to fit the target size.
     * <br>If the attachment is not an image then the size parameters are ignored and the file is downloaded.
     *
     * <p><b>Implementation note:</b>
     *       The file is first downloaded into a temporary file, the file is then moved to its real destination when the download is complete.
     *
     * @param  width
     *         The width of this image, must be positive
     * @param  height
     *         The height of this image, must be positive
     *
     * @throws IllegalArgumentException
     *         If any of the follow checks are true
     *         <ul>
     *             <li>The requested width is negative or 0</li>
     *             <li>The requested height is negative or 0</li>
     *             <li>The URL's scheme is neither http or https</li>
     *         </ul>
     *
     * @return {@link CompletableFuture} which holds a {@link Path} which corresponds to the location the file has been downloaded.
     *
     */",net.dv8tion.jda.api.utils
GatewayDataUpdater getGatewayDataUpdater();,"/**
     * Returns a {@link GatewayDataUpdater} that defines action handlers for updates received from the Discord gateway.
     *
     * @return a {@link GatewayDataUpdater}
     */",discord4j.common.store.api.layout
"Mono<Void> onGuildScheduledEventCreate(int shardIndex, GuildScheduledEventCreate dispatch);","/**
     * Updates the internal state of the store according to the {@link GuildScheduledEventCreate} gateway dispatch. This
     * will typically perform an insert operation on a new {@link GuildScheduledEventData} in the store.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a {@link Mono} completing when the operation is done
     */",discord4j.common.store.api.layout
"@Nullable
    @Unmodifiable
    public List<IntegrationPrivilege> getCommandPrivileges(@Nonnull Command command)
    {
        Checks.notNull(command, ""Command"");
        return privileges.get(command.getId());
    }","/**
     * The {@link IntegrationPrivilege IntegrationPrivileges} that have been applied to the supplied {@link Command}.
     *
     * <br><b>If the privileges are ""Synced"" (No custom config applied), or this command no longer exists, this will return null.</b>
     *
     * <p>This does not include privileges applied to the application directly. Use {@link #getApplicationPrivileges()} for that.
     *
     * @param  command
     *         The {@link Command} to get the privileges from
     *
     * @throws IllegalArgumentException
     *         If the provided command is null
     *
     * @return Immutable List containing all IntegrationPrivileges that have been applied to the command in this guild.
     */",net.dv8tion.jda.api.interactions.commands
"public ImmutablePair(final L left, final R right) {
        super();
        this.left = left;
        this.right = right;
    }","/**
     * Create a new pair instance.
     *
     * @param left  the left value, may be null
     * @param right  the right value, may be null
     */",net.dv8tion.jda.internal.utils.tuple
"public Optional<Snowflake> getId() {
        return data.id().toOptional().map(Snowflake::of);
    }","/**
     * Gets	the id of the invoked command.
     *
     * @return The id of the invoked command.
     */",discord4j.core.object.command
"public Snowflake getUserId() {
        // ThreadMemberData#userId is absent in GUILD_CREATE (threads self is part of)
        // TODO D4J should be able to include the missing value with the self id when creating ThreadMember
        return Snowflake.of(data.userId().toOptional().orElseThrow(IllegalStateException::new));
    }","/**
     * Gets the ID of user.
     *
     * @return The ID of user.
     */",discord4j.core.object.entity
"@Nullable
    T getOldValue();","/**
     * The old value
     *
     * @return The old value
     */",net.dv8tion.jda.api.events
"default void onUserSpeakingModeUpdate(@Nonnull UserSnowflake user, @Nonnull EnumSet<SpeakingMode> modes) {}","/**
     * This method is used to listen for users changing their speaking mode.
     * <p>Whenever a user joins a voice channel, this is fired once to define the initial speaking modes.
     *
     * <p>To detect when a user is speaking, a {@link net.dv8tion.jda.api.audio.AudioReceiveHandler AudioReceiveHandler} should be used instead.
     *
     * <p>This method works independently of the user cache. The provided user might not be cached.
     *
     * @param user
     *        The user who changed their speaking mode
     * @param modes
     *        The new speaking modes of the user
     */",net.dv8tion.jda.api.audio.hooks
"public static long getUnsignedLong(@Nonnull DataObject root, @Nonnull String path, long fallback)
    {
        Long longValue = get(root, path, (obj, key) -> obj.getUnsignedLong(key, fallback), (arr, index) -> arr.getUnsignedLong(index, fallback));
        return longValue == null ? fallback : longValue;
    }","/**
     * Parses the given {@code path} and finds the appropriate value within this {@link DataObject}.
     * <br>If the resulting value is a string, this will parse the string using {@link Long#parseUnsignedLong(String)}.
     *
     * @param  root
     *         The root data object, which is the top level accessor.
     *         <br>The very first element in the path corresponds to a field of that name within this root object.
     * @param  path
     *         The path of the value, in accordance with the described grammar by {@link DataPath}.
     *         This must start with a name element, such as {@code ""foo""}.
     *
     * @throws ParsingException
     *         If the path is invalid or resolving fails due to missing elements
     * @throws IndexOutOfBoundsException
     *         If any of the elements in the path refer to an array index that is out of bounds
     * @throws IllegalArgumentException
     *         If null is provided or the path is empty
     *
     * @return The unsigned long value at the given path, returning the fallback if the path resolves to an optional value that is missing.
     */",net.dv8tion.jda.api.utils.data
"public Mono<StageInstance> startStageLive(String topic, @Nullable String reason) {
        return getClient()
                .getRestClient()
                .getStageInstanceService()
                .createStageInstance(StageInstanceCreateRequest.builder().channelId(this.getId().asLong()).topic(topic).build(), reason)
                .map(stageInstanceData -> new StageInstance(getClient(), stageInstanceData));
    }","/**
     * Requests to start a {@link StageInstance} on this channel.
     *
     * @param topic The topic of this {@link StageInstance}
     * @param reason The reason, if present
     * @return A {@link Mono} where, upon successful completion, emits a {@link StageInstance} created
     *         for this channel with the specified {@param topic}. If an error is received, it is emitted
     *         through the {@code Mono}
     */",discord4j.core.object.entity.channel
"@Nonnull
    @Override
    M reset(long... fields);","/**
     * Resets the fields specified by the provided bit-flag patterns.
     * <br>Example: {@code manager.reset(ChannelManager.NAME, ChannelManager.PARENT);}
     *
     * <p><b>Flag Constants:</b>
     * <ul>
     *     <li>{@link #NAME}</li>
     *     <li>{@link #PARENT}</li>
     *     <li>{@link #TOPIC}</li>
     *     <li>{@link #POSITION}</li>
     *     <li>{@link #NSFW}</li>
     *     <li>{@link #USERLIMIT}</li>
     *     <li>{@link #BITRATE}</li>
     *     <li>{@link #PERMISSION}</li>
     *     <li>{@link #TYPE}</li>
     *     <li>{@link #REGION}</li>
     *     <li>{@link #AUTO_ARCHIVE_DURATION}</li>
     *     <li>{@link #ARCHIVED}</li>
     *     <li>{@link #LOCKED}</li>
     *     <li>{@link #INVITEABLE}</li>
     *     <li>{@link #AVAILABLE_TAGS}</li>
     *     <li>{@link #APPLIED_TAGS}</li>
     *     <li>{@link #PINNED}</li>
     *     <li>{@link #REQUIRE_TAG}</li>
     *     <li>{@link #DEFAULT_REACTION}</li>
     *     <li>{@link #DEFAULT_LAYOUT}</li>
     *     <li>{@link #DEFAULT_SORT_ORDER}</li>
     *     <li>{@link #HIDE_MEDIA_DOWNLOAD_OPTIONS}</li>
     *     <li>{@link #DEFAULT_THREAD_SLOWMODE}</li>
     * </ul>
     *
     * @param  fields
     *         Integer values containing the flags to reset.
     *
     * @return ChannelManager for chaining convenience
     */",net.dv8tion.jda.api.managers.channel
"public Mono<Void> withGateway(Function<GatewayDiscordClient, Publisher<?>> whileConnectedFunction) {
        return gateway().withGateway(whileConnectedFunction);
    }","/**
     * Connect to the Discord Gateway upon subscription to acquire a {@link GatewayDiscordClient} instance and use it
     * in a declarative way, releasing the object once the derived usage {@link Function} completes, and the underlying
     * shard group disconnects, according to {@link GatewayDiscordClient#onDisconnect()}.
     * <p>
     * To further configure the bot features, refer to using {@link #gateway()}.
     * <p>
     * Calling this method is useful when you operate on the {@link GatewayDiscordClient} object using reactive API you
     * can compose within the scope of the given {@link Function}.
     *
     * @param whileConnectedFunction the {@link Function} to apply the <strong>connected</strong>
     * {@link GatewayDiscordClient} and trigger a processing pipeline from it.
     * @return an empty {@link Mono} completing after all resources have released
     */",discord4j.core
"@Nonnull
    @Unmodifiable
    default List<User> getUsers()
    {
        return this.getUserCache().asList();
    }","/**
     * An unmodifiable list of all {@link net.dv8tion.jda.api.entities.User Users} that share a
     * {@link net.dv8tion.jda.api.entities.Guild Guild} with the currently logged in account.
     * <br>This list will never contain duplicates and represents all {@link net.dv8tion.jda.api.entities.User Users}
     * that JDA can currently see.
     *
     * <p>If the developer is sharding, then only users from guilds connected to the specifically logged in
     * shard will be returned in the List.
     *
     * <p>This copies the backing store into a list. This means every call
     * creates a new list with O(n) complexity. It is recommended to store this into
     * a local variable or use {@link #getUserCache()} and use its more efficient
     * versions of handling these values.
     *
     * @return List of all {@link net.dv8tion.jda.api.entities.User Users} that are visible to JDA.
     */",net.dv8tion.jda.api.sharding
"@Nonnull
    @CheckReturnValue
    ScheduledEventManager setStatus(@Nonnull ScheduledEvent.Status status);","/**
     * Sets the status of the event. This method may be used to start, end or cancel an event but can only be used to
     * complete one of the following transitions:
     * <ol>
     *     <li>{@link ScheduledEvent.Status#SCHEDULED Status.SCHEDULED} to {@link ScheduledEvent.Status#ACTIVE Status.ACTIVE}</li>
     *     <li>{@link ScheduledEvent.Status#SCHEDULED Status.SCHEDULED} to {@link ScheduledEvent.Status#CANCELED Status.CANCELED}</li>
     *     <li>{@link ScheduledEvent.Status#ACTIVE Status.ACTIVE} to {@link ScheduledEvent.Status#COMPLETED Status.COMPLETED}</li>
     * </ol>
     *
     * @param  status
     *         The new status
     *
     * @throws java.lang.IllegalStateException
     *         If the transition between statuses does not follow one of the three documented above.
     * @throws IllegalArgumentException
     *         If the provided status is {@code null}
     *
     * @return ScheduledEventManager for chaining convenience
     *
     * @see    #getScheduledEvent()
     * @see    ScheduledEvent#getStatus()
     */",net.dv8tion.jda.api.managers
"public LegacyVoiceChannelEditSpec setRtcRegion(@Nullable String rtcRegion) {
        requestBuilder.rtcRegionOrNull(rtcRegion);
        return this;
    }","/**
     * Sets the channel voice region id, automatic if null.
     *
     * @param rtcRegion The channel voice region id, automatic if null.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public Builder maxConcurrency(int maxConcurrency) {
            if (maxConcurrency < 1) {
                throw new IllegalArgumentException(""maxConcurrency < 1"");
            }
            if ((maxConcurrency & (maxConcurrency - 1)) != 0) {
                throw new IllegalArgumentException(""maxConcurrency must be a power of 2"");
            }
            this.maxConcurrency = maxConcurrency;
            return this;
        }","/**
         * Set the sharding maximum concurrency to use when identifying to the Discord Gateway, determining the
         * amount of shards that will be concurrently identified. Defaults to 1. You should only change this value
         * if your bot is authorized to use the very large bot sharding system, otherwise you will hit a rate limit on
         * identifying. {@code maxConcurrency} always needs to be a power of 2 and must not be lower than one.
         *
         * @param maxConcurrency a positive number indicating the amount of shards that can be identified concurrently.
         * @return this builder
         */",discord4j.core.shard
"String encoding = response.header(""content-encoding"", """");","/**
     * Retrieves an {@link InputStream InputStream} for the provided {@link okhttp3.Response Response}.
     * <br>When the header for {@code content-encoding} is set with {@code gzip} this will wrap the body
     * in a {@link java.util.zip.GZIPInputStream GZIPInputStream} which decodes the data.
     *
     * <p>This is used to make usage of encoded responses more user-friendly in various parts of JDA.
     *
     * @param  response
     *         The not-null Response object
     *
     * @return InputStream representing the body of this response
     */",net.dv8tion.jda.internal.utils
"@Override
    public UpdateRate getUpdateRate() {
        return this.updateRate;
    }","/**
     * Get the update rate of the recognizer.
     *
     * @return the frame value
     */",jestures.core.recognition.gesturedata
"private void checkId(Integer id) {
        if (Objects.isNull(id) || id < 1) {
            throw new InvalidValidationException(""Invalid ID!"");
        }
    }","/**
     * This method is used to check id.
     *
     * @param id -> Incoming id cannot be less than one.
     * @since 1.0
     */",org.khasanof.citiesapi.service.user
"Disposable create(Scheduler scheduler, Flux<ByteBuf> in, PacketTransformer transformer, AudioReceiver receiver);","/**
     * Create a task that is capable of handling incoming audio packets.
     *
     * @param scheduler a dedicated {@link Scheduler} that can be used to run the task
     * @param in a sequence of raw incoming audio {@link ByteBuf} packets
     * @param transformer a strategy to decode a packet from a raw {@link ByteBuf}
     * @param receiver a strategy to consume decoded audio packets
     * @return a task that can receive audio and process it
     */",discord4j.voice
"public CategoryOrderActionImpl(Category category, int bucket)
    {
        super(category.getGuild(), bucket, getChannelsOfType(category, bucket));
        this.category = category;
    }","/**
     * Creates a new CategoryOrderAction for the specified {@link Category Category}
     *
     * @param  category
     *         The target {@link Category Category}
     *         which the new CategoryOrderAction will order channels from.
     * @param  bucket
     *         The sorting bucket
     */",net.dv8tion.jda.internal.requests.restaction.order
"public String getUrl()
        {
            return url;
        }","/**
         * The gateway endpoint
         *
         * @return The endpoint
         */",net.dv8tion.jda.api.utils
"@Nonnull
    @CheckReturnValue
    AutoCompleteCallbackAction addChoices(@Nonnull Collection<Command.Choice> choices);","/**
     * Add up to {@value OptionData#MAX_CHOICES} choices which can be picked from by the user.
     * <br>The user may continue writing inputs instead of using one of your choices.
     *
     * @param  choices
     *         The choice suggestions to present to the user, 0-{@link OptionData#MAX_CHOICES} choices
     *
     * @throws IllegalArgumentException
     *         <ul>
     *             <li>If {@code null} is provided</li>
     *             <li>If more than {@value OptionData#MAX_CHOICES} choices are added</li>
     *             <li>If any of the choice names are empty or longer than {@value OptionData#MAX_CHOICE_NAME_LENGTH}</li>
     *             <li>If the option type is incompatible with the choice type</li>
     *             <li>If the numeric value of any of the choices is not between {@value OptionData#MIN_NEGATIVE_NUMBER} and {@value OptionData#MAX_POSITIVE_NUMBER}</li>
     *             <li>If the string value of any of the choices is empty or longer than {@value OptionData#MAX_CHOICE_VALUE_LENGTH}</li>
     *         </ul>
     *
     * @return The same callback action, for chaining convenience
     */",net.dv8tion.jda.api.requests.restaction.interactions
"static EventDispatcher replayingWithSize(int historySize) {
        return builder()
                .eventSink(spec -> spec.replay().limit(historySize))
                .build();
    }","/**
     * Create an {@link EventDispatcher} that will replay up to {@code historySize} elements to late subscribers.
     * Be aware that using this type of dispatcher with operators such as {@link Flux#retry()} or
     * {@link Flux#repeat()} that re-subscribe to the dispatcher will observe the same elements as the backlog contains.
     *
     * @param historySize the backlog size or maximum items retained for replay
     * @return an {@link EventDispatcher} that will replay up to {@code historySize} elements to late subscribers
     */",discord4j.core.event
"@Nonnull
    public String getUrl()
    {
        return ""https://discord.gg/"" + code;
    }","/**
     * The invite url.
     * <br>This uses the {@code https://discord.gg/<code>} format.
     *
     * @return The invite url
     */",net.dv8tion.jda.api.events.guild.invite
"@Override
	public List<EmployeeProjectData> findByEmployeeId(final Integer employeeId) {
		return this.rep.findByEmployeeId(employeeId);
	}","/**
	 * @param employeeId
	 * @return list of EmployeeProjectData
	 */",com.pfa.app.service.impl
"@Deprecated
    static RequestQueueFactory backedByProcessor(Supplier<FluxProcessor<Object, Object>> processorSupplier,
                                                 FluxSink.OverflowStrategy overflowStrategy) {
        return new ProcessorRequestQueueFactory(processorSupplier, overflowStrategy);
    }","/**
     * Returns a factory of {@link RequestQueue} backed by a {@link FluxProcessor}.
     *
     * @param processorSupplier a Supplier that provides a processor. The Supplier <b>must</b> provide a new instance
     * every time it is called, and the processor must not be pre-filled with any elements, otherwise it may lead to
     * non-deterministic behavior.
     * @param overflowStrategy the overflow strategy to apply on the processor
     * @return a {@link RequestQueueFactory} backed by a {@link FluxProcessor}
     * @deprecated use the new Sinks API based approach at {@link #createFromSink(Function, EmissionStrategy)}
     */",discord4j.rest.request
"@Nonnull
    @CheckReturnValue
    default MessageEditAction editMessageComponentsById(long messageId, @Nonnull Collection<? extends LayoutComponent> components)
    {
        return editMessageComponentsById(Long.toUnsignedString(messageId), components);
    }","/**
     * Attempts to edit a message by its id in this MessageChannel.
     * <br>This will replace all the current {@link net.dv8tion.jda.api.interactions.components.Component Components},
     * such as {@link Button Buttons} or {@link SelectMenu SelectMenus} on this message.
     * The provided parameters are {@link LayoutComponent LayoutComponents} such as {@link ActionRow} which contain a list of components to arrange in the respective layout.
     *
     * <p>The following {@link net.dv8tion.jda.api.requests.ErrorResponse ErrorResponses} are possible:
     * <ul>
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#INVALID_AUTHOR_EDIT INVALID_AUTHOR_EDIT}
     *     <br>Attempted to edit a message that was not sent by the currently logged in account.
     *         Discord does not allow editing of other users' Messages!</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS}
     *     <br>The request was attempted after the account lost access to the {@link net.dv8tion.jda.api.entities.Guild Guild}
     *         typically due to being kicked or removed, or after {@link net.dv8tion.jda.api.Permission#VIEW_CHANNEL Permission.VIEW_CHANNEL}
     *         was revoked in the {@link GuildMessageChannel GuildMessageChannel}</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_MESSAGE UNKNOWN_MESSAGE}
     *     <br>The provided {@code messageId} is unknown in this MessageChannel, either due to the id being invalid, or
     *         the message it referred to has already been deleted. This might also be triggered for ephemeral messages.</li>
     *
     *     <li>{@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_CHANNEL UNKNOWN_CHANNEL}
     *     <br>The request was attempted after the channel was deleted.</li>
     * </ul>
     *
     * <p><b>Example</b><br>
     * <pre>{@code
     * List<ActionRow> rows = Arrays.asList(
     *   ActionRow.of(Button.success(""prompt:accept"", ""Accept""), Button.danger(""prompt:reject"", ""Reject"")), // 1st row below message
     *   ActionRow.of(Button.link(url, ""Help"")) // 2nd row below message
     * );
     * channel.editMessageComponentsById(messageId, rows).queue();
     * }</pre>
     *
     * @param  messageId
     *         The id referencing the Message that should be edited
     * @param  components
     *         Up to 5 new {@link LayoutComponent LayoutComponents} for the edited message, such as {@link ActionRow}
     *
     * @throws UnsupportedOperationException
     *         If the component layout is a custom implementation that is not supported by this interface
     * @throws IllegalArgumentException
     *         If any of the provided {@link LayoutComponent LayoutComponents} is null
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If this is a {@link GuildMessageChannel GuildMessageChannel} and this account does not have
     *         {@link net.dv8tion.jda.api.Permission#VIEW_CHANNEL Permission.VIEW_CHANNEL}
     *         or {@link net.dv8tion.jda.api.Permission#MESSAGE_SEND Permission.MESSAGE_SEND}
     *
     * @return {@link MessageEditAction}
     */",net.dv8tion.jda.api.entities.channel.middleman
"@Nonnull
    @CheckReturnValue
    default PermissionOverrideAction setDenied(@Nullable Collection<Permission> permissions)
    {
        if (permissions == null || permissions.isEmpty())
            return setDenied(0);
        Checks.noneNull(permissions, ""Permissions"");
        return setDenied(Permission.getRaw(permissions));
    }","/**
     * Sets the value of explicitly denied permissions
     * using a Collection of {@link net.dv8tion.jda.api.Permission Permissions}.
     * <br><b>Note: Permissions not marked as {@link net.dv8tion.jda.api.Permission#isChannel() isChannel()} will have no affect!</b>
     *
     * <p>Example: {@code setDeny(EnumSet.of(Permission.MESSAGE_SEND, Permission.MESSAGE_EXT_EMOJI))}</p>
     *
     * @param  permissions
     *         The Collection of Permissions representing the denied
     *         permissions for the new PermissionOverride.
     *         <br>If the provided value is {@code null} the permissions are reset to the default of none
     *
     * @throws java.lang.IllegalArgumentException
     *         If the any of the specified Permissions is {@code null}
     * @throws net.dv8tion.jda.api.exceptions.InsufficientPermissionException
     *         If the currently logged in account does not have {@link Permission#MANAGE_PERMISSIONS Permission.MANAGE_PERMISSIONS}
     *         on the channel and tries to set permissions it does not have in the channel
     *
     * @return The current PermissionOverrideAction - for chaining convenience
     *
     * @see    java.util.EnumSet EnumSet
     * @see    #setDenied(net.dv8tion.jda.api.Permission...) setDeny(Permission...)
     */",net.dv8tion.jda.api.requests.restaction
"@Nonnull
    public RestConfig setCustomBuilder(@Nullable Consumer<? super Request.Builder> customBuilder)
    {
        this.customBuilder = customBuilder;
        return this;
    }","/**
     * Provide an interceptor to update outgoing requests with custom headers or other modifications.
     * <br>Be careful not to replace any important headers, like authorization or content-type.
     * This is allowed by JDA, to allow proper use of {@link #setBaseUrl(String)} with any exotic proxy.
     *
     * <p><b>Example</b>
     * <pre>{@code
     * setCustomBuilder((request) -> {
     *     request.header(""X-My-Header"", ""MyValue"");
     * })
     * }</pre>
     *
     * @param  customBuilder
     *         The request interceptor, or null to disable
     *
     * @return The current RestConfig for chaining convenience
     */",net.dv8tion.jda.api.requests
"public void fillGestureCombo() {
        this.gestureComboBox.getItems().addAll(DefaultGesture.getAllDefaultGestures());
    }","/**
     * Fill gesture with default combo.
     *
     */",recorder.view
Matcher matcher = PARAMETER_PATTERN.matcher(template);,"/**
     * ""Overrides"" Object#toString behaviour for some objects, when we need to format them in a special form
     * For instance, this function on its creation handle long printing to make them unsigned only
     *
     * @param obj Object to handle
     * @return If handled, custom string value or else the object's toString return value
     */",discord4j.rest.util
int getMaxValues();,"/**
     * The maximum amount of values a user can select at once.
     *
     * @return The max values
     */",net.dv8tion.jda.api.interactions.components.selections
"@Nonnull
    @CheckReturnValue
    default ReplyCallbackAction deferReply(boolean ephemeral)
    {
        return deferReply().setEphemeral(ephemeral);
    }","/**
     * Acknowledge this interaction and defer the reply to a later time.
     * <br>This will send a {@code <Bot> is thinking...} message in chat that will be updated later through either {@link InteractionHook#editOriginal(String)} or {@link InteractionHook#sendMessage(String)}.
     *
     * <p>You can use {@code deferReply()} or {@code deferReply(false)} to send a non-ephemeral deferred reply. If your initial deferred message is ephemeral it cannot be made non-ephemeral later.
     * Your first message to the {@link InteractionHook} will inherit whether the message is ephemeral or not from this deferred reply.
     *
     * <p><b>You only have 3 seconds to acknowledge an interaction!</b>
     * <br>When the acknowledgement is sent after the interaction expired, you will receive {@link net.dv8tion.jda.api.requests.ErrorResponse#UNKNOWN_INTERACTION ErrorResponse.UNKNOWN_INTERACTION}.
     * <p>Use {@link #reply(String)} to reply directly.
     *
     * <p>Ephemeral messages have some limitations and will be removed once the user restarts their client.
     * <br>When a message is ephemeral, it will only be visible to the user that used the interaction.
     * <br>Limitations:
     * <ul>
     *     <li>Cannot contain any files/attachments</li>
     *     <li>Cannot be reacted to</li>
     *     <li>Cannot be retrieved</li>
     * </ul>
     *
     * @param  ephemeral
     *         True, if this message should only be visible to the interaction user
     *
     * @return {@link ReplyCallbackAction}
     */",net.dv8tion.jda.api.interactions.callbacks
"@Nonnull
    String getDefaultAvatarId();","/**
     * The Discord ID for this user's default avatar image.
     *
     * @return Never-null String containing the user's default avatar id.
     */",net.dv8tion.jda.api.entities
"public PermissionSet getPermissions() {
        return this.data.oauth2InstallParams()
            .toOptional()
            .map(InstallParamsData::permissions)
            .map(PermissionSet::of)
            .orElse(PermissionSet.none());
    }","/**
     * Gets the permissions of this configuration
     *
     * @return The permissions of this configuration
     */",discord4j.core.object
"public LegacyRoleEditSpec setColor(Color color) {
        requestBuilder.color(color.getRGB());
        return this;
    }","/**
     * Sets the new color of the {@link Role}.
     *
     * @param color The role color.
     * @return This spec.
     */",discord4j.core.spec.legacy
"@Nonnull
    public Map<DiscordLocale, String> toMap()
    {
        return Collections.unmodifiableMap(map);
    }","/**
     * Gets the <b>unmodifiable</b> map representing this LocalizationMap.
     * <br>The changes on this LocalizationMap will be reflected on the returned map.
     *
     * @return The unmodifiable map of this LocalizationMap
     */",net.dv8tion.jda.api.interactions.commands.localization
"public Optional<Snowflake> getChannelId() {
        return data.channelId().map(Snowflake::of);
    }","/**
     * Gets the channel ID this user is connected to, if present.
     *
     * @return The channel ID this user is connected to, if present.
     */",discord4j.core.object
public abstract boolean isValid();,"/**
     * Whether this builder has a valid state to build.
     * <br>If this is {@code false}, then {@link #build()} throws an {@link IllegalStateException}.
     * You can check the exception docs on {@link #build()} for specifics.
     *
     * @return True, if the builder is in a valid state
     */",net.dv8tion.jda.api.utils.messages
"public RestChannel getChannelById(final Snowflake channelId) {
        return RestChannel.create(this, channelId);
    }","/**
     * Requests to retrieve the channel represented by the supplied ID.
     *
     * @param channelId The ID of the channel.
     * @return A {@link RestChannel} as represented by the supplied ID.
     */",discord4j.rest
"public static int getInt(@Nonnull DataObject root, @Nonnull String path, int fallback)
    {
        Integer integer = get(root, path, (obj, key) -> obj.getInt(key, fallback), (arr, index) -> arr.getInt(index, fallback));
        return integer == null ? fallback : integer;
    }","/**
     * Parses the given {@code path} and finds the appropriate value within this {@link DataObject}.
     * <br>If the resulting value is a string, this will parse the string using {@link Integer#parseInt(String)}.
     *
     * @param  root
     *         The root data object, which is the top level accessor.
     *         <br>The very first element in the path corresponds to a field of that name within this root object.
     * @param  path
     *         The path of the value, in accordance with the described grammar by {@link DataPath}.
     *         This must start with a name element, such as {@code ""foo""}.
     *
     * @throws ParsingException
     *         If the path is invalid or resolving fails due to missing elements
     * @throws IndexOutOfBoundsException
     *         If any of the elements in the path refer to an array index that is out of bounds
     * @throws IllegalArgumentException
     *         If null is provided or the path is empty
     *
     * @return The int value at the given path, returning the fallback if the path resolves to an optional value that is missing.
     */",net.dv8tion.jda.api.utils.data
"public LegacyGuildEditSpec setBanner(@Nullable Image banner) {
        requestBuilder.banner(Possible.of(Optional.ofNullable(banner).map(Image::getDataUri)));
        return this;
    }","/**
     * Sets the image for the guild banner (when the server has the BANNER feature).
     *
     * @param banner The image for the guild banner.
     * @return This spec.
     */",discord4j.core.spec.legacy
"Mono<MemberData> onGuildMemberRemove(int shardIndex, GuildMemberRemove dispatch);","/**
     * Updates the internal state of the store according to the given {@link GuildMemberRemove} gateway dispatch.
     * This will typically perform a delete operation on the related {@link MemberData}, remove the ID of the
     * member from the list returned by {@link GuildData#members()}, and decrement the count returned by
     * {@link GuildData#memberCount()}.
     *
     * @param shardIndex the index of the shard where the dispatch comes from
     * @param dispatch   the dispatch data coming from Discord gateway
     * @return a {@link Mono} completing when the operation is done, optionally returning the old state of the
     * {@link MemberData} before the deletion
     */",discord4j.common.store.api.layout
"public Publisher<?> onNewsChannelCreate(NewsChannelCreateEvent event) {
        return Mono.empty();
    }","/**
     * Invoked when a guild news channel is created.
     *
     * @param event the event instance
     * @return a {@link Publisher} that completes when this listener has done processing the event, for example,
     * returning any {@link Mono}, {@link Flux} or synchronous code using {@link Mono#fromRunnable(Runnable)}.
     */",discord4j.core.event
"public LegacyMessageReferenceSpec setFailIfNotExists(boolean failIfNotExists) {
        requestBuilder.failIfNotExists(failIfNotExists);
        return this;
    }","/**
     * Sets to error if the referenced message doesn't exist instead of sending as a normal (non-reply) message,
     * default true.
     *
     * @param failIfNotExists Whether to error if the referenced message doesn't exist instead of sending as a normal
     *                        (non-reply) message.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public static final Route CURRENT_USER_MODIFY = Route.patch(""/users/@me"");","/**
     * Modify the requester's user account settings. Returns a user object on success.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/user#modify-current-user"">
     * https://discord.com/developers/docs/resources/user#modify-current-user</a>
     */",discord4j.rest.route
"public static final Route GUILD_PREVIEW_GET = Route.get(""/guilds/{guild.id}/preview"");","/**
     * Returns the guild preview object. If the user is not in the guild, then the guild must be Discoverable.
     *
     * @see <a href=""https://discord.com/developers/docs/resources/guild#get-guild-preview"">
     * https://discord.com/developers/docs/resources/guild#get-guild-preview</a>
     */",discord4j.rest.route
"public InteractionService getInteractionService() {
        return interactionService;
    }","/**
     * Access a low-level representation of the API endpoints for the Interaction resource.
     * @return a handle to perform low-level requests to the API
     */",discord4j.rest
"public LegacyEmbedCreateSpec setImage(String url) {
        requestBuilder.image(EmbedImageData.builder()
                .url(url)
                .build());
        return this;
    }","/**
     * Sets the image of the embed.
     *
     * @param url An image URL.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public String getCompleteUri() {
        return completeUri;
    }","/**
     * Return the compiled URI of this request.
     *
     * @return the compiled URI, containing the actual path variables
     */",discord4j.rest.request
"@RequestMapping(value = ""getSubscription/{userId}","/**
     * This method sends the DTO to the service's getSubscriptions method.
     *
     * @param userId -> Incoming id cannot be less than one.
     * @return Flux<CityGetDTO>
     * @since 1.0
     */",org.khasanof.citiesapi.controller.subscription
Properties properties = GitProperties.getProperties();,"/**
     * Initialize a new builder with the given token.
     *
     * @param token the bot token used to authenticate to Discord
     */",discord4j.core
void setGestureLength(GestureLength length);,"/**
     * Set the gesture length.
     *
     * @param length
     *            the length
     */",jestures.core.recognition.gesturedata
"public LegacyEmbedCreateSpec setThumbnail(String url) {
        requestBuilder.thumbnail(EmbedThumbnailData.builder()
                .url(url)
                .build());
        return this;
    }","/**
     * Sets the thumbnail of the embed.
     *
     * @param url An image URL.
     * @return This spec.
     */",discord4j.core.spec.legacy
"public static Function<RestInteraction, InteractionHandler> direct(Function<DirectInteraction,
            InteractionHandler> handlerFunction) {
        return new InteractionHandlerSpec(it -> NOOP_HANDLER_FUNCTION.apply(it), handlerFunction).build();
    }","/**
     * Create an interaction handler that only accepts direct message interactions, giving you access to methods
     * specific to {@link DirectInteraction} instances. To create an interaction handler capable of also handling
     * guild messages, see {@link #createHandler()}.
     *
     * @param handlerFunction a mapper to derive an {@link InteractionHandler} from a {@link DirectInteraction}
     * @return an interaction handling function, to be used in methods like
     * {@link #onGlobalCommand(ApplicationCommandRequest, Function)}
     */",discord4j.rest.interaction
"public Snowflake getId() {
        return permissions.getId();
    }","/**
     * Gets unique id of the command.
     *
     * @return The unique id of the command.
     */",discord4j.core.event.domain.command
"@Nonnull
    public CompletableFuture<InputStream> download()
    {
        return download(url);
    }","/**
     * Retrieves the {@link InputStream} of this file
     *
     * @return {@link CompletableFuture} which holds an {@link InputStream}, the {@link InputStream} must be closed manually
     */",net.dv8tion.jda.api.utils
